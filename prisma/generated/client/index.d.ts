
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CategoryTranslation
 * 
 */
export type CategoryTranslation = $Result.DefaultSelection<Prisma.$CategoryTranslationPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductTranslation
 * 
 */
export type ProductTranslation = $Result.DefaultSelection<Prisma.$ProductTranslationPayload>
/**
 * Model modelSpecification
 * 
 */
export type modelSpecification = $Result.DefaultSelection<Prisma.$modelSpecificationPayload>
/**
 * Model modelSpecificationTranslation
 * 
 */
export type modelSpecificationTranslation = $Result.DefaultSelection<Prisma.$modelSpecificationTranslationPayload>
/**
 * Model Advantage
 * 
 */
export type Advantage = $Result.DefaultSelection<Prisma.$AdvantagePayload>
/**
 * Model AdvantageTranslation
 * 
 */
export type AdvantageTranslation = $Result.DefaultSelection<Prisma.$AdvantageTranslationPayload>
/**
 * Model Specification
 * 
 */
export type Specification = $Result.DefaultSelection<Prisma.$SpecificationPayload>
/**
 * Model SpecificationTranslation
 * 
 */
export type SpecificationTranslation = $Result.DefaultSelection<Prisma.$SpecificationTranslationPayload>
/**
 * Model ApplicationData
 * 
 */
export type ApplicationData = $Result.DefaultSelection<Prisma.$ApplicationDataPayload>
/**
 * Model ApplicationDataTranslation
 * 
 */
export type ApplicationDataTranslation = $Result.DefaultSelection<Prisma.$ApplicationDataTranslationPayload>
/**
 * Model TechnicalSpecification
 * 
 */
export type TechnicalSpecification = $Result.DefaultSelection<Prisma.$TechnicalSpecificationPayload>
/**
 * Model TechnicalSpecificationTranslation
 * 
 */
export type TechnicalSpecificationTranslation = $Result.DefaultSelection<Prisma.$TechnicalSpecificationTranslationPayload>
/**
 * Model RelatedProduct
 * 
 */
export type RelatedProduct = $Result.DefaultSelection<Prisma.$RelatedProductPayload>
/**
 * Model RelatedProductTranslation
 * 
 */
export type RelatedProductTranslation = $Result.DefaultSelection<Prisma.$RelatedProductTranslationPayload>
/**
 * Model ProcessStep
 * 
 */
export type ProcessStep = $Result.DefaultSelection<Prisma.$ProcessStepPayload>
/**
 * Model ProcessStepTranslation
 * 
 */
export type ProcessStepTranslation = $Result.DefaultSelection<Prisma.$ProcessStepTranslationPayload>
/**
 * Model CTA
 * 
 */
export type CTA = $Result.DefaultSelection<Prisma.$CTAPayload>
/**
 * Model CTATranslation
 * 
 */
export type CTATranslation = $Result.DefaultSelection<Prisma.$CTATranslationPayload>
/**
 * Model TranslationTask
 * 
 */
export type TranslationTask = $Result.DefaultSelection<Prisma.$TranslationTaskPayload>
/**
 * Model ContactSubmission
 * 
 */
export type ContactSubmission = $Result.DefaultSelection<Prisma.$ContactSubmissionPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model ApiKeyUsage
 * 
 */
export type ApiKeyUsage = $Result.DefaultSelection<Prisma.$ApiKeyUsagePayload>
/**
 * Model ApiConfig
 * 
 */
export type ApiConfig = $Result.DefaultSelection<Prisma.$ApiConfigPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  user: 'user',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const LanguageCode: {
  en: 'en',
  fr: 'fr',
  hi: 'hi',
  ta: 'ta'
};

export type LanguageCode = (typeof LanguageCode)[keyof typeof LanguageCode]


export const MachineType: {
  Mechanical: 'Mechanical',
  Servo: 'Servo'
};

export type MachineType = (typeof MachineType)[keyof typeof MachineType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type LanguageCode = $Enums.LanguageCode

export const LanguageCode: typeof $Enums.LanguageCode

export type MachineType = $Enums.MachineType

export const MachineType: typeof $Enums.MachineType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoryTranslation`: Exposes CRUD operations for the **CategoryTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryTranslations
    * const categoryTranslations = await prisma.categoryTranslation.findMany()
    * ```
    */
  get categoryTranslation(): Prisma.CategoryTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productTranslation`: Exposes CRUD operations for the **ProductTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTranslations
    * const productTranslations = await prisma.productTranslation.findMany()
    * ```
    */
  get productTranslation(): Prisma.ProductTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelSpecification`: Exposes CRUD operations for the **modelSpecification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelSpecifications
    * const modelSpecifications = await prisma.modelSpecification.findMany()
    * ```
    */
  get modelSpecification(): Prisma.modelSpecificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelSpecificationTranslation`: Exposes CRUD operations for the **modelSpecificationTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelSpecificationTranslations
    * const modelSpecificationTranslations = await prisma.modelSpecificationTranslation.findMany()
    * ```
    */
  get modelSpecificationTranslation(): Prisma.modelSpecificationTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.advantage`: Exposes CRUD operations for the **Advantage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advantages
    * const advantages = await prisma.advantage.findMany()
    * ```
    */
  get advantage(): Prisma.AdvantageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.advantageTranslation`: Exposes CRUD operations for the **AdvantageTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvantageTranslations
    * const advantageTranslations = await prisma.advantageTranslation.findMany()
    * ```
    */
  get advantageTranslation(): Prisma.AdvantageTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specification`: Exposes CRUD operations for the **Specification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specifications
    * const specifications = await prisma.specification.findMany()
    * ```
    */
  get specification(): Prisma.SpecificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specificationTranslation`: Exposes CRUD operations for the **SpecificationTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecificationTranslations
    * const specificationTranslations = await prisma.specificationTranslation.findMany()
    * ```
    */
  get specificationTranslation(): Prisma.SpecificationTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationData`: Exposes CRUD operations for the **ApplicationData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicationData
    * const applicationData = await prisma.applicationData.findMany()
    * ```
    */
  get applicationData(): Prisma.ApplicationDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationDataTranslation`: Exposes CRUD operations for the **ApplicationDataTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicationDataTranslations
    * const applicationDataTranslations = await prisma.applicationDataTranslation.findMany()
    * ```
    */
  get applicationDataTranslation(): Prisma.ApplicationDataTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicalSpecification`: Exposes CRUD operations for the **TechnicalSpecification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicalSpecifications
    * const technicalSpecifications = await prisma.technicalSpecification.findMany()
    * ```
    */
  get technicalSpecification(): Prisma.TechnicalSpecificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicalSpecificationTranslation`: Exposes CRUD operations for the **TechnicalSpecificationTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicalSpecificationTranslations
    * const technicalSpecificationTranslations = await prisma.technicalSpecificationTranslation.findMany()
    * ```
    */
  get technicalSpecificationTranslation(): Prisma.TechnicalSpecificationTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relatedProduct`: Exposes CRUD operations for the **RelatedProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelatedProducts
    * const relatedProducts = await prisma.relatedProduct.findMany()
    * ```
    */
  get relatedProduct(): Prisma.RelatedProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relatedProductTranslation`: Exposes CRUD operations for the **RelatedProductTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelatedProductTranslations
    * const relatedProductTranslations = await prisma.relatedProductTranslation.findMany()
    * ```
    */
  get relatedProductTranslation(): Prisma.RelatedProductTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processStep`: Exposes CRUD operations for the **ProcessStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessSteps
    * const processSteps = await prisma.processStep.findMany()
    * ```
    */
  get processStep(): Prisma.ProcessStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processStepTranslation`: Exposes CRUD operations for the **ProcessStepTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessStepTranslations
    * const processStepTranslations = await prisma.processStepTranslation.findMany()
    * ```
    */
  get processStepTranslation(): Prisma.ProcessStepTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cTA`: Exposes CRUD operations for the **CTA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CTAS
    * const cTAS = await prisma.cTA.findMany()
    * ```
    */
  get cTA(): Prisma.CTADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cTATranslation`: Exposes CRUD operations for the **CTATranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CTATranslations
    * const cTATranslations = await prisma.cTATranslation.findMany()
    * ```
    */
  get cTATranslation(): Prisma.CTATranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.translationTask`: Exposes CRUD operations for the **TranslationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranslationTasks
    * const translationTasks = await prisma.translationTask.findMany()
    * ```
    */
  get translationTask(): Prisma.TranslationTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSubmission`: Exposes CRUD operations for the **ContactSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSubmissions
    * const contactSubmissions = await prisma.contactSubmission.findMany()
    * ```
    */
  get contactSubmission(): Prisma.ContactSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKeyUsage`: Exposes CRUD operations for the **ApiKeyUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeyUsages
    * const apiKeyUsages = await prisma.apiKeyUsage.findMany()
    * ```
    */
  get apiKeyUsage(): Prisma.ApiKeyUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiConfig`: Exposes CRUD operations for the **ApiConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiConfigs
    * const apiConfigs = await prisma.apiConfig.findMany()
    * ```
    */
  get apiConfig(): Prisma.ApiConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    CategoryTranslation: 'CategoryTranslation',
    Product: 'Product',
    ProductTranslation: 'ProductTranslation',
    modelSpecification: 'modelSpecification',
    modelSpecificationTranslation: 'modelSpecificationTranslation',
    Advantage: 'Advantage',
    AdvantageTranslation: 'AdvantageTranslation',
    Specification: 'Specification',
    SpecificationTranslation: 'SpecificationTranslation',
    ApplicationData: 'ApplicationData',
    ApplicationDataTranslation: 'ApplicationDataTranslation',
    TechnicalSpecification: 'TechnicalSpecification',
    TechnicalSpecificationTranslation: 'TechnicalSpecificationTranslation',
    RelatedProduct: 'RelatedProduct',
    RelatedProductTranslation: 'RelatedProductTranslation',
    ProcessStep: 'ProcessStep',
    ProcessStepTranslation: 'ProcessStepTranslation',
    CTA: 'CTA',
    CTATranslation: 'CTATranslation',
    TranslationTask: 'TranslationTask',
    ContactSubmission: 'ContactSubmission',
    ApiKey: 'ApiKey',
    ApiKeyUsage: 'ApiKeyUsage',
    ApiConfig: 'ApiConfig',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "category" | "categoryTranslation" | "product" | "productTranslation" | "modelSpecification" | "modelSpecificationTranslation" | "advantage" | "advantageTranslation" | "specification" | "specificationTranslation" | "applicationData" | "applicationDataTranslation" | "technicalSpecification" | "technicalSpecificationTranslation" | "relatedProduct" | "relatedProductTranslation" | "processStep" | "processStepTranslation" | "cTA" | "cTATranslation" | "translationTask" | "contactSubmission" | "apiKey" | "apiKeyUsage" | "apiConfig" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CategoryTranslation: {
        payload: Prisma.$CategoryTranslationPayload<ExtArgs>
        fields: Prisma.CategoryTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findFirst: {
            args: Prisma.CategoryTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          findMany: {
            args: Prisma.CategoryTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          create: {
            args: Prisma.CategoryTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          createMany: {
            args: Prisma.CategoryTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          delete: {
            args: Prisma.CategoryTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          update: {
            args: Prisma.CategoryTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CategoryTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
          }
          upsert: {
            args: Prisma.CategoryTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
          }
          aggregate: {
            args: Prisma.CategoryTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryTranslation>
          }
          groupBy: {
            args: Prisma.CategoryTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryTranslationCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductTranslation: {
        payload: Prisma.$ProductTranslationPayload<ExtArgs>
        fields: Prisma.ProductTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findFirst: {
            args: Prisma.ProductTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findMany: {
            args: Prisma.ProductTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          create: {
            args: Prisma.ProductTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          createMany: {
            args: Prisma.ProductTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          delete: {
            args: Prisma.ProductTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          update: {
            args: Prisma.ProductTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ProductTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ProductTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          aggregate: {
            args: Prisma.ProductTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTranslation>
          }
          groupBy: {
            args: Prisma.ProductTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationCountAggregateOutputType> | number
          }
        }
      }
      modelSpecification: {
        payload: Prisma.$modelSpecificationPayload<ExtArgs>
        fields: Prisma.modelSpecificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modelSpecificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modelSpecificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          findFirst: {
            args: Prisma.modelSpecificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modelSpecificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          findMany: {
            args: Prisma.modelSpecificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>[]
          }
          create: {
            args: Prisma.modelSpecificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          createMany: {
            args: Prisma.modelSpecificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.modelSpecificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>[]
          }
          delete: {
            args: Prisma.modelSpecificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          update: {
            args: Prisma.modelSpecificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          deleteMany: {
            args: Prisma.modelSpecificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modelSpecificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.modelSpecificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>[]
          }
          upsert: {
            args: Prisma.modelSpecificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationPayload>
          }
          aggregate: {
            args: Prisma.ModelSpecificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelSpecification>
          }
          groupBy: {
            args: Prisma.modelSpecificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelSpecificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.modelSpecificationCountArgs<ExtArgs>
            result: $Utils.Optional<ModelSpecificationCountAggregateOutputType> | number
          }
        }
      }
      modelSpecificationTranslation: {
        payload: Prisma.$modelSpecificationTranslationPayload<ExtArgs>
        fields: Prisma.modelSpecificationTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modelSpecificationTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modelSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          findFirst: {
            args: Prisma.modelSpecificationTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modelSpecificationTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          findMany: {
            args: Prisma.modelSpecificationTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>[]
          }
          create: {
            args: Prisma.modelSpecificationTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          createMany: {
            args: Prisma.modelSpecificationTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.modelSpecificationTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>[]
          }
          delete: {
            args: Prisma.modelSpecificationTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          update: {
            args: Prisma.modelSpecificationTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          deleteMany: {
            args: Prisma.modelSpecificationTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modelSpecificationTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.modelSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>[]
          }
          upsert: {
            args: Prisma.modelSpecificationTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelSpecificationTranslationPayload>
          }
          aggregate: {
            args: Prisma.ModelSpecificationTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelSpecificationTranslation>
          }
          groupBy: {
            args: Prisma.modelSpecificationTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelSpecificationTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.modelSpecificationTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ModelSpecificationTranslationCountAggregateOutputType> | number
          }
        }
      }
      Advantage: {
        payload: Prisma.$AdvantagePayload<ExtArgs>
        fields: Prisma.AdvantageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvantageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvantageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          findFirst: {
            args: Prisma.AdvantageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvantageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          findMany: {
            args: Prisma.AdvantageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>[]
          }
          create: {
            args: Prisma.AdvantageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          createMany: {
            args: Prisma.AdvantageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvantageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>[]
          }
          delete: {
            args: Prisma.AdvantageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          update: {
            args: Prisma.AdvantageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          deleteMany: {
            args: Prisma.AdvantageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvantageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdvantageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>[]
          }
          upsert: {
            args: Prisma.AdvantageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantagePayload>
          }
          aggregate: {
            args: Prisma.AdvantageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvantage>
          }
          groupBy: {
            args: Prisma.AdvantageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvantageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvantageCountArgs<ExtArgs>
            result: $Utils.Optional<AdvantageCountAggregateOutputType> | number
          }
        }
      }
      AdvantageTranslation: {
        payload: Prisma.$AdvantageTranslationPayload<ExtArgs>
        fields: Prisma.AdvantageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvantageTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvantageTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          findFirst: {
            args: Prisma.AdvantageTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvantageTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          findMany: {
            args: Prisma.AdvantageTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>[]
          }
          create: {
            args: Prisma.AdvantageTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          createMany: {
            args: Prisma.AdvantageTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvantageTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>[]
          }
          delete: {
            args: Prisma.AdvantageTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          update: {
            args: Prisma.AdvantageTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.AdvantageTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvantageTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdvantageTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>[]
          }
          upsert: {
            args: Prisma.AdvantageTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageTranslationPayload>
          }
          aggregate: {
            args: Prisma.AdvantageTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvantageTranslation>
          }
          groupBy: {
            args: Prisma.AdvantageTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvantageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvantageTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<AdvantageTranslationCountAggregateOutputType> | number
          }
        }
      }
      Specification: {
        payload: Prisma.$SpecificationPayload<ExtArgs>
        fields: Prisma.SpecificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          findFirst: {
            args: Prisma.SpecificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          findMany: {
            args: Prisma.SpecificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>[]
          }
          create: {
            args: Prisma.SpecificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          createMany: {
            args: Prisma.SpecificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>[]
          }
          delete: {
            args: Prisma.SpecificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          update: {
            args: Prisma.SpecificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          deleteMany: {
            args: Prisma.SpecificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>[]
          }
          upsert: {
            args: Prisma.SpecificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationPayload>
          }
          aggregate: {
            args: Prisma.SpecificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecification>
          }
          groupBy: {
            args: Prisma.SpecificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecificationCountArgs<ExtArgs>
            result: $Utils.Optional<SpecificationCountAggregateOutputType> | number
          }
        }
      }
      SpecificationTranslation: {
        payload: Prisma.$SpecificationTranslationPayload<ExtArgs>
        fields: Prisma.SpecificationTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecificationTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          findFirst: {
            args: Prisma.SpecificationTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecificationTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          findMany: {
            args: Prisma.SpecificationTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>[]
          }
          create: {
            args: Prisma.SpecificationTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          createMany: {
            args: Prisma.SpecificationTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecificationTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>[]
          }
          delete: {
            args: Prisma.SpecificationTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          update: {
            args: Prisma.SpecificationTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          deleteMany: {
            args: Prisma.SpecificationTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecificationTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>[]
          }
          upsert: {
            args: Prisma.SpecificationTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecificationTranslationPayload>
          }
          aggregate: {
            args: Prisma.SpecificationTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecificationTranslation>
          }
          groupBy: {
            args: Prisma.SpecificationTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecificationTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecificationTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<SpecificationTranslationCountAggregateOutputType> | number
          }
        }
      }
      ApplicationData: {
        payload: Prisma.$ApplicationDataPayload<ExtArgs>
        fields: Prisma.ApplicationDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          findFirst: {
            args: Prisma.ApplicationDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          findMany: {
            args: Prisma.ApplicationDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>[]
          }
          create: {
            args: Prisma.ApplicationDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          createMany: {
            args: Prisma.ApplicationDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          update: {
            args: Prisma.ApplicationDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataPayload>
          }
          aggregate: {
            args: Prisma.ApplicationDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationData>
          }
          groupBy: {
            args: Prisma.ApplicationDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationDataCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDataCountAggregateOutputType> | number
          }
        }
      }
      ApplicationDataTranslation: {
        payload: Prisma.$ApplicationDataTranslationPayload<ExtArgs>
        fields: Prisma.ApplicationDataTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationDataTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationDataTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationDataTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationDataTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          findMany: {
            args: Prisma.ApplicationDataTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>[]
          }
          create: {
            args: Prisma.ApplicationDataTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          createMany: {
            args: Prisma.ApplicationDataTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationDataTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDataTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          update: {
            args: Prisma.ApplicationDataTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDataTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationDataTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationDataTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationDataTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDataTranslationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationDataTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationDataTranslation>
          }
          groupBy: {
            args: Prisma.ApplicationDataTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDataTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationDataTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDataTranslationCountAggregateOutputType> | number
          }
        }
      }
      TechnicalSpecification: {
        payload: Prisma.$TechnicalSpecificationPayload<ExtArgs>
        fields: Prisma.TechnicalSpecificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicalSpecificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          findFirst: {
            args: Prisma.TechnicalSpecificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          findMany: {
            args: Prisma.TechnicalSpecificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          create: {
            args: Prisma.TechnicalSpecificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          createMany: {
            args: Prisma.TechnicalSpecificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          delete: {
            args: Prisma.TechnicalSpecificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          update: {
            args: Prisma.TechnicalSpecificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          deleteMany: {
            args: Prisma.TechnicalSpecificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicalSpecificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>[]
          }
          upsert: {
            args: Prisma.TechnicalSpecificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationPayload>
          }
          aggregate: {
            args: Prisma.TechnicalSpecificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicalSpecification>
          }
          groupBy: {
            args: Prisma.TechnicalSpecificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicalSpecificationCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationCountAggregateOutputType> | number
          }
        }
      }
      TechnicalSpecificationTranslation: {
        payload: Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>
        fields: Prisma.TechnicalSpecificationTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicalSpecificationTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicalSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          findFirst: {
            args: Prisma.TechnicalSpecificationTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicalSpecificationTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          findMany: {
            args: Prisma.TechnicalSpecificationTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>[]
          }
          create: {
            args: Prisma.TechnicalSpecificationTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          createMany: {
            args: Prisma.TechnicalSpecificationTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicalSpecificationTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>[]
          }
          delete: {
            args: Prisma.TechnicalSpecificationTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          update: {
            args: Prisma.TechnicalSpecificationTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          deleteMany: {
            args: Prisma.TechnicalSpecificationTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicalSpecificationTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicalSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>[]
          }
          upsert: {
            args: Prisma.TechnicalSpecificationTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalSpecificationTranslationPayload>
          }
          aggregate: {
            args: Prisma.TechnicalSpecificationTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicalSpecificationTranslation>
          }
          groupBy: {
            args: Prisma.TechnicalSpecificationTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicalSpecificationTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicalSpecificationTranslationCountAggregateOutputType> | number
          }
        }
      }
      RelatedProduct: {
        payload: Prisma.$RelatedProductPayload<ExtArgs>
        fields: Prisma.RelatedProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelatedProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelatedProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          findFirst: {
            args: Prisma.RelatedProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelatedProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          findMany: {
            args: Prisma.RelatedProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>[]
          }
          create: {
            args: Prisma.RelatedProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          createMany: {
            args: Prisma.RelatedProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelatedProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>[]
          }
          delete: {
            args: Prisma.RelatedProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          update: {
            args: Prisma.RelatedProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          deleteMany: {
            args: Prisma.RelatedProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelatedProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelatedProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>[]
          }
          upsert: {
            args: Prisma.RelatedProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductPayload>
          }
          aggregate: {
            args: Prisma.RelatedProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelatedProduct>
          }
          groupBy: {
            args: Prisma.RelatedProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelatedProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelatedProductCountArgs<ExtArgs>
            result: $Utils.Optional<RelatedProductCountAggregateOutputType> | number
          }
        }
      }
      RelatedProductTranslation: {
        payload: Prisma.$RelatedProductTranslationPayload<ExtArgs>
        fields: Prisma.RelatedProductTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelatedProductTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelatedProductTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          findFirst: {
            args: Prisma.RelatedProductTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelatedProductTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          findMany: {
            args: Prisma.RelatedProductTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>[]
          }
          create: {
            args: Prisma.RelatedProductTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          createMany: {
            args: Prisma.RelatedProductTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelatedProductTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>[]
          }
          delete: {
            args: Prisma.RelatedProductTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          update: {
            args: Prisma.RelatedProductTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          deleteMany: {
            args: Prisma.RelatedProductTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelatedProductTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelatedProductTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>[]
          }
          upsert: {
            args: Prisma.RelatedProductTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatedProductTranslationPayload>
          }
          aggregate: {
            args: Prisma.RelatedProductTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelatedProductTranslation>
          }
          groupBy: {
            args: Prisma.RelatedProductTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelatedProductTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelatedProductTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<RelatedProductTranslationCountAggregateOutputType> | number
          }
        }
      }
      ProcessStep: {
        payload: Prisma.$ProcessStepPayload<ExtArgs>
        fields: Prisma.ProcessStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findFirst: {
            args: Prisma.ProcessStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findMany: {
            args: Prisma.ProcessStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          create: {
            args: Prisma.ProcessStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          createMany: {
            args: Prisma.ProcessStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          delete: {
            args: Prisma.ProcessStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          update: {
            args: Prisma.ProcessStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          deleteMany: {
            args: Prisma.ProcessStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          upsert: {
            args: Prisma.ProcessStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          aggregate: {
            args: Prisma.ProcessStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessStep>
          }
          groupBy: {
            args: Prisma.ProcessStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessStepCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepCountAggregateOutputType> | number
          }
        }
      }
      ProcessStepTranslation: {
        payload: Prisma.$ProcessStepTranslationPayload<ExtArgs>
        fields: Prisma.ProcessStepTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessStepTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessStepTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          findFirst: {
            args: Prisma.ProcessStepTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessStepTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          findMany: {
            args: Prisma.ProcessStepTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>[]
          }
          create: {
            args: Prisma.ProcessStepTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          createMany: {
            args: Prisma.ProcessStepTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessStepTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>[]
          }
          delete: {
            args: Prisma.ProcessStepTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          update: {
            args: Prisma.ProcessStepTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ProcessStepTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessStepTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessStepTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>[]
          }
          upsert: {
            args: Prisma.ProcessStepTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepTranslationPayload>
          }
          aggregate: {
            args: Prisma.ProcessStepTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessStepTranslation>
          }
          groupBy: {
            args: Prisma.ProcessStepTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessStepTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepTranslationCountAggregateOutputType> | number
          }
        }
      }
      CTA: {
        payload: Prisma.$CTAPayload<ExtArgs>
        fields: Prisma.CTAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CTAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CTAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          findFirst: {
            args: Prisma.CTAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CTAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          findMany: {
            args: Prisma.CTAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>[]
          }
          create: {
            args: Prisma.CTACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          createMany: {
            args: Prisma.CTACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CTACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>[]
          }
          delete: {
            args: Prisma.CTADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          update: {
            args: Prisma.CTAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          deleteMany: {
            args: Prisma.CTADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CTAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CTAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>[]
          }
          upsert: {
            args: Prisma.CTAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTAPayload>
          }
          aggregate: {
            args: Prisma.CTAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCTA>
          }
          groupBy: {
            args: Prisma.CTAGroupByArgs<ExtArgs>
            result: $Utils.Optional<CTAGroupByOutputType>[]
          }
          count: {
            args: Prisma.CTACountArgs<ExtArgs>
            result: $Utils.Optional<CTACountAggregateOutputType> | number
          }
        }
      }
      CTATranslation: {
        payload: Prisma.$CTATranslationPayload<ExtArgs>
        fields: Prisma.CTATranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CTATranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CTATranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          findFirst: {
            args: Prisma.CTATranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CTATranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          findMany: {
            args: Prisma.CTATranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>[]
          }
          create: {
            args: Prisma.CTATranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          createMany: {
            args: Prisma.CTATranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CTATranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>[]
          }
          delete: {
            args: Prisma.CTATranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          update: {
            args: Prisma.CTATranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          deleteMany: {
            args: Prisma.CTATranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CTATranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CTATranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>[]
          }
          upsert: {
            args: Prisma.CTATranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTATranslationPayload>
          }
          aggregate: {
            args: Prisma.CTATranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCTATranslation>
          }
          groupBy: {
            args: Prisma.CTATranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CTATranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CTATranslationCountArgs<ExtArgs>
            result: $Utils.Optional<CTATranslationCountAggregateOutputType> | number
          }
        }
      }
      TranslationTask: {
        payload: Prisma.$TranslationTaskPayload<ExtArgs>
        fields: Prisma.TranslationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          findFirst: {
            args: Prisma.TranslationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          findMany: {
            args: Prisma.TranslationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>[]
          }
          create: {
            args: Prisma.TranslationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          createMany: {
            args: Prisma.TranslationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>[]
          }
          delete: {
            args: Prisma.TranslationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          update: {
            args: Prisma.TranslationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          deleteMany: {
            args: Prisma.TranslationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranslationTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>[]
          }
          upsert: {
            args: Prisma.TranslationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationTaskPayload>
          }
          aggregate: {
            args: Prisma.TranslationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslationTask>
          }
          groupBy: {
            args: Prisma.TranslationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationTaskCountAggregateOutputType> | number
          }
        }
      }
      ContactSubmission: {
        payload: Prisma.$ContactSubmissionPayload<ExtArgs>
        fields: Prisma.ContactSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ContactSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findMany: {
            args: Prisma.ContactSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          create: {
            args: Prisma.ContactSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          createMany: {
            args: Prisma.ContactSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ContactSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          update: {
            args: Prisma.ContactSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ContactSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ContactSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ContactSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSubmission>
          }
          groupBy: {
            args: Prisma.ContactSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      ApiKeyUsage: {
        payload: Prisma.$ApiKeyUsagePayload<ExtArgs>
        fields: Prisma.ApiKeyUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          findFirst: {
            args: Prisma.ApiKeyUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          findMany: {
            args: Prisma.ApiKeyUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>[]
          }
          create: {
            args: Prisma.ApiKeyUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          createMany: {
            args: Prisma.ApiKeyUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>[]
          }
          delete: {
            args: Prisma.ApiKeyUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          update: {
            args: Prisma.ApiKeyUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyUsagePayload>
          }
          aggregate: {
            args: Prisma.ApiKeyUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeyUsage>
          }
          groupBy: {
            args: Prisma.ApiKeyUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyUsageCountAggregateOutputType> | number
          }
        }
      }
      ApiConfig: {
        payload: Prisma.$ApiConfigPayload<ExtArgs>
        fields: Prisma.ApiConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          findFirst: {
            args: Prisma.ApiConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          findMany: {
            args: Prisma.ApiConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>[]
          }
          create: {
            args: Prisma.ApiConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          createMany: {
            args: Prisma.ApiConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>[]
          }
          delete: {
            args: Prisma.ApiConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          update: {
            args: Prisma.ApiConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          deleteMany: {
            args: Prisma.ApiConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>[]
          }
          upsert: {
            args: Prisma.ApiConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          aggregate: {
            args: Prisma.ApiConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiConfig>
          }
          groupBy: {
            args: Prisma.ApiConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ApiConfigCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    category?: CategoryOmit
    categoryTranslation?: CategoryTranslationOmit
    product?: ProductOmit
    productTranslation?: ProductTranslationOmit
    modelSpecification?: modelSpecificationOmit
    modelSpecificationTranslation?: modelSpecificationTranslationOmit
    advantage?: AdvantageOmit
    advantageTranslation?: AdvantageTranslationOmit
    specification?: SpecificationOmit
    specificationTranslation?: SpecificationTranslationOmit
    applicationData?: ApplicationDataOmit
    applicationDataTranslation?: ApplicationDataTranslationOmit
    technicalSpecification?: TechnicalSpecificationOmit
    technicalSpecificationTranslation?: TechnicalSpecificationTranslationOmit
    relatedProduct?: RelatedProductOmit
    relatedProductTranslation?: RelatedProductTranslationOmit
    processStep?: ProcessStepOmit
    processStepTranslation?: ProcessStepTranslationOmit
    cTA?: CTAOmit
    cTATranslation?: CTATranslationOmit
    translationTask?: TranslationTaskOmit
    contactSubmission?: ContactSubmissionOmit
    apiKey?: ApiKeyOmit
    apiKeyUsage?: ApiKeyUsageOmit
    apiConfig?: ApiConfigOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    translations: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    translations?: boolean | CategoryCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }


  /**
   * Count Type CategoryTranslationCountOutputType
   */

  export type CategoryTranslationCountOutputType = {
    products: number
  }

  export type CategoryTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryTranslationCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryTranslationCountOutputType without action
   */
  export type CategoryTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslationCountOutputType
     */
    select?: CategoryTranslationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryTranslationCountOutputType without action
   */
  export type CategoryTranslationCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    categories: number
    modelSpecification: number
    advantages: number
    specifications: number
    applicationData: number
    technicalSpecifications: number
    relatedProducts: number
    processSteps: number
    translations: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    modelSpecification?: boolean | ProductCountOutputTypeCountModelSpecificationArgs
    advantages?: boolean | ProductCountOutputTypeCountAdvantagesArgs
    specifications?: boolean | ProductCountOutputTypeCountSpecificationsArgs
    applicationData?: boolean | ProductCountOutputTypeCountApplicationDataArgs
    technicalSpecifications?: boolean | ProductCountOutputTypeCountTechnicalSpecificationsArgs
    relatedProducts?: boolean | ProductCountOutputTypeCountRelatedProductsArgs
    processSteps?: boolean | ProductCountOutputTypeCountProcessStepsArgs
    translations?: boolean | ProductCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountModelSpecificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelSpecificationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdvantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountApplicationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDataWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTechnicalSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRelatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type ProductTranslationCountOutputType
   */

  export type ProductTranslationCountOutputType = {
    categories: number
    advantages: number
    specifications: number
    applicationData: number
    technicalSpecifications: number
    relatedProducts: number
    processSteps: number
    modelSpecifications: number
  }

  export type ProductTranslationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductTranslationCountOutputTypeCountCategoriesArgs
    advantages?: boolean | ProductTranslationCountOutputTypeCountAdvantagesArgs
    specifications?: boolean | ProductTranslationCountOutputTypeCountSpecificationsArgs
    applicationData?: boolean | ProductTranslationCountOutputTypeCountApplicationDataArgs
    technicalSpecifications?: boolean | ProductTranslationCountOutputTypeCountTechnicalSpecificationsArgs
    relatedProducts?: boolean | ProductTranslationCountOutputTypeCountRelatedProductsArgs
    processSteps?: boolean | ProductTranslationCountOutputTypeCountProcessStepsArgs
    modelSpecifications?: boolean | ProductTranslationCountOutputTypeCountModelSpecificationsArgs
  }

  // Custom InputTypes
  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslationCountOutputType
     */
    select?: ProductTranslationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountAdvantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificationWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountApplicationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDataWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountTechnicalSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountRelatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedProductWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * ProductTranslationCountOutputType without action
   */
  export type ProductTranslationCountOutputTypeCountModelSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelSpecificationWhereInput
  }


  /**
   * Count Type ModelSpecificationCountOutputType
   */

  export type ModelSpecificationCountOutputType = {
    products: number
    translations: number
    productTranslations: number
  }

  export type ModelSpecificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ModelSpecificationCountOutputTypeCountProductsArgs
    translations?: boolean | ModelSpecificationCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | ModelSpecificationCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ModelSpecificationCountOutputType without action
   */
  export type ModelSpecificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelSpecificationCountOutputType
     */
    select?: ModelSpecificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelSpecificationCountOutputType without action
   */
  export type ModelSpecificationCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ModelSpecificationCountOutputType without action
   */
  export type ModelSpecificationCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelSpecificationTranslationWhereInput
  }

  /**
   * ModelSpecificationCountOutputType without action
   */
  export type ModelSpecificationCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type AdvantageCountOutputType
   */

  export type AdvantageCountOutputType = {
    products: number
    translations: number
    productTranslations: number
  }

  export type AdvantageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | AdvantageCountOutputTypeCountProductsArgs
    translations?: boolean | AdvantageCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | AdvantageCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * AdvantageCountOutputType without action
   */
  export type AdvantageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageCountOutputType
     */
    select?: AdvantageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvantageCountOutputType without action
   */
  export type AdvantageCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * AdvantageCountOutputType without action
   */
  export type AdvantageCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageTranslationWhereInput
  }

  /**
   * AdvantageCountOutputType without action
   */
  export type AdvantageCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type SpecificationCountOutputType
   */

  export type SpecificationCountOutputType = {
    translations: number
    productTranslations: number
  }

  export type SpecificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | SpecificationCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | SpecificationCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * SpecificationCountOutputType without action
   */
  export type SpecificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationCountOutputType
     */
    select?: SpecificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecificationCountOutputType without action
   */
  export type SpecificationCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificationTranslationWhereInput
  }

  /**
   * SpecificationCountOutputType without action
   */
  export type SpecificationCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type ApplicationDataCountOutputType
   */

  export type ApplicationDataCountOutputType = {
    translations: number
    productTranslations: number
  }

  export type ApplicationDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | ApplicationDataCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | ApplicationDataCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationDataCountOutputType without action
   */
  export type ApplicationDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataCountOutputType
     */
    select?: ApplicationDataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationDataCountOutputType without action
   */
  export type ApplicationDataCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDataTranslationWhereInput
  }

  /**
   * ApplicationDataCountOutputType without action
   */
  export type ApplicationDataCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type TechnicalSpecificationCountOutputType
   */

  export type TechnicalSpecificationCountOutputType = {
    translations: number
    productTranslations: number
  }

  export type TechnicalSpecificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | TechnicalSpecificationCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | TechnicalSpecificationCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * TechnicalSpecificationCountOutputType without action
   */
  export type TechnicalSpecificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationCountOutputType
     */
    select?: TechnicalSpecificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TechnicalSpecificationCountOutputType without action
   */
  export type TechnicalSpecificationCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationTranslationWhereInput
  }

  /**
   * TechnicalSpecificationCountOutputType without action
   */
  export type TechnicalSpecificationCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type RelatedProductCountOutputType
   */

  export type RelatedProductCountOutputType = {
    translations: number
    productTranslations: number
  }

  export type RelatedProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | RelatedProductCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | RelatedProductCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * RelatedProductCountOutputType without action
   */
  export type RelatedProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductCountOutputType
     */
    select?: RelatedProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelatedProductCountOutputType without action
   */
  export type RelatedProductCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedProductTranslationWhereInput
  }

  /**
   * RelatedProductCountOutputType without action
   */
  export type RelatedProductCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type ProcessStepCountOutputType
   */

  export type ProcessStepCountOutputType = {
    translations: number
    productTranslations: number
  }

  export type ProcessStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | ProcessStepCountOutputTypeCountTranslationsArgs
    productTranslations?: boolean | ProcessStepCountOutputTypeCountProductTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepCountOutputType
     */
    select?: ProcessStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepTranslationWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountProductTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type CTACountOutputType
   */

  export type CTACountOutputType = {
    translations: number
  }

  export type CTACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | CTACountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * CTACountOutputType without action
   */
  export type CTACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTACountOutputType
     */
    select?: CTACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CTACountOutputType without action
   */
  export type CTACountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CTATranslationWhereInput
  }


  /**
   * Count Type ApiKeyCountOutputType
   */

  export type ApiKeyCountOutputType = {
    usageLogs: number
    auditLogs: number
    translationTasks: number
  }

  export type ApiKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | ApiKeyCountOutputTypeCountUsageLogsArgs
    auditLogs?: boolean | ApiKeyCountOutputTypeCountAuditLogsArgs
    translationTasks?: boolean | ApiKeyCountOutputTypeCountTranslationTasksArgs
  }

  // Custom InputTypes
  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyCountOutputType
     */
    select?: ApiKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageWhereInput
  }

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountTranslationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationTaskWhereInput
  }


  /**
   * Count Type ApiConfigCountOutputType
   */

  export type ApiConfigCountOutputType = {
    auditLogs: number
  }

  export type ApiConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ApiConfigCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ApiConfigCountOutputType without action
   */
  export type ApiConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfigCountOutputType
     */
    select?: ApiConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiConfigCountOutputType without action
   */
  export type ApiConfigCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    otpToken: string | null
    otpExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    refreshToken: string | null
    isApproved: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    otpToken: string | null
    otpExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    refreshToken: string | null
    isApproved: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    avatar: number
    otpToken: number
    otpExpires: number
    createdAt: number
    updatedAt: number
    role: number
    refreshToken: number
    isApproved: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    otpToken?: true
    otpExpires?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    refreshToken?: true
    isApproved?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    otpToken?: true
    otpExpires?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    refreshToken?: true
    isApproved?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    otpToken?: true
    otpExpires?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    refreshToken?: true
    isApproved?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    password: string
    avatar: string | null
    otpToken: string | null
    otpExpires: Date | null
    createdAt: Date
    updatedAt: Date
    role: $Enums.Role
    refreshToken: string | null
    isApproved: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    otpToken?: boolean
    otpExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    refreshToken?: boolean
    isApproved?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    otpToken?: boolean
    otpExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    refreshToken?: boolean
    isApproved?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    otpToken?: boolean
    otpExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    refreshToken?: boolean
    isApproved?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    otpToken?: boolean
    otpExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    refreshToken?: boolean
    isApproved?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "avatar" | "otpToken" | "otpExpires" | "createdAt" | "updatedAt" | "role" | "refreshToken" | "isApproved", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      password: string
      avatar: string | null
      otpToken: string | null
      otpExpires: Date | null
      createdAt: Date
      updatedAt: Date
      role: $Enums.Role
      refreshToken: string | null
      isApproved: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly otpToken: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly isApproved: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name_en: string | null
    category_icon: string | null
    category_image: string | null
    category_Alt_en: string | null
    categoryLink_en: string | null
    specification_image: string | null
    specification_image_alt: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name_en: string | null
    category_icon: string | null
    category_image: string | null
    category_Alt_en: string | null
    categoryLink_en: string | null
    specification_image: string | null
    specification_image_alt: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name_en: number
    category_icon: number
    category_image: number
    category_Alt_en: number
    categoryLink_en: number
    specification_image: number
    specification_image_alt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name_en?: true
    category_icon?: true
    category_image?: true
    category_Alt_en?: true
    categoryLink_en?: true
    specification_image?: true
    specification_image_alt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name_en?: true
    category_icon?: true
    category_image?: true
    category_Alt_en?: true
    categoryLink_en?: true
    specification_image?: true
    specification_image_alt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name_en?: true
    category_icon?: true
    category_image?: true
    category_Alt_en?: true
    categoryLink_en?: true
    specification_image?: true
    specification_image_alt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name_en: string
    category_icon: string | null
    category_image: string | null
    category_Alt_en: string | null
    categoryLink_en: string | null
    specification_image: string | null
    specification_image_alt: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    category_icon?: boolean
    category_image?: boolean
    category_Alt_en?: boolean
    categoryLink_en?: boolean
    specification_image?: boolean
    specification_image_alt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    translations?: boolean | Category$translationsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    category_icon?: boolean
    category_image?: boolean
    category_Alt_en?: boolean
    categoryLink_en?: boolean
    specification_image?: boolean
    specification_image_alt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    category_icon?: boolean
    category_image?: boolean
    category_Alt_en?: boolean
    categoryLink_en?: boolean
    specification_image?: boolean
    specification_image_alt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name_en?: boolean
    category_icon?: boolean
    category_image?: boolean
    category_Alt_en?: boolean
    categoryLink_en?: boolean
    specification_image?: boolean
    specification_image_alt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "category_icon" | "category_image" | "category_Alt_en" | "categoryLink_en" | "specification_image" | "specification_image_alt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    translations?: boolean | Category$translationsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      translations: Prisma.$CategoryTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name_en: string
      category_icon: string | null
      category_image: string | null
      category_Alt_en: string | null
      categoryLink_en: string | null
      specification_image: string | null
      specification_image_alt: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends Category$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Category$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name_en: FieldRef<"Category", 'String'>
    readonly category_icon: FieldRef<"Category", 'String'>
    readonly category_image: FieldRef<"Category", 'String'>
    readonly category_Alt_en: FieldRef<"Category", 'String'>
    readonly categoryLink_en: FieldRef<"Category", 'String'>
    readonly specification_image: FieldRef<"Category", 'String'>
    readonly specification_image_alt: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category.translations
   */
  export type Category$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model CategoryTranslation
   */

  export type AggregateCategoryTranslation = {
    _count: CategoryTranslationCountAggregateOutputType | null
    _avg: CategoryTranslationAvgAggregateOutputType | null
    _sum: CategoryTranslationSumAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  export type CategoryTranslationAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type CategoryTranslationSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type CategoryTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    name: string | null
    iconAlt: string | null
    categoryLink: string | null
    description: string | null
    categoryId: number | null
  }

  export type CategoryTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    name: string | null
    iconAlt: string | null
    categoryLink: string | null
    description: string | null
    categoryId: number | null
  }

  export type CategoryTranslationCountAggregateOutputType = {
    id: number
    language: number
    name: number
    iconAlt: number
    categoryLink: number
    description: number
    categoryId: number
    _all: number
  }


  export type CategoryTranslationAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type CategoryTranslationSumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type CategoryTranslationMinAggregateInputType = {
    id?: true
    language?: true
    name?: true
    iconAlt?: true
    categoryLink?: true
    description?: true
    categoryId?: true
  }

  export type CategoryTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    name?: true
    iconAlt?: true
    categoryLink?: true
    description?: true
    categoryId?: true
  }

  export type CategoryTranslationCountAggregateInputType = {
    id?: true
    language?: true
    name?: true
    iconAlt?: true
    categoryLink?: true
    description?: true
    categoryId?: true
    _all?: true
  }

  export type CategoryTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslation to aggregate.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryTranslations
    **/
    _count?: true | CategoryTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type GetCategoryTranslationAggregateType<T extends CategoryTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryTranslation[P]>
      : GetScalarType<T[P], AggregateCategoryTranslation[P]>
  }




  export type CategoryTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithAggregationInput | CategoryTranslationOrderByWithAggregationInput[]
    by: CategoryTranslationScalarFieldEnum[] | CategoryTranslationScalarFieldEnum
    having?: CategoryTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryTranslationCountAggregateInputType | true
    _avg?: CategoryTranslationAvgAggregateInputType
    _sum?: CategoryTranslationSumAggregateInputType
    _min?: CategoryTranslationMinAggregateInputType
    _max?: CategoryTranslationMaxAggregateInputType
  }

  export type CategoryTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    name: string
    iconAlt: string | null
    categoryLink: string | null
    description: string | null
    categoryId: number
    _count: CategoryTranslationCountAggregateOutputType | null
    _avg: CategoryTranslationAvgAggregateOutputType | null
    _sum: CategoryTranslationSumAggregateOutputType | null
    _min: CategoryTranslationMinAggregateOutputType | null
    _max: CategoryTranslationMaxAggregateOutputType | null
  }

  type GetCategoryTranslationGroupByPayload<T extends CategoryTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CategoryTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    iconAlt?: boolean
    categoryLink?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    products?: boolean | CategoryTranslation$productsArgs<ExtArgs>
    _count?: boolean | CategoryTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    iconAlt?: boolean
    categoryLink?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    iconAlt?: boolean
    categoryLink?: boolean
    description?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryTranslation"]>

  export type CategoryTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    name?: boolean
    iconAlt?: boolean
    categoryLink?: boolean
    description?: boolean
    categoryId?: boolean
  }

  export type CategoryTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "name" | "iconAlt" | "categoryLink" | "description" | "categoryId", ExtArgs["result"]["categoryTranslation"]>
  export type CategoryTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    products?: boolean | CategoryTranslation$productsArgs<ExtArgs>
    _count?: boolean | CategoryTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CategoryTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CategoryTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryTranslation"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      products: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      name: string
      iconAlt: string | null
      categoryLink: string | null
      description: string | null
      categoryId: number
    }, ExtArgs["result"]["categoryTranslation"]>
    composites: {}
  }

  type CategoryTranslationGetPayload<S extends boolean | null | undefined | CategoryTranslationDefaultArgs> = $Result.GetResult<Prisma.$CategoryTranslationPayload, S>

  type CategoryTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryTranslationCountAggregateInputType | true
    }

  export interface CategoryTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryTranslation'], meta: { name: 'CategoryTranslation' } }
    /**
     * Find zero or one CategoryTranslation that matches the filter.
     * @param {CategoryTranslationFindUniqueArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryTranslationFindUniqueArgs>(args: SelectSubset<T, CategoryTranslationFindUniqueArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryTranslationFindUniqueOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryTranslationFindFirstArgs>(args?: SelectSubset<T, CategoryTranslationFindFirstArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindFirstOrThrowArgs} args - Arguments to find a CategoryTranslation
     * @example
     * // Get one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany()
     * 
     * // Get first 10 CategoryTranslations
     * const categoryTranslations = await prisma.categoryTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryTranslationFindManyArgs>(args?: SelectSubset<T, CategoryTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryTranslation.
     * @param {CategoryTranslationCreateArgs} args - Arguments to create a CategoryTranslation.
     * @example
     * // Create one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.create({
     *   data: {
     *     // ... data to create a CategoryTranslation
     *   }
     * })
     * 
     */
    create<T extends CategoryTranslationCreateArgs>(args: SelectSubset<T, CategoryTranslationCreateArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryTranslations.
     * @param {CategoryTranslationCreateManyArgs} args - Arguments to create many CategoryTranslations.
     * @example
     * // Create many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryTranslationCreateManyArgs>(args?: SelectSubset<T, CategoryTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryTranslations and returns the data saved in the database.
     * @param {CategoryTranslationCreateManyAndReturnArgs} args - Arguments to create many CategoryTranslations.
     * @example
     * // Create many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryTranslations and only return the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryTranslation.
     * @param {CategoryTranslationDeleteArgs} args - Arguments to delete one CategoryTranslation.
     * @example
     * // Delete one CategoryTranslation
     * const CategoryTranslation = await prisma.categoryTranslation.delete({
     *   where: {
     *     // ... filter to delete one CategoryTranslation
     *   }
     * })
     * 
     */
    delete<T extends CategoryTranslationDeleteArgs>(args: SelectSubset<T, CategoryTranslationDeleteArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryTranslation.
     * @param {CategoryTranslationUpdateArgs} args - Arguments to update one CategoryTranslation.
     * @example
     * // Update one CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryTranslationUpdateArgs>(args: SelectSubset<T, CategoryTranslationUpdateArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryTranslations.
     * @param {CategoryTranslationDeleteManyArgs} args - Arguments to filter CategoryTranslations to delete.
     * @example
     * // Delete a few CategoryTranslations
     * const { count } = await prisma.categoryTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryTranslationDeleteManyArgs>(args?: SelectSubset<T, CategoryTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryTranslationUpdateManyArgs>(args: SelectSubset<T, CategoryTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryTranslations and returns the data updated in the database.
     * @param {CategoryTranslationUpdateManyAndReturnArgs} args - Arguments to update many CategoryTranslations.
     * @example
     * // Update many CategoryTranslations
     * const categoryTranslation = await prisma.categoryTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryTranslations and only return the `id`
     * const categoryTranslationWithIdOnly = await prisma.categoryTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryTranslation.
     * @param {CategoryTranslationUpsertArgs} args - Arguments to update or create a CategoryTranslation.
     * @example
     * // Update or create a CategoryTranslation
     * const categoryTranslation = await prisma.categoryTranslation.upsert({
     *   create: {
     *     // ... data to create a CategoryTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryTranslation we want to update
     *   }
     * })
     */
    upsert<T extends CategoryTranslationUpsertArgs>(args: SelectSubset<T, CategoryTranslationUpsertArgs<ExtArgs>>): Prisma__CategoryTranslationClient<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationCountArgs} args - Arguments to filter CategoryTranslations to count.
     * @example
     * // Count the number of CategoryTranslations
     * const count = await prisma.categoryTranslation.count({
     *   where: {
     *     // ... the filter for the CategoryTranslations we want to count
     *   }
     * })
    **/
    count<T extends CategoryTranslationCountArgs>(
      args?: Subset<T, CategoryTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryTranslationAggregateArgs>(args: Subset<T, CategoryTranslationAggregateArgs>): Prisma.PrismaPromise<GetCategoryTranslationAggregateType<T>>

    /**
     * Group by CategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CategoryTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryTranslation model
   */
  readonly fields: CategoryTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends CategoryTranslation$productsArgs<ExtArgs> = {}>(args?: Subset<T, CategoryTranslation$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryTranslation model
   */
  interface CategoryTranslationFieldRefs {
    readonly id: FieldRef<"CategoryTranslation", 'Int'>
    readonly language: FieldRef<"CategoryTranslation", 'LanguageCode'>
    readonly name: FieldRef<"CategoryTranslation", 'String'>
    readonly iconAlt: FieldRef<"CategoryTranslation", 'String'>
    readonly categoryLink: FieldRef<"CategoryTranslation", 'String'>
    readonly description: FieldRef<"CategoryTranslation", 'String'>
    readonly categoryId: FieldRef<"CategoryTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CategoryTranslation findUnique
   */
  export type CategoryTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation findUniqueOrThrow
   */
  export type CategoryTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation findFirst
   */
  export type CategoryTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation findFirstOrThrow
   */
  export type CategoryTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslation to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryTranslations.
     */
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation findMany
   */
  export type CategoryTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CategoryTranslations to fetch.
     */
    where?: CategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryTranslations to fetch.
     */
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryTranslations.
     */
    cursor?: CategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryTranslations.
     */
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation create
   */
  export type CategoryTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryTranslation.
     */
    data: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
  }

  /**
   * CategoryTranslation createMany
   */
  export type CategoryTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryTranslations.
     */
    data: CategoryTranslationCreateManyInput | CategoryTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryTranslation createManyAndReturn
   */
  export type CategoryTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryTranslations.
     */
    data: CategoryTranslationCreateManyInput | CategoryTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryTranslation update
   */
  export type CategoryTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryTranslation.
     */
    data: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
    /**
     * Choose, which CategoryTranslation to update.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation updateMany
   */
  export type CategoryTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryTranslations.
     */
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryTranslations to update
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to update.
     */
    limit?: number
  }

  /**
   * CategoryTranslation updateManyAndReturn
   */
  export type CategoryTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * The data used to update CategoryTranslations.
     */
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CategoryTranslations to update
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryTranslation upsert
   */
  export type CategoryTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryTranslation to update in case it exists.
     */
    where: CategoryTranslationWhereUniqueInput
    /**
     * In case the CategoryTranslation found by the `where` argument doesn't exist, create a new CategoryTranslation with this data.
     */
    create: XOR<CategoryTranslationCreateInput, CategoryTranslationUncheckedCreateInput>
    /**
     * In case the CategoryTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryTranslationUpdateInput, CategoryTranslationUncheckedUpdateInput>
  }

  /**
   * CategoryTranslation delete
   */
  export type CategoryTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter which CategoryTranslation to delete.
     */
    where: CategoryTranslationWhereUniqueInput
  }

  /**
   * CategoryTranslation deleteMany
   */
  export type CategoryTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryTranslations to delete
     */
    where?: CategoryTranslationWhereInput
    /**
     * Limit how many CategoryTranslations to delete.
     */
    limit?: number
  }

  /**
   * CategoryTranslation.products
   */
  export type CategoryTranslation$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * CategoryTranslation without action
   */
  export type CategoryTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    stars: number | null
    reviews: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    stars: number | null
    reviews: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    model_name_en: string | null
    product_name: string | null
    productImage: string | null
    productImage_Alt: string | null
    status_en: string | null
    stars: number | null
    reviews: number | null
    productDescription_en: string | null
    model_description: string | null
    introduction: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    model_name_en: string | null
    product_name: string | null
    productImage: string | null
    productImage_Alt: string | null
    status_en: string | null
    stars: number | null
    reviews: number | null
    productDescription_en: string | null
    model_description: string | null
    introduction: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    model_name_en: number
    product_name: number
    productImage: number
    productImage_Alt: number
    status_en: number
    stars: number
    reviews: number
    productDescription_en: number
    model_description: number
    introduction: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    stars?: true
    reviews?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    stars?: true
    reviews?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    model_name_en?: true
    product_name?: true
    productImage?: true
    productImage_Alt?: true
    status_en?: true
    stars?: true
    reviews?: true
    productDescription_en?: true
    model_description?: true
    introduction?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    model_name_en?: true
    product_name?: true
    productImage?: true
    productImage_Alt?: true
    status_en?: true
    stars?: true
    reviews?: true
    productDescription_en?: true
    model_description?: true
    introduction?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    model_name_en?: true
    product_name?: true
    productImage?: true
    productImage_Alt?: true
    status_en?: true
    stars?: true
    reviews?: true
    productDescription_en?: true
    model_description?: true
    introduction?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    model_name_en: string
    product_name: string | null
    productImage: string | null
    productImage_Alt: string | null
    status_en: string | null
    stars: number | null
    reviews: number | null
    productDescription_en: string | null
    model_description: string | null
    introduction: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model_name_en?: boolean
    product_name?: boolean
    productImage?: boolean
    productImage_Alt?: boolean
    status_en?: boolean
    stars?: boolean
    reviews?: boolean
    productDescription_en?: boolean
    model_description?: boolean
    introduction?: boolean
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    modelSpecification?: boolean | Product$modelSpecificationArgs<ExtArgs>
    advantages?: boolean | Product$advantagesArgs<ExtArgs>
    specifications?: boolean | Product$specificationsArgs<ExtArgs>
    applicationData?: boolean | Product$applicationDataArgs<ExtArgs>
    technicalSpecifications?: boolean | Product$technicalSpecificationsArgs<ExtArgs>
    relatedProducts?: boolean | Product$relatedProductsArgs<ExtArgs>
    processSteps?: boolean | Product$processStepsArgs<ExtArgs>
    translations?: boolean | Product$translationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model_name_en?: boolean
    product_name?: boolean
    productImage?: boolean
    productImage_Alt?: boolean
    status_en?: boolean
    stars?: boolean
    reviews?: boolean
    productDescription_en?: boolean
    model_description?: boolean
    introduction?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model_name_en?: boolean
    product_name?: boolean
    productImage?: boolean
    productImage_Alt?: boolean
    status_en?: boolean
    stars?: boolean
    reviews?: boolean
    productDescription_en?: boolean
    model_description?: boolean
    introduction?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    model_name_en?: boolean
    product_name?: boolean
    productImage?: boolean
    productImage_Alt?: boolean
    status_en?: boolean
    stars?: boolean
    reviews?: boolean
    productDescription_en?: boolean
    model_description?: boolean
    introduction?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "model_name_en" | "product_name" | "productImage" | "productImage_Alt" | "status_en" | "stars" | "reviews" | "productDescription_en" | "model_description" | "introduction", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    modelSpecification?: boolean | Product$modelSpecificationArgs<ExtArgs>
    advantages?: boolean | Product$advantagesArgs<ExtArgs>
    specifications?: boolean | Product$specificationsArgs<ExtArgs>
    applicationData?: boolean | Product$applicationDataArgs<ExtArgs>
    technicalSpecifications?: boolean | Product$technicalSpecificationsArgs<ExtArgs>
    relatedProducts?: boolean | Product$relatedProductsArgs<ExtArgs>
    processSteps?: boolean | Product$processStepsArgs<ExtArgs>
    translations?: boolean | Product$translationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      modelSpecification: Prisma.$modelSpecificationPayload<ExtArgs>[]
      advantages: Prisma.$AdvantagePayload<ExtArgs>[]
      specifications: Prisma.$SpecificationPayload<ExtArgs>[]
      applicationData: Prisma.$ApplicationDataPayload<ExtArgs>[]
      technicalSpecifications: Prisma.$TechnicalSpecificationPayload<ExtArgs>[]
      relatedProducts: Prisma.$RelatedProductPayload<ExtArgs>[]
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      translations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      model_name_en: string
      product_name: string | null
      productImage: string | null
      productImage_Alt: string | null
      status_en: string | null
      stars: number | null
      reviews: number | null
      productDescription_en: string | null
      model_description: string | null
      introduction: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modelSpecification<T extends Product$modelSpecificationArgs<ExtArgs> = {}>(args?: Subset<T, Product$modelSpecificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    advantages<T extends Product$advantagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specifications<T extends Product$specificationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$specificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicationData<T extends Product$applicationDataArgs<ExtArgs> = {}>(args?: Subset<T, Product$applicationDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    technicalSpecifications<T extends Product$technicalSpecificationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$technicalSpecificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedProducts<T extends Product$relatedProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$relatedProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processSteps<T extends Product$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, Product$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends Product$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly model_name_en: FieldRef<"Product", 'String'>
    readonly product_name: FieldRef<"Product", 'String'>
    readonly productImage: FieldRef<"Product", 'String'>
    readonly productImage_Alt: FieldRef<"Product", 'String'>
    readonly status_en: FieldRef<"Product", 'String'>
    readonly stars: FieldRef<"Product", 'Int'>
    readonly reviews: FieldRef<"Product", 'Int'>
    readonly productDescription_en: FieldRef<"Product", 'String'>
    readonly model_description: FieldRef<"Product", 'String'>
    readonly introduction: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Product.modelSpecification
   */
  export type Product$modelSpecificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    where?: modelSpecificationWhereInput
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    cursor?: modelSpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelSpecificationScalarFieldEnum | ModelSpecificationScalarFieldEnum[]
  }

  /**
   * Product.advantages
   */
  export type Product$advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    where?: AdvantageWhereInput
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    cursor?: AdvantageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvantageScalarFieldEnum | AdvantageScalarFieldEnum[]
  }

  /**
   * Product.specifications
   */
  export type Product$specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    where?: SpecificationWhereInput
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    cursor?: SpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificationScalarFieldEnum | SpecificationScalarFieldEnum[]
  }

  /**
   * Product.applicationData
   */
  export type Product$applicationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    where?: ApplicationDataWhereInput
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    cursor?: ApplicationDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationDataScalarFieldEnum | ApplicationDataScalarFieldEnum[]
  }

  /**
   * Product.technicalSpecifications
   */
  export type Product$technicalSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    where?: TechnicalSpecificationWhereInput
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    cursor?: TechnicalSpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * Product.relatedProducts
   */
  export type Product$relatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    where?: RelatedProductWhereInput
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    cursor?: RelatedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatedProductScalarFieldEnum | RelatedProductScalarFieldEnum[]
  }

  /**
   * Product.processSteps
   */
  export type Product$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * Product.translations
   */
  export type Product$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductTranslation
   */

  export type AggregateProductTranslation = {
    _count: ProductTranslationCountAggregateOutputType | null
    _avg: ProductTranslationAvgAggregateOutputType | null
    _sum: ProductTranslationSumAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  export type ProductTranslationAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductTranslationSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    name: string | null
    imageAlt: string | null
    status: string | null
    productDescription: string | null
    model_description: string | null
    introduction: string | null
    productId: number | null
  }

  export type ProductTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    name: string | null
    imageAlt: string | null
    status: string | null
    productDescription: string | null
    model_description: string | null
    introduction: string | null
    productId: number | null
  }

  export type ProductTranslationCountAggregateOutputType = {
    id: number
    language: number
    name: number
    imageAlt: number
    status: number
    productDescription: number
    model_description: number
    introduction: number
    productId: number
    _all: number
  }


  export type ProductTranslationAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductTranslationSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductTranslationMinAggregateInputType = {
    id?: true
    language?: true
    name?: true
    imageAlt?: true
    status?: true
    productDescription?: true
    model_description?: true
    introduction?: true
    productId?: true
  }

  export type ProductTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    name?: true
    imageAlt?: true
    status?: true
    productDescription?: true
    model_description?: true
    introduction?: true
    productId?: true
  }

  export type ProductTranslationCountAggregateInputType = {
    id?: true
    language?: true
    name?: true
    imageAlt?: true
    status?: true
    productDescription?: true
    model_description?: true
    introduction?: true
    productId?: true
    _all?: true
  }

  export type ProductTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTranslation to aggregate.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTranslations
    **/
    _count?: true | ProductTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type GetProductTranslationAggregateType<T extends ProductTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTranslation[P]>
      : GetScalarType<T[P], AggregateProductTranslation[P]>
  }




  export type ProductTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithAggregationInput | ProductTranslationOrderByWithAggregationInput[]
    by: ProductTranslationScalarFieldEnum[] | ProductTranslationScalarFieldEnum
    having?: ProductTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTranslationCountAggregateInputType | true
    _avg?: ProductTranslationAvgAggregateInputType
    _sum?: ProductTranslationSumAggregateInputType
    _min?: ProductTranslationMinAggregateInputType
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type ProductTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    name: string
    imageAlt: string | null
    status: string | null
    productDescription: string | null
    model_description: string | null
    introduction: string | null
    productId: number
    _count: ProductTranslationCountAggregateOutputType | null
    _avg: ProductTranslationAvgAggregateOutputType | null
    _sum: ProductTranslationSumAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  type GetProductTranslationGroupByPayload<T extends ProductTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ProductTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    imageAlt?: boolean
    status?: boolean
    productDescription?: boolean
    model_description?: boolean
    introduction?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    categories?: boolean | ProductTranslation$categoriesArgs<ExtArgs>
    advantages?: boolean | ProductTranslation$advantagesArgs<ExtArgs>
    specifications?: boolean | ProductTranslation$specificationsArgs<ExtArgs>
    applicationData?: boolean | ProductTranslation$applicationDataArgs<ExtArgs>
    technicalSpecifications?: boolean | ProductTranslation$technicalSpecificationsArgs<ExtArgs>
    relatedProducts?: boolean | ProductTranslation$relatedProductsArgs<ExtArgs>
    processSteps?: boolean | ProductTranslation$processStepsArgs<ExtArgs>
    modelSpecifications?: boolean | ProductTranslation$modelSpecificationsArgs<ExtArgs>
    _count?: boolean | ProductTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTranslation"]>

  export type ProductTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    imageAlt?: boolean
    status?: boolean
    productDescription?: boolean
    model_description?: boolean
    introduction?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTranslation"]>

  export type ProductTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    name?: boolean
    imageAlt?: boolean
    status?: boolean
    productDescription?: boolean
    model_description?: boolean
    introduction?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTranslation"]>

  export type ProductTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    name?: boolean
    imageAlt?: boolean
    status?: boolean
    productDescription?: boolean
    model_description?: boolean
    introduction?: boolean
    productId?: boolean
  }

  export type ProductTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "name" | "imageAlt" | "status" | "productDescription" | "model_description" | "introduction" | "productId", ExtArgs["result"]["productTranslation"]>
  export type ProductTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    categories?: boolean | ProductTranslation$categoriesArgs<ExtArgs>
    advantages?: boolean | ProductTranslation$advantagesArgs<ExtArgs>
    specifications?: boolean | ProductTranslation$specificationsArgs<ExtArgs>
    applicationData?: boolean | ProductTranslation$applicationDataArgs<ExtArgs>
    technicalSpecifications?: boolean | ProductTranslation$technicalSpecificationsArgs<ExtArgs>
    relatedProducts?: boolean | ProductTranslation$relatedProductsArgs<ExtArgs>
    processSteps?: boolean | ProductTranslation$processStepsArgs<ExtArgs>
    modelSpecifications?: boolean | ProductTranslation$modelSpecificationsArgs<ExtArgs>
    _count?: boolean | ProductTranslationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductTranslation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      categories: Prisma.$CategoryTranslationPayload<ExtArgs>[]
      advantages: Prisma.$AdvantagePayload<ExtArgs>[]
      specifications: Prisma.$SpecificationPayload<ExtArgs>[]
      applicationData: Prisma.$ApplicationDataPayload<ExtArgs>[]
      technicalSpecifications: Prisma.$TechnicalSpecificationPayload<ExtArgs>[]
      relatedProducts: Prisma.$RelatedProductPayload<ExtArgs>[]
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      modelSpecifications: Prisma.$modelSpecificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      name: string
      imageAlt: string | null
      status: string | null
      productDescription: string | null
      model_description: string | null
      introduction: string | null
      productId: number
    }, ExtArgs["result"]["productTranslation"]>
    composites: {}
  }

  type ProductTranslationGetPayload<S extends boolean | null | undefined | ProductTranslationDefaultArgs> = $Result.GetResult<Prisma.$ProductTranslationPayload, S>

  type ProductTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductTranslationCountAggregateInputType | true
    }

  export interface ProductTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTranslation'], meta: { name: 'ProductTranslation' } }
    /**
     * Find zero or one ProductTranslation that matches the filter.
     * @param {ProductTranslationFindUniqueArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTranslationFindUniqueArgs>(args: SelectSubset<T, ProductTranslationFindUniqueArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTranslationFindUniqueOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTranslationFindFirstArgs>(args?: SelectSubset<T, ProductTranslationFindFirstArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany()
     * 
     * // Get first 10 ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductTranslationFindManyArgs>(args?: SelectSubset<T, ProductTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductTranslation.
     * @param {ProductTranslationCreateArgs} args - Arguments to create a ProductTranslation.
     * @example
     * // Create one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.create({
     *   data: {
     *     // ... data to create a ProductTranslation
     *   }
     * })
     * 
     */
    create<T extends ProductTranslationCreateArgs>(args: SelectSubset<T, ProductTranslationCreateArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductTranslations.
     * @param {ProductTranslationCreateManyArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTranslationCreateManyArgs>(args?: SelectSubset<T, ProductTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTranslations and returns the data saved in the database.
     * @param {ProductTranslationCreateManyAndReturnArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTranslations and only return the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductTranslation.
     * @param {ProductTranslationDeleteArgs} args - Arguments to delete one ProductTranslation.
     * @example
     * // Delete one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.delete({
     *   where: {
     *     // ... filter to delete one ProductTranslation
     *   }
     * })
     * 
     */
    delete<T extends ProductTranslationDeleteArgs>(args: SelectSubset<T, ProductTranslationDeleteArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductTranslation.
     * @param {ProductTranslationUpdateArgs} args - Arguments to update one ProductTranslation.
     * @example
     * // Update one ProductTranslation
     * const productTranslation = await prisma.productTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTranslationUpdateArgs>(args: SelectSubset<T, ProductTranslationUpdateArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductTranslations.
     * @param {ProductTranslationDeleteManyArgs} args - Arguments to filter ProductTranslations to delete.
     * @example
     * // Delete a few ProductTranslations
     * const { count } = await prisma.productTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTranslationDeleteManyArgs>(args?: SelectSubset<T, ProductTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTranslations
     * const productTranslation = await prisma.productTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTranslationUpdateManyArgs>(args: SelectSubset<T, ProductTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTranslations and returns the data updated in the database.
     * @param {ProductTranslationUpdateManyAndReturnArgs} args - Arguments to update many ProductTranslations.
     * @example
     * // Update many ProductTranslations
     * const productTranslation = await prisma.productTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductTranslations and only return the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductTranslation.
     * @param {ProductTranslationUpsertArgs} args - Arguments to update or create a ProductTranslation.
     * @example
     * // Update or create a ProductTranslation
     * const productTranslation = await prisma.productTranslation.upsert({
     *   create: {
     *     // ... data to create a ProductTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ProductTranslationUpsertArgs>(args: SelectSubset<T, ProductTranslationUpsertArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationCountArgs} args - Arguments to filter ProductTranslations to count.
     * @example
     * // Count the number of ProductTranslations
     * const count = await prisma.productTranslation.count({
     *   where: {
     *     // ... the filter for the ProductTranslations we want to count
     *   }
     * })
    **/
    count<T extends ProductTranslationCountArgs>(
      args?: Subset<T, ProductTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTranslationAggregateArgs>(args: Subset<T, ProductTranslationAggregateArgs>): Prisma.PrismaPromise<GetProductTranslationAggregateType<T>>

    /**
     * Group by ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ProductTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTranslation model
   */
  readonly fields: ProductTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends ProductTranslation$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    advantages<T extends ProductTranslation$advantagesArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specifications<T extends ProductTranslation$specificationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$specificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicationData<T extends ProductTranslation$applicationDataArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$applicationDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    technicalSpecifications<T extends ProductTranslation$technicalSpecificationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$technicalSpecificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedProducts<T extends ProductTranslation$relatedProductsArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$relatedProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processSteps<T extends ProductTranslation$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modelSpecifications<T extends ProductTranslation$modelSpecificationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductTranslation$modelSpecificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductTranslation model
   */
  interface ProductTranslationFieldRefs {
    readonly id: FieldRef<"ProductTranslation", 'Int'>
    readonly language: FieldRef<"ProductTranslation", 'LanguageCode'>
    readonly name: FieldRef<"ProductTranslation", 'String'>
    readonly imageAlt: FieldRef<"ProductTranslation", 'String'>
    readonly status: FieldRef<"ProductTranslation", 'String'>
    readonly productDescription: FieldRef<"ProductTranslation", 'String'>
    readonly model_description: FieldRef<"ProductTranslation", 'String'>
    readonly introduction: FieldRef<"ProductTranslation", 'String'>
    readonly productId: FieldRef<"ProductTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductTranslation findUnique
   */
  export type ProductTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findUniqueOrThrow
   */
  export type ProductTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findFirst
   */
  export type ProductTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findFirstOrThrow
   */
  export type ProductTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findMany
   */
  export type ProductTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslations to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation create
   */
  export type ProductTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTranslation.
     */
    data: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
  }

  /**
   * ProductTranslation createMany
   */
  export type ProductTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTranslation createManyAndReturn
   */
  export type ProductTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTranslation update
   */
  export type ProductTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTranslation.
     */
    data: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
    /**
     * Choose, which ProductTranslation to update.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation updateMany
   */
  export type ProductTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTranslations.
     */
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductTranslations to update
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to update.
     */
    limit?: number
  }

  /**
   * ProductTranslation updateManyAndReturn
   */
  export type ProductTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ProductTranslations.
     */
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductTranslations to update
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTranslation upsert
   */
  export type ProductTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTranslation to update in case it exists.
     */
    where: ProductTranslationWhereUniqueInput
    /**
     * In case the ProductTranslation found by the `where` argument doesn't exist, create a new ProductTranslation with this data.
     */
    create: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
    /**
     * In case the ProductTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
  }

  /**
   * ProductTranslation delete
   */
  export type ProductTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter which ProductTranslation to delete.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation deleteMany
   */
  export type ProductTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTranslations to delete
     */
    where?: ProductTranslationWhereInput
    /**
     * Limit how many ProductTranslations to delete.
     */
    limit?: number
  }

  /**
   * ProductTranslation.categories
   */
  export type ProductTranslation$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryTranslation
     */
    select?: CategoryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryTranslation
     */
    omit?: CategoryTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryTranslationInclude<ExtArgs> | null
    where?: CategoryTranslationWhereInput
    orderBy?: CategoryTranslationOrderByWithRelationInput | CategoryTranslationOrderByWithRelationInput[]
    cursor?: CategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryTranslationScalarFieldEnum | CategoryTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation.advantages
   */
  export type ProductTranslation$advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    where?: AdvantageWhereInput
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    cursor?: AdvantageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvantageScalarFieldEnum | AdvantageScalarFieldEnum[]
  }

  /**
   * ProductTranslation.specifications
   */
  export type ProductTranslation$specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    where?: SpecificationWhereInput
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    cursor?: SpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificationScalarFieldEnum | SpecificationScalarFieldEnum[]
  }

  /**
   * ProductTranslation.applicationData
   */
  export type ProductTranslation$applicationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    where?: ApplicationDataWhereInput
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    cursor?: ApplicationDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationDataScalarFieldEnum | ApplicationDataScalarFieldEnum[]
  }

  /**
   * ProductTranslation.technicalSpecifications
   */
  export type ProductTranslation$technicalSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    where?: TechnicalSpecificationWhereInput
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    cursor?: TechnicalSpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * ProductTranslation.relatedProducts
   */
  export type ProductTranslation$relatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    where?: RelatedProductWhereInput
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    cursor?: RelatedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatedProductScalarFieldEnum | RelatedProductScalarFieldEnum[]
  }

  /**
   * ProductTranslation.processSteps
   */
  export type ProductTranslation$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProductTranslation.modelSpecifications
   */
  export type ProductTranslation$modelSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    where?: modelSpecificationWhereInput
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    cursor?: modelSpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelSpecificationScalarFieldEnum | ModelSpecificationScalarFieldEnum[]
  }

  /**
   * ProductTranslation without action
   */
  export type ProductTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
  }


  /**
   * Model modelSpecification
   */

  export type AggregateModelSpecification = {
    _count: ModelSpecificationCountAggregateOutputType | null
    _avg: ModelSpecificationAvgAggregateOutputType | null
    _sum: ModelSpecificationSumAggregateOutputType | null
    _min: ModelSpecificationMinAggregateOutputType | null
    _max: ModelSpecificationMaxAggregateOutputType | null
  }

  export type ModelSpecificationAvgAggregateOutputType = {
    id: number | null
  }

  export type ModelSpecificationSumAggregateOutputType = {
    id: number | null
  }

  export type ModelSpecificationMinAggregateOutputType = {
    id: number | null
    title_en: string | null
  }

  export type ModelSpecificationMaxAggregateOutputType = {
    id: number | null
    title_en: string | null
  }

  export type ModelSpecificationCountAggregateOutputType = {
    id: number
    title_en: number
    _all: number
  }


  export type ModelSpecificationAvgAggregateInputType = {
    id?: true
  }

  export type ModelSpecificationSumAggregateInputType = {
    id?: true
  }

  export type ModelSpecificationMinAggregateInputType = {
    id?: true
    title_en?: true
  }

  export type ModelSpecificationMaxAggregateInputType = {
    id?: true
    title_en?: true
  }

  export type ModelSpecificationCountAggregateInputType = {
    id?: true
    title_en?: true
    _all?: true
  }

  export type ModelSpecificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modelSpecification to aggregate.
     */
    where?: modelSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecifications to fetch.
     */
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modelSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modelSpecifications
    **/
    _count?: true | ModelSpecificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelSpecificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSpecificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelSpecificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelSpecificationMaxAggregateInputType
  }

  export type GetModelSpecificationAggregateType<T extends ModelSpecificationAggregateArgs> = {
        [P in keyof T & keyof AggregateModelSpecification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelSpecification[P]>
      : GetScalarType<T[P], AggregateModelSpecification[P]>
  }




  export type modelSpecificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelSpecificationWhereInput
    orderBy?: modelSpecificationOrderByWithAggregationInput | modelSpecificationOrderByWithAggregationInput[]
    by: ModelSpecificationScalarFieldEnum[] | ModelSpecificationScalarFieldEnum
    having?: modelSpecificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelSpecificationCountAggregateInputType | true
    _avg?: ModelSpecificationAvgAggregateInputType
    _sum?: ModelSpecificationSumAggregateInputType
    _min?: ModelSpecificationMinAggregateInputType
    _max?: ModelSpecificationMaxAggregateInputType
  }

  export type ModelSpecificationGroupByOutputType = {
    id: number
    title_en: string
    _count: ModelSpecificationCountAggregateOutputType | null
    _avg: ModelSpecificationAvgAggregateOutputType | null
    _sum: ModelSpecificationSumAggregateOutputType | null
    _min: ModelSpecificationMinAggregateOutputType | null
    _max: ModelSpecificationMaxAggregateOutputType | null
  }

  type GetModelSpecificationGroupByPayload<T extends modelSpecificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelSpecificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelSpecificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelSpecificationGroupByOutputType[P]>
            : GetScalarType<T[P], ModelSpecificationGroupByOutputType[P]>
        }
      >
    >


  export type modelSpecificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_en?: boolean
    products?: boolean | modelSpecification$productsArgs<ExtArgs>
    translations?: boolean | modelSpecification$translationsArgs<ExtArgs>
    productTranslations?: boolean | modelSpecification$productTranslationsArgs<ExtArgs>
    _count?: boolean | ModelSpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelSpecification"]>

  export type modelSpecificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_en?: boolean
  }, ExtArgs["result"]["modelSpecification"]>

  export type modelSpecificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_en?: boolean
  }, ExtArgs["result"]["modelSpecification"]>

  export type modelSpecificationSelectScalar = {
    id?: boolean
    title_en?: boolean
  }

  export type modelSpecificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title_en", ExtArgs["result"]["modelSpecification"]>
  export type modelSpecificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | modelSpecification$productsArgs<ExtArgs>
    translations?: boolean | modelSpecification$translationsArgs<ExtArgs>
    productTranslations?: boolean | modelSpecification$productTranslationsArgs<ExtArgs>
    _count?: boolean | ModelSpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type modelSpecificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type modelSpecificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $modelSpecificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modelSpecification"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      translations: Prisma.$modelSpecificationTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title_en: string
    }, ExtArgs["result"]["modelSpecification"]>
    composites: {}
  }

  type modelSpecificationGetPayload<S extends boolean | null | undefined | modelSpecificationDefaultArgs> = $Result.GetResult<Prisma.$modelSpecificationPayload, S>

  type modelSpecificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modelSpecificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelSpecificationCountAggregateInputType | true
    }

  export interface modelSpecificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modelSpecification'], meta: { name: 'modelSpecification' } }
    /**
     * Find zero or one ModelSpecification that matches the filter.
     * @param {modelSpecificationFindUniqueArgs} args - Arguments to find a ModelSpecification
     * @example
     * // Get one ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modelSpecificationFindUniqueArgs>(args: SelectSubset<T, modelSpecificationFindUniqueArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelSpecification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modelSpecificationFindUniqueOrThrowArgs} args - Arguments to find a ModelSpecification
     * @example
     * // Get one ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modelSpecificationFindUniqueOrThrowArgs>(args: SelectSubset<T, modelSpecificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelSpecification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationFindFirstArgs} args - Arguments to find a ModelSpecification
     * @example
     * // Get one ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modelSpecificationFindFirstArgs>(args?: SelectSubset<T, modelSpecificationFindFirstArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelSpecification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationFindFirstOrThrowArgs} args - Arguments to find a ModelSpecification
     * @example
     * // Get one ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modelSpecificationFindFirstOrThrowArgs>(args?: SelectSubset<T, modelSpecificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelSpecifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelSpecifications
     * const modelSpecifications = await prisma.modelSpecification.findMany()
     * 
     * // Get first 10 ModelSpecifications
     * const modelSpecifications = await prisma.modelSpecification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelSpecificationWithIdOnly = await prisma.modelSpecification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modelSpecificationFindManyArgs>(args?: SelectSubset<T, modelSpecificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelSpecification.
     * @param {modelSpecificationCreateArgs} args - Arguments to create a ModelSpecification.
     * @example
     * // Create one ModelSpecification
     * const ModelSpecification = await prisma.modelSpecification.create({
     *   data: {
     *     // ... data to create a ModelSpecification
     *   }
     * })
     * 
     */
    create<T extends modelSpecificationCreateArgs>(args: SelectSubset<T, modelSpecificationCreateArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelSpecifications.
     * @param {modelSpecificationCreateManyArgs} args - Arguments to create many ModelSpecifications.
     * @example
     * // Create many ModelSpecifications
     * const modelSpecification = await prisma.modelSpecification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modelSpecificationCreateManyArgs>(args?: SelectSubset<T, modelSpecificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelSpecifications and returns the data saved in the database.
     * @param {modelSpecificationCreateManyAndReturnArgs} args - Arguments to create many ModelSpecifications.
     * @example
     * // Create many ModelSpecifications
     * const modelSpecification = await prisma.modelSpecification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelSpecifications and only return the `id`
     * const modelSpecificationWithIdOnly = await prisma.modelSpecification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends modelSpecificationCreateManyAndReturnArgs>(args?: SelectSubset<T, modelSpecificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelSpecification.
     * @param {modelSpecificationDeleteArgs} args - Arguments to delete one ModelSpecification.
     * @example
     * // Delete one ModelSpecification
     * const ModelSpecification = await prisma.modelSpecification.delete({
     *   where: {
     *     // ... filter to delete one ModelSpecification
     *   }
     * })
     * 
     */
    delete<T extends modelSpecificationDeleteArgs>(args: SelectSubset<T, modelSpecificationDeleteArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelSpecification.
     * @param {modelSpecificationUpdateArgs} args - Arguments to update one ModelSpecification.
     * @example
     * // Update one ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modelSpecificationUpdateArgs>(args: SelectSubset<T, modelSpecificationUpdateArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelSpecifications.
     * @param {modelSpecificationDeleteManyArgs} args - Arguments to filter ModelSpecifications to delete.
     * @example
     * // Delete a few ModelSpecifications
     * const { count } = await prisma.modelSpecification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modelSpecificationDeleteManyArgs>(args?: SelectSubset<T, modelSpecificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelSpecifications
     * const modelSpecification = await prisma.modelSpecification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modelSpecificationUpdateManyArgs>(args: SelectSubset<T, modelSpecificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelSpecifications and returns the data updated in the database.
     * @param {modelSpecificationUpdateManyAndReturnArgs} args - Arguments to update many ModelSpecifications.
     * @example
     * // Update many ModelSpecifications
     * const modelSpecification = await prisma.modelSpecification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelSpecifications and only return the `id`
     * const modelSpecificationWithIdOnly = await prisma.modelSpecification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends modelSpecificationUpdateManyAndReturnArgs>(args: SelectSubset<T, modelSpecificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelSpecification.
     * @param {modelSpecificationUpsertArgs} args - Arguments to update or create a ModelSpecification.
     * @example
     * // Update or create a ModelSpecification
     * const modelSpecification = await prisma.modelSpecification.upsert({
     *   create: {
     *     // ... data to create a ModelSpecification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelSpecification we want to update
     *   }
     * })
     */
    upsert<T extends modelSpecificationUpsertArgs>(args: SelectSubset<T, modelSpecificationUpsertArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationCountArgs} args - Arguments to filter ModelSpecifications to count.
     * @example
     * // Count the number of ModelSpecifications
     * const count = await prisma.modelSpecification.count({
     *   where: {
     *     // ... the filter for the ModelSpecifications we want to count
     *   }
     * })
    **/
    count<T extends modelSpecificationCountArgs>(
      args?: Subset<T, modelSpecificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelSpecificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelSpecificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelSpecificationAggregateArgs>(args: Subset<T, ModelSpecificationAggregateArgs>): Prisma.PrismaPromise<GetModelSpecificationAggregateType<T>>

    /**
     * Group by ModelSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modelSpecificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modelSpecificationGroupByArgs['orderBy'] }
        : { orderBy?: modelSpecificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modelSpecificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelSpecificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modelSpecification model
   */
  readonly fields: modelSpecificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modelSpecification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modelSpecificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends modelSpecification$productsArgs<ExtArgs> = {}>(args?: Subset<T, modelSpecification$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends modelSpecification$translationsArgs<ExtArgs> = {}>(args?: Subset<T, modelSpecification$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends modelSpecification$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, modelSpecification$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modelSpecification model
   */
  interface modelSpecificationFieldRefs {
    readonly id: FieldRef<"modelSpecification", 'Int'>
    readonly title_en: FieldRef<"modelSpecification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * modelSpecification findUnique
   */
  export type modelSpecificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecification to fetch.
     */
    where: modelSpecificationWhereUniqueInput
  }

  /**
   * modelSpecification findUniqueOrThrow
   */
  export type modelSpecificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecification to fetch.
     */
    where: modelSpecificationWhereUniqueInput
  }

  /**
   * modelSpecification findFirst
   */
  export type modelSpecificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecification to fetch.
     */
    where?: modelSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecifications to fetch.
     */
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modelSpecifications.
     */
    cursor?: modelSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modelSpecifications.
     */
    distinct?: ModelSpecificationScalarFieldEnum | ModelSpecificationScalarFieldEnum[]
  }

  /**
   * modelSpecification findFirstOrThrow
   */
  export type modelSpecificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecification to fetch.
     */
    where?: modelSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecifications to fetch.
     */
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modelSpecifications.
     */
    cursor?: modelSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modelSpecifications.
     */
    distinct?: ModelSpecificationScalarFieldEnum | ModelSpecificationScalarFieldEnum[]
  }

  /**
   * modelSpecification findMany
   */
  export type modelSpecificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecifications to fetch.
     */
    where?: modelSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecifications to fetch.
     */
    orderBy?: modelSpecificationOrderByWithRelationInput | modelSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modelSpecifications.
     */
    cursor?: modelSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecifications.
     */
    skip?: number
    distinct?: ModelSpecificationScalarFieldEnum | ModelSpecificationScalarFieldEnum[]
  }

  /**
   * modelSpecification create
   */
  export type modelSpecificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to create a modelSpecification.
     */
    data: XOR<modelSpecificationCreateInput, modelSpecificationUncheckedCreateInput>
  }

  /**
   * modelSpecification createMany
   */
  export type modelSpecificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many modelSpecifications.
     */
    data: modelSpecificationCreateManyInput | modelSpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modelSpecification createManyAndReturn
   */
  export type modelSpecificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * The data used to create many modelSpecifications.
     */
    data: modelSpecificationCreateManyInput | modelSpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modelSpecification update
   */
  export type modelSpecificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to update a modelSpecification.
     */
    data: XOR<modelSpecificationUpdateInput, modelSpecificationUncheckedUpdateInput>
    /**
     * Choose, which modelSpecification to update.
     */
    where: modelSpecificationWhereUniqueInput
  }

  /**
   * modelSpecification updateMany
   */
  export type modelSpecificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update modelSpecifications.
     */
    data: XOR<modelSpecificationUpdateManyMutationInput, modelSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which modelSpecifications to update
     */
    where?: modelSpecificationWhereInput
    /**
     * Limit how many modelSpecifications to update.
     */
    limit?: number
  }

  /**
   * modelSpecification updateManyAndReturn
   */
  export type modelSpecificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * The data used to update modelSpecifications.
     */
    data: XOR<modelSpecificationUpdateManyMutationInput, modelSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which modelSpecifications to update
     */
    where?: modelSpecificationWhereInput
    /**
     * Limit how many modelSpecifications to update.
     */
    limit?: number
  }

  /**
   * modelSpecification upsert
   */
  export type modelSpecificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * The filter to search for the modelSpecification to update in case it exists.
     */
    where: modelSpecificationWhereUniqueInput
    /**
     * In case the modelSpecification found by the `where` argument doesn't exist, create a new modelSpecification with this data.
     */
    create: XOR<modelSpecificationCreateInput, modelSpecificationUncheckedCreateInput>
    /**
     * In case the modelSpecification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modelSpecificationUpdateInput, modelSpecificationUncheckedUpdateInput>
  }

  /**
   * modelSpecification delete
   */
  export type modelSpecificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
    /**
     * Filter which modelSpecification to delete.
     */
    where: modelSpecificationWhereUniqueInput
  }

  /**
   * modelSpecification deleteMany
   */
  export type modelSpecificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modelSpecifications to delete
     */
    where?: modelSpecificationWhereInput
    /**
     * Limit how many modelSpecifications to delete.
     */
    limit?: number
  }

  /**
   * modelSpecification.products
   */
  export type modelSpecification$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * modelSpecification.translations
   */
  export type modelSpecification$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    where?: modelSpecificationTranslationWhereInput
    orderBy?: modelSpecificationTranslationOrderByWithRelationInput | modelSpecificationTranslationOrderByWithRelationInput[]
    cursor?: modelSpecificationTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelSpecificationTranslationScalarFieldEnum | ModelSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * modelSpecification.productTranslations
   */
  export type modelSpecification$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * modelSpecification without action
   */
  export type modelSpecificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecification
     */
    select?: modelSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecification
     */
    omit?: modelSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationInclude<ExtArgs> | null
  }


  /**
   * Model modelSpecificationTranslation
   */

  export type AggregateModelSpecificationTranslation = {
    _count: ModelSpecificationTranslationCountAggregateOutputType | null
    _avg: ModelSpecificationTranslationAvgAggregateOutputType | null
    _sum: ModelSpecificationTranslationSumAggregateOutputType | null
    _min: ModelSpecificationTranslationMinAggregateOutputType | null
    _max: ModelSpecificationTranslationMaxAggregateOutputType | null
  }

  export type ModelSpecificationTranslationAvgAggregateOutputType = {
    id: number | null
    modelspecId: number | null
  }

  export type ModelSpecificationTranslationSumAggregateOutputType = {
    id: number | null
    modelspecId: number | null
  }

  export type ModelSpecificationTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    modelspecId: number | null
  }

  export type ModelSpecificationTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    modelspecId: number | null
  }

  export type ModelSpecificationTranslationCountAggregateOutputType = {
    id: number
    language: number
    title: number
    modelspecId: number
    _all: number
  }


  export type ModelSpecificationTranslationAvgAggregateInputType = {
    id?: true
    modelspecId?: true
  }

  export type ModelSpecificationTranslationSumAggregateInputType = {
    id?: true
    modelspecId?: true
  }

  export type ModelSpecificationTranslationMinAggregateInputType = {
    id?: true
    language?: true
    title?: true
    modelspecId?: true
  }

  export type ModelSpecificationTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    title?: true
    modelspecId?: true
  }

  export type ModelSpecificationTranslationCountAggregateInputType = {
    id?: true
    language?: true
    title?: true
    modelspecId?: true
    _all?: true
  }

  export type ModelSpecificationTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modelSpecificationTranslation to aggregate.
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecificationTranslations to fetch.
     */
    orderBy?: modelSpecificationTranslationOrderByWithRelationInput | modelSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modelSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modelSpecificationTranslations
    **/
    _count?: true | ModelSpecificationTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelSpecificationTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSpecificationTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelSpecificationTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelSpecificationTranslationMaxAggregateInputType
  }

  export type GetModelSpecificationTranslationAggregateType<T extends ModelSpecificationTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateModelSpecificationTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelSpecificationTranslation[P]>
      : GetScalarType<T[P], AggregateModelSpecificationTranslation[P]>
  }




  export type modelSpecificationTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelSpecificationTranslationWhereInput
    orderBy?: modelSpecificationTranslationOrderByWithAggregationInput | modelSpecificationTranslationOrderByWithAggregationInput[]
    by: ModelSpecificationTranslationScalarFieldEnum[] | ModelSpecificationTranslationScalarFieldEnum
    having?: modelSpecificationTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelSpecificationTranslationCountAggregateInputType | true
    _avg?: ModelSpecificationTranslationAvgAggregateInputType
    _sum?: ModelSpecificationTranslationSumAggregateInputType
    _min?: ModelSpecificationTranslationMinAggregateInputType
    _max?: ModelSpecificationTranslationMaxAggregateInputType
  }

  export type ModelSpecificationTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    title: string
    modelspecId: number
    _count: ModelSpecificationTranslationCountAggregateOutputType | null
    _avg: ModelSpecificationTranslationAvgAggregateOutputType | null
    _sum: ModelSpecificationTranslationSumAggregateOutputType | null
    _min: ModelSpecificationTranslationMinAggregateOutputType | null
    _max: ModelSpecificationTranslationMaxAggregateOutputType | null
  }

  type GetModelSpecificationTranslationGroupByPayload<T extends modelSpecificationTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelSpecificationTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelSpecificationTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelSpecificationTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ModelSpecificationTranslationGroupByOutputType[P]>
        }
      >
    >


  export type modelSpecificationTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    modelspecId?: boolean
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelSpecificationTranslation"]>

  export type modelSpecificationTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    modelspecId?: boolean
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelSpecificationTranslation"]>

  export type modelSpecificationTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    modelspecId?: boolean
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelSpecificationTranslation"]>

  export type modelSpecificationTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    title?: boolean
    modelspecId?: boolean
  }

  export type modelSpecificationTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "title" | "modelspecId", ExtArgs["result"]["modelSpecificationTranslation"]>
  export type modelSpecificationTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }
  export type modelSpecificationTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }
  export type modelSpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelSpec?: boolean | modelSpecificationDefaultArgs<ExtArgs>
  }

  export type $modelSpecificationTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modelSpecificationTranslation"
    objects: {
      modelSpec: Prisma.$modelSpecificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      title: string
      modelspecId: number
    }, ExtArgs["result"]["modelSpecificationTranslation"]>
    composites: {}
  }

  type modelSpecificationTranslationGetPayload<S extends boolean | null | undefined | modelSpecificationTranslationDefaultArgs> = $Result.GetResult<Prisma.$modelSpecificationTranslationPayload, S>

  type modelSpecificationTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modelSpecificationTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelSpecificationTranslationCountAggregateInputType | true
    }

  export interface modelSpecificationTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modelSpecificationTranslation'], meta: { name: 'modelSpecificationTranslation' } }
    /**
     * Find zero or one ModelSpecificationTranslation that matches the filter.
     * @param {modelSpecificationTranslationFindUniqueArgs} args - Arguments to find a ModelSpecificationTranslation
     * @example
     * // Get one ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modelSpecificationTranslationFindUniqueArgs>(args: SelectSubset<T, modelSpecificationTranslationFindUniqueArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelSpecificationTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modelSpecificationTranslationFindUniqueOrThrowArgs} args - Arguments to find a ModelSpecificationTranslation
     * @example
     * // Get one ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modelSpecificationTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, modelSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelSpecificationTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationFindFirstArgs} args - Arguments to find a ModelSpecificationTranslation
     * @example
     * // Get one ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modelSpecificationTranslationFindFirstArgs>(args?: SelectSubset<T, modelSpecificationTranslationFindFirstArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelSpecificationTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationFindFirstOrThrowArgs} args - Arguments to find a ModelSpecificationTranslation
     * @example
     * // Get one ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modelSpecificationTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, modelSpecificationTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelSpecificationTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelSpecificationTranslations
     * const modelSpecificationTranslations = await prisma.modelSpecificationTranslation.findMany()
     * 
     * // Get first 10 ModelSpecificationTranslations
     * const modelSpecificationTranslations = await prisma.modelSpecificationTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelSpecificationTranslationWithIdOnly = await prisma.modelSpecificationTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modelSpecificationTranslationFindManyArgs>(args?: SelectSubset<T, modelSpecificationTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelSpecificationTranslation.
     * @param {modelSpecificationTranslationCreateArgs} args - Arguments to create a ModelSpecificationTranslation.
     * @example
     * // Create one ModelSpecificationTranslation
     * const ModelSpecificationTranslation = await prisma.modelSpecificationTranslation.create({
     *   data: {
     *     // ... data to create a ModelSpecificationTranslation
     *   }
     * })
     * 
     */
    create<T extends modelSpecificationTranslationCreateArgs>(args: SelectSubset<T, modelSpecificationTranslationCreateArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelSpecificationTranslations.
     * @param {modelSpecificationTranslationCreateManyArgs} args - Arguments to create many ModelSpecificationTranslations.
     * @example
     * // Create many ModelSpecificationTranslations
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modelSpecificationTranslationCreateManyArgs>(args?: SelectSubset<T, modelSpecificationTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelSpecificationTranslations and returns the data saved in the database.
     * @param {modelSpecificationTranslationCreateManyAndReturnArgs} args - Arguments to create many ModelSpecificationTranslations.
     * @example
     * // Create many ModelSpecificationTranslations
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelSpecificationTranslations and only return the `id`
     * const modelSpecificationTranslationWithIdOnly = await prisma.modelSpecificationTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends modelSpecificationTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, modelSpecificationTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelSpecificationTranslation.
     * @param {modelSpecificationTranslationDeleteArgs} args - Arguments to delete one ModelSpecificationTranslation.
     * @example
     * // Delete one ModelSpecificationTranslation
     * const ModelSpecificationTranslation = await prisma.modelSpecificationTranslation.delete({
     *   where: {
     *     // ... filter to delete one ModelSpecificationTranslation
     *   }
     * })
     * 
     */
    delete<T extends modelSpecificationTranslationDeleteArgs>(args: SelectSubset<T, modelSpecificationTranslationDeleteArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelSpecificationTranslation.
     * @param {modelSpecificationTranslationUpdateArgs} args - Arguments to update one ModelSpecificationTranslation.
     * @example
     * // Update one ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modelSpecificationTranslationUpdateArgs>(args: SelectSubset<T, modelSpecificationTranslationUpdateArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelSpecificationTranslations.
     * @param {modelSpecificationTranslationDeleteManyArgs} args - Arguments to filter ModelSpecificationTranslations to delete.
     * @example
     * // Delete a few ModelSpecificationTranslations
     * const { count } = await prisma.modelSpecificationTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modelSpecificationTranslationDeleteManyArgs>(args?: SelectSubset<T, modelSpecificationTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelSpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelSpecificationTranslations
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modelSpecificationTranslationUpdateManyArgs>(args: SelectSubset<T, modelSpecificationTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelSpecificationTranslations and returns the data updated in the database.
     * @param {modelSpecificationTranslationUpdateManyAndReturnArgs} args - Arguments to update many ModelSpecificationTranslations.
     * @example
     * // Update many ModelSpecificationTranslations
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelSpecificationTranslations and only return the `id`
     * const modelSpecificationTranslationWithIdOnly = await prisma.modelSpecificationTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends modelSpecificationTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, modelSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelSpecificationTranslation.
     * @param {modelSpecificationTranslationUpsertArgs} args - Arguments to update or create a ModelSpecificationTranslation.
     * @example
     * // Update or create a ModelSpecificationTranslation
     * const modelSpecificationTranslation = await prisma.modelSpecificationTranslation.upsert({
     *   create: {
     *     // ... data to create a ModelSpecificationTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelSpecificationTranslation we want to update
     *   }
     * })
     */
    upsert<T extends modelSpecificationTranslationUpsertArgs>(args: SelectSubset<T, modelSpecificationTranslationUpsertArgs<ExtArgs>>): Prisma__modelSpecificationTranslationClient<$Result.GetResult<Prisma.$modelSpecificationTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelSpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationCountArgs} args - Arguments to filter ModelSpecificationTranslations to count.
     * @example
     * // Count the number of ModelSpecificationTranslations
     * const count = await prisma.modelSpecificationTranslation.count({
     *   where: {
     *     // ... the filter for the ModelSpecificationTranslations we want to count
     *   }
     * })
    **/
    count<T extends modelSpecificationTranslationCountArgs>(
      args?: Subset<T, modelSpecificationTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelSpecificationTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelSpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelSpecificationTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelSpecificationTranslationAggregateArgs>(args: Subset<T, ModelSpecificationTranslationAggregateArgs>): Prisma.PrismaPromise<GetModelSpecificationTranslationAggregateType<T>>

    /**
     * Group by ModelSpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelSpecificationTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modelSpecificationTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modelSpecificationTranslationGroupByArgs['orderBy'] }
        : { orderBy?: modelSpecificationTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modelSpecificationTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelSpecificationTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modelSpecificationTranslation model
   */
  readonly fields: modelSpecificationTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modelSpecificationTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modelSpecificationTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modelSpec<T extends modelSpecificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, modelSpecificationDefaultArgs<ExtArgs>>): Prisma__modelSpecificationClient<$Result.GetResult<Prisma.$modelSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modelSpecificationTranslation model
   */
  interface modelSpecificationTranslationFieldRefs {
    readonly id: FieldRef<"modelSpecificationTranslation", 'Int'>
    readonly language: FieldRef<"modelSpecificationTranslation", 'LanguageCode'>
    readonly title: FieldRef<"modelSpecificationTranslation", 'String'>
    readonly modelspecId: FieldRef<"modelSpecificationTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * modelSpecificationTranslation findUnique
   */
  export type modelSpecificationTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecificationTranslation to fetch.
     */
    where: modelSpecificationTranslationWhereUniqueInput
  }

  /**
   * modelSpecificationTranslation findUniqueOrThrow
   */
  export type modelSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecificationTranslation to fetch.
     */
    where: modelSpecificationTranslationWhereUniqueInput
  }

  /**
   * modelSpecificationTranslation findFirst
   */
  export type modelSpecificationTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecificationTranslation to fetch.
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecificationTranslations to fetch.
     */
    orderBy?: modelSpecificationTranslationOrderByWithRelationInput | modelSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modelSpecificationTranslations.
     */
    cursor?: modelSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modelSpecificationTranslations.
     */
    distinct?: ModelSpecificationTranslationScalarFieldEnum | ModelSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * modelSpecificationTranslation findFirstOrThrow
   */
  export type modelSpecificationTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecificationTranslation to fetch.
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecificationTranslations to fetch.
     */
    orderBy?: modelSpecificationTranslationOrderByWithRelationInput | modelSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modelSpecificationTranslations.
     */
    cursor?: modelSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modelSpecificationTranslations.
     */
    distinct?: ModelSpecificationTranslationScalarFieldEnum | ModelSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * modelSpecificationTranslation findMany
   */
  export type modelSpecificationTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which modelSpecificationTranslations to fetch.
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modelSpecificationTranslations to fetch.
     */
    orderBy?: modelSpecificationTranslationOrderByWithRelationInput | modelSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modelSpecificationTranslations.
     */
    cursor?: modelSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modelSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modelSpecificationTranslations.
     */
    skip?: number
    distinct?: ModelSpecificationTranslationScalarFieldEnum | ModelSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * modelSpecificationTranslation create
   */
  export type modelSpecificationTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a modelSpecificationTranslation.
     */
    data: XOR<modelSpecificationTranslationCreateInput, modelSpecificationTranslationUncheckedCreateInput>
  }

  /**
   * modelSpecificationTranslation createMany
   */
  export type modelSpecificationTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many modelSpecificationTranslations.
     */
    data: modelSpecificationTranslationCreateManyInput | modelSpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modelSpecificationTranslation createManyAndReturn
   */
  export type modelSpecificationTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many modelSpecificationTranslations.
     */
    data: modelSpecificationTranslationCreateManyInput | modelSpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * modelSpecificationTranslation update
   */
  export type modelSpecificationTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a modelSpecificationTranslation.
     */
    data: XOR<modelSpecificationTranslationUpdateInput, modelSpecificationTranslationUncheckedUpdateInput>
    /**
     * Choose, which modelSpecificationTranslation to update.
     */
    where: modelSpecificationTranslationWhereUniqueInput
  }

  /**
   * modelSpecificationTranslation updateMany
   */
  export type modelSpecificationTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update modelSpecificationTranslations.
     */
    data: XOR<modelSpecificationTranslationUpdateManyMutationInput, modelSpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which modelSpecificationTranslations to update
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * Limit how many modelSpecificationTranslations to update.
     */
    limit?: number
  }

  /**
   * modelSpecificationTranslation updateManyAndReturn
   */
  export type modelSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to update modelSpecificationTranslations.
     */
    data: XOR<modelSpecificationTranslationUpdateManyMutationInput, modelSpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which modelSpecificationTranslations to update
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * Limit how many modelSpecificationTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * modelSpecificationTranslation upsert
   */
  export type modelSpecificationTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the modelSpecificationTranslation to update in case it exists.
     */
    where: modelSpecificationTranslationWhereUniqueInput
    /**
     * In case the modelSpecificationTranslation found by the `where` argument doesn't exist, create a new modelSpecificationTranslation with this data.
     */
    create: XOR<modelSpecificationTranslationCreateInput, modelSpecificationTranslationUncheckedCreateInput>
    /**
     * In case the modelSpecificationTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modelSpecificationTranslationUpdateInput, modelSpecificationTranslationUncheckedUpdateInput>
  }

  /**
   * modelSpecificationTranslation delete
   */
  export type modelSpecificationTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter which modelSpecificationTranslation to delete.
     */
    where: modelSpecificationTranslationWhereUniqueInput
  }

  /**
   * modelSpecificationTranslation deleteMany
   */
  export type modelSpecificationTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modelSpecificationTranslations to delete
     */
    where?: modelSpecificationTranslationWhereInput
    /**
     * Limit how many modelSpecificationTranslations to delete.
     */
    limit?: number
  }

  /**
   * modelSpecificationTranslation without action
   */
  export type modelSpecificationTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modelSpecificationTranslation
     */
    select?: modelSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modelSpecificationTranslation
     */
    omit?: modelSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelSpecificationTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Advantage
   */

  export type AggregateAdvantage = {
    _count: AdvantageCountAggregateOutputType | null
    _avg: AdvantageAvgAggregateOutputType | null
    _sum: AdvantageSumAggregateOutputType | null
    _min: AdvantageMinAggregateOutputType | null
    _max: AdvantageMaxAggregateOutputType | null
  }

  export type AdvantageAvgAggregateOutputType = {
    id: number | null
  }

  export type AdvantageSumAggregateOutputType = {
    id: number | null
  }

  export type AdvantageMinAggregateOutputType = {
    id: number | null
    heading_en: string | null
    title_en: string | null
  }

  export type AdvantageMaxAggregateOutputType = {
    id: number | null
    heading_en: string | null
    title_en: string | null
  }

  export type AdvantageCountAggregateOutputType = {
    id: number
    heading_en: number
    title_en: number
    _all: number
  }


  export type AdvantageAvgAggregateInputType = {
    id?: true
  }

  export type AdvantageSumAggregateInputType = {
    id?: true
  }

  export type AdvantageMinAggregateInputType = {
    id?: true
    heading_en?: true
    title_en?: true
  }

  export type AdvantageMaxAggregateInputType = {
    id?: true
    heading_en?: true
    title_en?: true
  }

  export type AdvantageCountAggregateInputType = {
    id?: true
    heading_en?: true
    title_en?: true
    _all?: true
  }

  export type AdvantageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advantage to aggregate.
     */
    where?: AdvantageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advantages to fetch.
     */
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvantageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advantages
    **/
    _count?: true | AdvantageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvantageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvantageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvantageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvantageMaxAggregateInputType
  }

  export type GetAdvantageAggregateType<T extends AdvantageAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvantage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvantage[P]>
      : GetScalarType<T[P], AggregateAdvantage[P]>
  }




  export type AdvantageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageWhereInput
    orderBy?: AdvantageOrderByWithAggregationInput | AdvantageOrderByWithAggregationInput[]
    by: AdvantageScalarFieldEnum[] | AdvantageScalarFieldEnum
    having?: AdvantageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvantageCountAggregateInputType | true
    _avg?: AdvantageAvgAggregateInputType
    _sum?: AdvantageSumAggregateInputType
    _min?: AdvantageMinAggregateInputType
    _max?: AdvantageMaxAggregateInputType
  }

  export type AdvantageGroupByOutputType = {
    id: number
    heading_en: string
    title_en: string
    _count: AdvantageCountAggregateOutputType | null
    _avg: AdvantageAvgAggregateOutputType | null
    _sum: AdvantageSumAggregateOutputType | null
    _min: AdvantageMinAggregateOutputType | null
    _max: AdvantageMaxAggregateOutputType | null
  }

  type GetAdvantageGroupByPayload<T extends AdvantageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvantageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvantageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvantageGroupByOutputType[P]>
            : GetScalarType<T[P], AdvantageGroupByOutputType[P]>
        }
      >
    >


  export type AdvantageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading_en?: boolean
    title_en?: boolean
    products?: boolean | Advantage$productsArgs<ExtArgs>
    translations?: boolean | Advantage$translationsArgs<ExtArgs>
    productTranslations?: boolean | Advantage$productTranslationsArgs<ExtArgs>
    _count?: boolean | AdvantageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advantage"]>

  export type AdvantageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading_en?: boolean
    title_en?: boolean
  }, ExtArgs["result"]["advantage"]>

  export type AdvantageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heading_en?: boolean
    title_en?: boolean
  }, ExtArgs["result"]["advantage"]>

  export type AdvantageSelectScalar = {
    id?: boolean
    heading_en?: boolean
    title_en?: boolean
  }

  export type AdvantageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heading_en" | "title_en", ExtArgs["result"]["advantage"]>
  export type AdvantageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Advantage$productsArgs<ExtArgs>
    translations?: boolean | Advantage$translationsArgs<ExtArgs>
    productTranslations?: boolean | Advantage$productTranslationsArgs<ExtArgs>
    _count?: boolean | AdvantageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdvantageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdvantageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdvantagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advantage"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      translations: Prisma.$AdvantageTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      heading_en: string
      title_en: string
    }, ExtArgs["result"]["advantage"]>
    composites: {}
  }

  type AdvantageGetPayload<S extends boolean | null | undefined | AdvantageDefaultArgs> = $Result.GetResult<Prisma.$AdvantagePayload, S>

  type AdvantageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdvantageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdvantageCountAggregateInputType | true
    }

  export interface AdvantageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advantage'], meta: { name: 'Advantage' } }
    /**
     * Find zero or one Advantage that matches the filter.
     * @param {AdvantageFindUniqueArgs} args - Arguments to find a Advantage
     * @example
     * // Get one Advantage
     * const advantage = await prisma.advantage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvantageFindUniqueArgs>(args: SelectSubset<T, AdvantageFindUniqueArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Advantage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdvantageFindUniqueOrThrowArgs} args - Arguments to find a Advantage
     * @example
     * // Get one Advantage
     * const advantage = await prisma.advantage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvantageFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvantageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advantage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageFindFirstArgs} args - Arguments to find a Advantage
     * @example
     * // Get one Advantage
     * const advantage = await prisma.advantage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvantageFindFirstArgs>(args?: SelectSubset<T, AdvantageFindFirstArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advantage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageFindFirstOrThrowArgs} args - Arguments to find a Advantage
     * @example
     * // Get one Advantage
     * const advantage = await prisma.advantage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvantageFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvantageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Advantages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advantages
     * const advantages = await prisma.advantage.findMany()
     * 
     * // Get first 10 Advantages
     * const advantages = await prisma.advantage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advantageWithIdOnly = await prisma.advantage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvantageFindManyArgs>(args?: SelectSubset<T, AdvantageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Advantage.
     * @param {AdvantageCreateArgs} args - Arguments to create a Advantage.
     * @example
     * // Create one Advantage
     * const Advantage = await prisma.advantage.create({
     *   data: {
     *     // ... data to create a Advantage
     *   }
     * })
     * 
     */
    create<T extends AdvantageCreateArgs>(args: SelectSubset<T, AdvantageCreateArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Advantages.
     * @param {AdvantageCreateManyArgs} args - Arguments to create many Advantages.
     * @example
     * // Create many Advantages
     * const advantage = await prisma.advantage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvantageCreateManyArgs>(args?: SelectSubset<T, AdvantageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advantages and returns the data saved in the database.
     * @param {AdvantageCreateManyAndReturnArgs} args - Arguments to create many Advantages.
     * @example
     * // Create many Advantages
     * const advantage = await prisma.advantage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advantages and only return the `id`
     * const advantageWithIdOnly = await prisma.advantage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvantageCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvantageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Advantage.
     * @param {AdvantageDeleteArgs} args - Arguments to delete one Advantage.
     * @example
     * // Delete one Advantage
     * const Advantage = await prisma.advantage.delete({
     *   where: {
     *     // ... filter to delete one Advantage
     *   }
     * })
     * 
     */
    delete<T extends AdvantageDeleteArgs>(args: SelectSubset<T, AdvantageDeleteArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Advantage.
     * @param {AdvantageUpdateArgs} args - Arguments to update one Advantage.
     * @example
     * // Update one Advantage
     * const advantage = await prisma.advantage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvantageUpdateArgs>(args: SelectSubset<T, AdvantageUpdateArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Advantages.
     * @param {AdvantageDeleteManyArgs} args - Arguments to filter Advantages to delete.
     * @example
     * // Delete a few Advantages
     * const { count } = await prisma.advantage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvantageDeleteManyArgs>(args?: SelectSubset<T, AdvantageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advantages
     * const advantage = await prisma.advantage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvantageUpdateManyArgs>(args: SelectSubset<T, AdvantageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advantages and returns the data updated in the database.
     * @param {AdvantageUpdateManyAndReturnArgs} args - Arguments to update many Advantages.
     * @example
     * // Update many Advantages
     * const advantage = await prisma.advantage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Advantages and only return the `id`
     * const advantageWithIdOnly = await prisma.advantage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdvantageUpdateManyAndReturnArgs>(args: SelectSubset<T, AdvantageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Advantage.
     * @param {AdvantageUpsertArgs} args - Arguments to update or create a Advantage.
     * @example
     * // Update or create a Advantage
     * const advantage = await prisma.advantage.upsert({
     *   create: {
     *     // ... data to create a Advantage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advantage we want to update
     *   }
     * })
     */
    upsert<T extends AdvantageUpsertArgs>(args: SelectSubset<T, AdvantageUpsertArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageCountArgs} args - Arguments to filter Advantages to count.
     * @example
     * // Count the number of Advantages
     * const count = await prisma.advantage.count({
     *   where: {
     *     // ... the filter for the Advantages we want to count
     *   }
     * })
    **/
    count<T extends AdvantageCountArgs>(
      args?: Subset<T, AdvantageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvantageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advantage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvantageAggregateArgs>(args: Subset<T, AdvantageAggregateArgs>): Prisma.PrismaPromise<GetAdvantageAggregateType<T>>

    /**
     * Group by Advantage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvantageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvantageGroupByArgs['orderBy'] }
        : { orderBy?: AdvantageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvantageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvantageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advantage model
   */
  readonly fields: AdvantageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advantage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvantageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Advantage$productsArgs<ExtArgs> = {}>(args?: Subset<T, Advantage$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translations<T extends Advantage$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Advantage$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends Advantage$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, Advantage$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advantage model
   */
  interface AdvantageFieldRefs {
    readonly id: FieldRef<"Advantage", 'Int'>
    readonly heading_en: FieldRef<"Advantage", 'String'>
    readonly title_en: FieldRef<"Advantage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Advantage findUnique
   */
  export type AdvantageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter, which Advantage to fetch.
     */
    where: AdvantageWhereUniqueInput
  }

  /**
   * Advantage findUniqueOrThrow
   */
  export type AdvantageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter, which Advantage to fetch.
     */
    where: AdvantageWhereUniqueInput
  }

  /**
   * Advantage findFirst
   */
  export type AdvantageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter, which Advantage to fetch.
     */
    where?: AdvantageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advantages to fetch.
     */
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advantages.
     */
    cursor?: AdvantageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advantages.
     */
    distinct?: AdvantageScalarFieldEnum | AdvantageScalarFieldEnum[]
  }

  /**
   * Advantage findFirstOrThrow
   */
  export type AdvantageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter, which Advantage to fetch.
     */
    where?: AdvantageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advantages to fetch.
     */
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advantages.
     */
    cursor?: AdvantageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advantages.
     */
    distinct?: AdvantageScalarFieldEnum | AdvantageScalarFieldEnum[]
  }

  /**
   * Advantage findMany
   */
  export type AdvantageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter, which Advantages to fetch.
     */
    where?: AdvantageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advantages to fetch.
     */
    orderBy?: AdvantageOrderByWithRelationInput | AdvantageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advantages.
     */
    cursor?: AdvantageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advantages.
     */
    skip?: number
    distinct?: AdvantageScalarFieldEnum | AdvantageScalarFieldEnum[]
  }

  /**
   * Advantage create
   */
  export type AdvantageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * The data needed to create a Advantage.
     */
    data: XOR<AdvantageCreateInput, AdvantageUncheckedCreateInput>
  }

  /**
   * Advantage createMany
   */
  export type AdvantageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advantages.
     */
    data: AdvantageCreateManyInput | AdvantageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advantage createManyAndReturn
   */
  export type AdvantageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * The data used to create many Advantages.
     */
    data: AdvantageCreateManyInput | AdvantageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advantage update
   */
  export type AdvantageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * The data needed to update a Advantage.
     */
    data: XOR<AdvantageUpdateInput, AdvantageUncheckedUpdateInput>
    /**
     * Choose, which Advantage to update.
     */
    where: AdvantageWhereUniqueInput
  }

  /**
   * Advantage updateMany
   */
  export type AdvantageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advantages.
     */
    data: XOR<AdvantageUpdateManyMutationInput, AdvantageUncheckedUpdateManyInput>
    /**
     * Filter which Advantages to update
     */
    where?: AdvantageWhereInput
    /**
     * Limit how many Advantages to update.
     */
    limit?: number
  }

  /**
   * Advantage updateManyAndReturn
   */
  export type AdvantageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * The data used to update Advantages.
     */
    data: XOR<AdvantageUpdateManyMutationInput, AdvantageUncheckedUpdateManyInput>
    /**
     * Filter which Advantages to update
     */
    where?: AdvantageWhereInput
    /**
     * Limit how many Advantages to update.
     */
    limit?: number
  }

  /**
   * Advantage upsert
   */
  export type AdvantageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * The filter to search for the Advantage to update in case it exists.
     */
    where: AdvantageWhereUniqueInput
    /**
     * In case the Advantage found by the `where` argument doesn't exist, create a new Advantage with this data.
     */
    create: XOR<AdvantageCreateInput, AdvantageUncheckedCreateInput>
    /**
     * In case the Advantage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvantageUpdateInput, AdvantageUncheckedUpdateInput>
  }

  /**
   * Advantage delete
   */
  export type AdvantageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
    /**
     * Filter which Advantage to delete.
     */
    where: AdvantageWhereUniqueInput
  }

  /**
   * Advantage deleteMany
   */
  export type AdvantageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advantages to delete
     */
    where?: AdvantageWhereInput
    /**
     * Limit how many Advantages to delete.
     */
    limit?: number
  }

  /**
   * Advantage.products
   */
  export type Advantage$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Advantage.translations
   */
  export type Advantage$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    where?: AdvantageTranslationWhereInput
    orderBy?: AdvantageTranslationOrderByWithRelationInput | AdvantageTranslationOrderByWithRelationInput[]
    cursor?: AdvantageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvantageTranslationScalarFieldEnum | AdvantageTranslationScalarFieldEnum[]
  }

  /**
   * Advantage.productTranslations
   */
  export type Advantage$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * Advantage without action
   */
  export type AdvantageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advantage
     */
    select?: AdvantageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advantage
     */
    omit?: AdvantageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageInclude<ExtArgs> | null
  }


  /**
   * Model AdvantageTranslation
   */

  export type AggregateAdvantageTranslation = {
    _count: AdvantageTranslationCountAggregateOutputType | null
    _avg: AdvantageTranslationAvgAggregateOutputType | null
    _sum: AdvantageTranslationSumAggregateOutputType | null
    _min: AdvantageTranslationMinAggregateOutputType | null
    _max: AdvantageTranslationMaxAggregateOutputType | null
  }

  export type AdvantageTranslationAvgAggregateOutputType = {
    id: number | null
    advantageId: number | null
  }

  export type AdvantageTranslationSumAggregateOutputType = {
    id: number | null
    advantageId: number | null
  }

  export type AdvantageTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    heading: string | null
    title: string | null
    advantageId: number | null
  }

  export type AdvantageTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    heading: string | null
    title: string | null
    advantageId: number | null
  }

  export type AdvantageTranslationCountAggregateOutputType = {
    id: number
    language: number
    heading: number
    title: number
    advantageId: number
    _all: number
  }


  export type AdvantageTranslationAvgAggregateInputType = {
    id?: true
    advantageId?: true
  }

  export type AdvantageTranslationSumAggregateInputType = {
    id?: true
    advantageId?: true
  }

  export type AdvantageTranslationMinAggregateInputType = {
    id?: true
    language?: true
    heading?: true
    title?: true
    advantageId?: true
  }

  export type AdvantageTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    heading?: true
    title?: true
    advantageId?: true
  }

  export type AdvantageTranslationCountAggregateInputType = {
    id?: true
    language?: true
    heading?: true
    title?: true
    advantageId?: true
    _all?: true
  }

  export type AdvantageTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvantageTranslation to aggregate.
     */
    where?: AdvantageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageTranslations to fetch.
     */
    orderBy?: AdvantageTranslationOrderByWithRelationInput | AdvantageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvantageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvantageTranslations
    **/
    _count?: true | AdvantageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvantageTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvantageTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvantageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvantageTranslationMaxAggregateInputType
  }

  export type GetAdvantageTranslationAggregateType<T extends AdvantageTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvantageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvantageTranslation[P]>
      : GetScalarType<T[P], AggregateAdvantageTranslation[P]>
  }




  export type AdvantageTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageTranslationWhereInput
    orderBy?: AdvantageTranslationOrderByWithAggregationInput | AdvantageTranslationOrderByWithAggregationInput[]
    by: AdvantageTranslationScalarFieldEnum[] | AdvantageTranslationScalarFieldEnum
    having?: AdvantageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvantageTranslationCountAggregateInputType | true
    _avg?: AdvantageTranslationAvgAggregateInputType
    _sum?: AdvantageTranslationSumAggregateInputType
    _min?: AdvantageTranslationMinAggregateInputType
    _max?: AdvantageTranslationMaxAggregateInputType
  }

  export type AdvantageTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    heading: string
    title: string
    advantageId: number
    _count: AdvantageTranslationCountAggregateOutputType | null
    _avg: AdvantageTranslationAvgAggregateOutputType | null
    _sum: AdvantageTranslationSumAggregateOutputType | null
    _min: AdvantageTranslationMinAggregateOutputType | null
    _max: AdvantageTranslationMaxAggregateOutputType | null
  }

  type GetAdvantageTranslationGroupByPayload<T extends AdvantageTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvantageTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvantageTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvantageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], AdvantageTranslationGroupByOutputType[P]>
        }
      >
    >


  export type AdvantageTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    heading?: boolean
    title?: boolean
    advantageId?: boolean
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advantageTranslation"]>

  export type AdvantageTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    heading?: boolean
    title?: boolean
    advantageId?: boolean
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advantageTranslation"]>

  export type AdvantageTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    heading?: boolean
    title?: boolean
    advantageId?: boolean
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advantageTranslation"]>

  export type AdvantageTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    heading?: boolean
    title?: boolean
    advantageId?: boolean
  }

  export type AdvantageTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "heading" | "title" | "advantageId", ExtArgs["result"]["advantageTranslation"]>
  export type AdvantageTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }
  export type AdvantageTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }
  export type AdvantageTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantage?: boolean | AdvantageDefaultArgs<ExtArgs>
  }

  export type $AdvantageTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvantageTranslation"
    objects: {
      advantage: Prisma.$AdvantagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      heading: string
      title: string
      advantageId: number
    }, ExtArgs["result"]["advantageTranslation"]>
    composites: {}
  }

  type AdvantageTranslationGetPayload<S extends boolean | null | undefined | AdvantageTranslationDefaultArgs> = $Result.GetResult<Prisma.$AdvantageTranslationPayload, S>

  type AdvantageTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdvantageTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdvantageTranslationCountAggregateInputType | true
    }

  export interface AdvantageTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvantageTranslation'], meta: { name: 'AdvantageTranslation' } }
    /**
     * Find zero or one AdvantageTranslation that matches the filter.
     * @param {AdvantageTranslationFindUniqueArgs} args - Arguments to find a AdvantageTranslation
     * @example
     * // Get one AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvantageTranslationFindUniqueArgs>(args: SelectSubset<T, AdvantageTranslationFindUniqueArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdvantageTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdvantageTranslationFindUniqueOrThrowArgs} args - Arguments to find a AdvantageTranslation
     * @example
     * // Get one AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvantageTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvantageTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdvantageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationFindFirstArgs} args - Arguments to find a AdvantageTranslation
     * @example
     * // Get one AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvantageTranslationFindFirstArgs>(args?: SelectSubset<T, AdvantageTranslationFindFirstArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdvantageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationFindFirstOrThrowArgs} args - Arguments to find a AdvantageTranslation
     * @example
     * // Get one AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvantageTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvantageTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdvantageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvantageTranslations
     * const advantageTranslations = await prisma.advantageTranslation.findMany()
     * 
     * // Get first 10 AdvantageTranslations
     * const advantageTranslations = await prisma.advantageTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advantageTranslationWithIdOnly = await prisma.advantageTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvantageTranslationFindManyArgs>(args?: SelectSubset<T, AdvantageTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdvantageTranslation.
     * @param {AdvantageTranslationCreateArgs} args - Arguments to create a AdvantageTranslation.
     * @example
     * // Create one AdvantageTranslation
     * const AdvantageTranslation = await prisma.advantageTranslation.create({
     *   data: {
     *     // ... data to create a AdvantageTranslation
     *   }
     * })
     * 
     */
    create<T extends AdvantageTranslationCreateArgs>(args: SelectSubset<T, AdvantageTranslationCreateArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdvantageTranslations.
     * @param {AdvantageTranslationCreateManyArgs} args - Arguments to create many AdvantageTranslations.
     * @example
     * // Create many AdvantageTranslations
     * const advantageTranslation = await prisma.advantageTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvantageTranslationCreateManyArgs>(args?: SelectSubset<T, AdvantageTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdvantageTranslations and returns the data saved in the database.
     * @param {AdvantageTranslationCreateManyAndReturnArgs} args - Arguments to create many AdvantageTranslations.
     * @example
     * // Create many AdvantageTranslations
     * const advantageTranslation = await prisma.advantageTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdvantageTranslations and only return the `id`
     * const advantageTranslationWithIdOnly = await prisma.advantageTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvantageTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvantageTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdvantageTranslation.
     * @param {AdvantageTranslationDeleteArgs} args - Arguments to delete one AdvantageTranslation.
     * @example
     * // Delete one AdvantageTranslation
     * const AdvantageTranslation = await prisma.advantageTranslation.delete({
     *   where: {
     *     // ... filter to delete one AdvantageTranslation
     *   }
     * })
     * 
     */
    delete<T extends AdvantageTranslationDeleteArgs>(args: SelectSubset<T, AdvantageTranslationDeleteArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdvantageTranslation.
     * @param {AdvantageTranslationUpdateArgs} args - Arguments to update one AdvantageTranslation.
     * @example
     * // Update one AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvantageTranslationUpdateArgs>(args: SelectSubset<T, AdvantageTranslationUpdateArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdvantageTranslations.
     * @param {AdvantageTranslationDeleteManyArgs} args - Arguments to filter AdvantageTranslations to delete.
     * @example
     * // Delete a few AdvantageTranslations
     * const { count } = await prisma.advantageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvantageTranslationDeleteManyArgs>(args?: SelectSubset<T, AdvantageTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvantageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvantageTranslations
     * const advantageTranslation = await prisma.advantageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvantageTranslationUpdateManyArgs>(args: SelectSubset<T, AdvantageTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvantageTranslations and returns the data updated in the database.
     * @param {AdvantageTranslationUpdateManyAndReturnArgs} args - Arguments to update many AdvantageTranslations.
     * @example
     * // Update many AdvantageTranslations
     * const advantageTranslation = await prisma.advantageTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdvantageTranslations and only return the `id`
     * const advantageTranslationWithIdOnly = await prisma.advantageTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdvantageTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, AdvantageTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdvantageTranslation.
     * @param {AdvantageTranslationUpsertArgs} args - Arguments to update or create a AdvantageTranslation.
     * @example
     * // Update or create a AdvantageTranslation
     * const advantageTranslation = await prisma.advantageTranslation.upsert({
     *   create: {
     *     // ... data to create a AdvantageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvantageTranslation we want to update
     *   }
     * })
     */
    upsert<T extends AdvantageTranslationUpsertArgs>(args: SelectSubset<T, AdvantageTranslationUpsertArgs<ExtArgs>>): Prisma__AdvantageTranslationClient<$Result.GetResult<Prisma.$AdvantageTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdvantageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationCountArgs} args - Arguments to filter AdvantageTranslations to count.
     * @example
     * // Count the number of AdvantageTranslations
     * const count = await prisma.advantageTranslation.count({
     *   where: {
     *     // ... the filter for the AdvantageTranslations we want to count
     *   }
     * })
    **/
    count<T extends AdvantageTranslationCountArgs>(
      args?: Subset<T, AdvantageTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvantageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvantageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvantageTranslationAggregateArgs>(args: Subset<T, AdvantageTranslationAggregateArgs>): Prisma.PrismaPromise<GetAdvantageTranslationAggregateType<T>>

    /**
     * Group by AdvantageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvantageTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvantageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: AdvantageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvantageTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvantageTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvantageTranslation model
   */
  readonly fields: AdvantageTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvantageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvantageTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    advantage<T extends AdvantageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvantageDefaultArgs<ExtArgs>>): Prisma__AdvantageClient<$Result.GetResult<Prisma.$AdvantagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvantageTranslation model
   */
  interface AdvantageTranslationFieldRefs {
    readonly id: FieldRef<"AdvantageTranslation", 'Int'>
    readonly language: FieldRef<"AdvantageTranslation", 'LanguageCode'>
    readonly heading: FieldRef<"AdvantageTranslation", 'String'>
    readonly title: FieldRef<"AdvantageTranslation", 'String'>
    readonly advantageId: FieldRef<"AdvantageTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AdvantageTranslation findUnique
   */
  export type AdvantageTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which AdvantageTranslation to fetch.
     */
    where: AdvantageTranslationWhereUniqueInput
  }

  /**
   * AdvantageTranslation findUniqueOrThrow
   */
  export type AdvantageTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which AdvantageTranslation to fetch.
     */
    where: AdvantageTranslationWhereUniqueInput
  }

  /**
   * AdvantageTranslation findFirst
   */
  export type AdvantageTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which AdvantageTranslation to fetch.
     */
    where?: AdvantageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageTranslations to fetch.
     */
    orderBy?: AdvantageTranslationOrderByWithRelationInput | AdvantageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvantageTranslations.
     */
    cursor?: AdvantageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvantageTranslations.
     */
    distinct?: AdvantageTranslationScalarFieldEnum | AdvantageTranslationScalarFieldEnum[]
  }

  /**
   * AdvantageTranslation findFirstOrThrow
   */
  export type AdvantageTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which AdvantageTranslation to fetch.
     */
    where?: AdvantageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageTranslations to fetch.
     */
    orderBy?: AdvantageTranslationOrderByWithRelationInput | AdvantageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvantageTranslations.
     */
    cursor?: AdvantageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvantageTranslations.
     */
    distinct?: AdvantageTranslationScalarFieldEnum | AdvantageTranslationScalarFieldEnum[]
  }

  /**
   * AdvantageTranslation findMany
   */
  export type AdvantageTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which AdvantageTranslations to fetch.
     */
    where?: AdvantageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageTranslations to fetch.
     */
    orderBy?: AdvantageTranslationOrderByWithRelationInput | AdvantageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvantageTranslations.
     */
    cursor?: AdvantageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageTranslations.
     */
    skip?: number
    distinct?: AdvantageTranslationScalarFieldEnum | AdvantageTranslationScalarFieldEnum[]
  }

  /**
   * AdvantageTranslation create
   */
  export type AdvantageTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdvantageTranslation.
     */
    data: XOR<AdvantageTranslationCreateInput, AdvantageTranslationUncheckedCreateInput>
  }

  /**
   * AdvantageTranslation createMany
   */
  export type AdvantageTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvantageTranslations.
     */
    data: AdvantageTranslationCreateManyInput | AdvantageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvantageTranslation createManyAndReturn
   */
  export type AdvantageTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many AdvantageTranslations.
     */
    data: AdvantageTranslationCreateManyInput | AdvantageTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdvantageTranslation update
   */
  export type AdvantageTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdvantageTranslation.
     */
    data: XOR<AdvantageTranslationUpdateInput, AdvantageTranslationUncheckedUpdateInput>
    /**
     * Choose, which AdvantageTranslation to update.
     */
    where: AdvantageTranslationWhereUniqueInput
  }

  /**
   * AdvantageTranslation updateMany
   */
  export type AdvantageTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvantageTranslations.
     */
    data: XOR<AdvantageTranslationUpdateManyMutationInput, AdvantageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which AdvantageTranslations to update
     */
    where?: AdvantageTranslationWhereInput
    /**
     * Limit how many AdvantageTranslations to update.
     */
    limit?: number
  }

  /**
   * AdvantageTranslation updateManyAndReturn
   */
  export type AdvantageTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * The data used to update AdvantageTranslations.
     */
    data: XOR<AdvantageTranslationUpdateManyMutationInput, AdvantageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which AdvantageTranslations to update
     */
    where?: AdvantageTranslationWhereInput
    /**
     * Limit how many AdvantageTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdvantageTranslation upsert
   */
  export type AdvantageTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdvantageTranslation to update in case it exists.
     */
    where: AdvantageTranslationWhereUniqueInput
    /**
     * In case the AdvantageTranslation found by the `where` argument doesn't exist, create a new AdvantageTranslation with this data.
     */
    create: XOR<AdvantageTranslationCreateInput, AdvantageTranslationUncheckedCreateInput>
    /**
     * In case the AdvantageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvantageTranslationUpdateInput, AdvantageTranslationUncheckedUpdateInput>
  }

  /**
   * AdvantageTranslation delete
   */
  export type AdvantageTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
    /**
     * Filter which AdvantageTranslation to delete.
     */
    where: AdvantageTranslationWhereUniqueInput
  }

  /**
   * AdvantageTranslation deleteMany
   */
  export type AdvantageTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvantageTranslations to delete
     */
    where?: AdvantageTranslationWhereInput
    /**
     * Limit how many AdvantageTranslations to delete.
     */
    limit?: number
  }

  /**
   * AdvantageTranslation without action
   */
  export type AdvantageTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageTranslation
     */
    select?: AdvantageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdvantageTranslation
     */
    omit?: AdvantageTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvantageTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Specification
   */

  export type AggregateSpecification = {
    _count: SpecificationCountAggregateOutputType | null
    _avg: SpecificationAvgAggregateOutputType | null
    _sum: SpecificationSumAggregateOutputType | null
    _min: SpecificationMinAggregateOutputType | null
    _max: SpecificationMaxAggregateOutputType | null
  }

  export type SpecificationAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    productId: number | null
  }

  export type SpecificationSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    productId: number | null
  }

  export type SpecificationMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    productId: number | null
    speed_en: string | null
    paperSpecification_en: string | null
    sizeRange_en: string | null
  }

  export type SpecificationMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    productId: number | null
    speed_en: string | null
    paperSpecification_en: string | null
    sizeRange_en: string | null
  }

  export type SpecificationCountAggregateOutputType = {
    id: number
    categoryId: number
    productId: number
    speed_en: number
    paperSpecification_en: number
    sizeRange_en: number
    _all: number
  }


  export type SpecificationAvgAggregateInputType = {
    id?: true
    categoryId?: true
    productId?: true
  }

  export type SpecificationSumAggregateInputType = {
    id?: true
    categoryId?: true
    productId?: true
  }

  export type SpecificationMinAggregateInputType = {
    id?: true
    categoryId?: true
    productId?: true
    speed_en?: true
    paperSpecification_en?: true
    sizeRange_en?: true
  }

  export type SpecificationMaxAggregateInputType = {
    id?: true
    categoryId?: true
    productId?: true
    speed_en?: true
    paperSpecification_en?: true
    sizeRange_en?: true
  }

  export type SpecificationCountAggregateInputType = {
    id?: true
    categoryId?: true
    productId?: true
    speed_en?: true
    paperSpecification_en?: true
    sizeRange_en?: true
    _all?: true
  }

  export type SpecificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specification to aggregate.
     */
    where?: SpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specifications to fetch.
     */
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specifications
    **/
    _count?: true | SpecificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecificationMaxAggregateInputType
  }

  export type GetSpecificationAggregateType<T extends SpecificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecification[P]>
      : GetScalarType<T[P], AggregateSpecification[P]>
  }




  export type SpecificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificationWhereInput
    orderBy?: SpecificationOrderByWithAggregationInput | SpecificationOrderByWithAggregationInput[]
    by: SpecificationScalarFieldEnum[] | SpecificationScalarFieldEnum
    having?: SpecificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecificationCountAggregateInputType | true
    _avg?: SpecificationAvgAggregateInputType
    _sum?: SpecificationSumAggregateInputType
    _min?: SpecificationMinAggregateInputType
    _max?: SpecificationMaxAggregateInputType
  }

  export type SpecificationGroupByOutputType = {
    id: number
    categoryId: number | null
    productId: number | null
    speed_en: string | null
    paperSpecification_en: string | null
    sizeRange_en: string | null
    _count: SpecificationCountAggregateOutputType | null
    _avg: SpecificationAvgAggregateOutputType | null
    _sum: SpecificationSumAggregateOutputType | null
    _min: SpecificationMinAggregateOutputType | null
    _max: SpecificationMaxAggregateOutputType | null
  }

  type GetSpecificationGroupByPayload<T extends SpecificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecificationGroupByOutputType[P]>
            : GetScalarType<T[P], SpecificationGroupByOutputType[P]>
        }
      >
    >


  export type SpecificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    productId?: boolean
    speed_en?: boolean
    paperSpecification_en?: boolean
    sizeRange_en?: boolean
    product?: boolean | Specification$productArgs<ExtArgs>
    translations?: boolean | Specification$translationsArgs<ExtArgs>
    productTranslations?: boolean | Specification$productTranslationsArgs<ExtArgs>
    _count?: boolean | SpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specification"]>

  export type SpecificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    productId?: boolean
    speed_en?: boolean
    paperSpecification_en?: boolean
    sizeRange_en?: boolean
    product?: boolean | Specification$productArgs<ExtArgs>
  }, ExtArgs["result"]["specification"]>

  export type SpecificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    productId?: boolean
    speed_en?: boolean
    paperSpecification_en?: boolean
    sizeRange_en?: boolean
    product?: boolean | Specification$productArgs<ExtArgs>
  }, ExtArgs["result"]["specification"]>

  export type SpecificationSelectScalar = {
    id?: boolean
    categoryId?: boolean
    productId?: boolean
    speed_en?: boolean
    paperSpecification_en?: boolean
    sizeRange_en?: boolean
  }

  export type SpecificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "productId" | "speed_en" | "paperSpecification_en" | "sizeRange_en", ExtArgs["result"]["specification"]>
  export type SpecificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Specification$productArgs<ExtArgs>
    translations?: boolean | Specification$translationsArgs<ExtArgs>
    productTranslations?: boolean | Specification$productTranslationsArgs<ExtArgs>
    _count?: boolean | SpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Specification$productArgs<ExtArgs>
  }
  export type SpecificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Specification$productArgs<ExtArgs>
  }

  export type $SpecificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specification"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
      translations: Prisma.$SpecificationTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: number | null
      productId: number | null
      speed_en: string | null
      paperSpecification_en: string | null
      sizeRange_en: string | null
    }, ExtArgs["result"]["specification"]>
    composites: {}
  }

  type SpecificationGetPayload<S extends boolean | null | undefined | SpecificationDefaultArgs> = $Result.GetResult<Prisma.$SpecificationPayload, S>

  type SpecificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecificationCountAggregateInputType | true
    }

  export interface SpecificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specification'], meta: { name: 'Specification' } }
    /**
     * Find zero or one Specification that matches the filter.
     * @param {SpecificationFindUniqueArgs} args - Arguments to find a Specification
     * @example
     * // Get one Specification
     * const specification = await prisma.specification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecificationFindUniqueArgs>(args: SelectSubset<T, SpecificationFindUniqueArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Specification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecificationFindUniqueOrThrowArgs} args - Arguments to find a Specification
     * @example
     * // Get one Specification
     * const specification = await prisma.specification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationFindFirstArgs} args - Arguments to find a Specification
     * @example
     * // Get one Specification
     * const specification = await prisma.specification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecificationFindFirstArgs>(args?: SelectSubset<T, SpecificationFindFirstArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationFindFirstOrThrowArgs} args - Arguments to find a Specification
     * @example
     * // Get one Specification
     * const specification = await prisma.specification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Specifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specifications
     * const specifications = await prisma.specification.findMany()
     * 
     * // Get first 10 Specifications
     * const specifications = await prisma.specification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specificationWithIdOnly = await prisma.specification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecificationFindManyArgs>(args?: SelectSubset<T, SpecificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Specification.
     * @param {SpecificationCreateArgs} args - Arguments to create a Specification.
     * @example
     * // Create one Specification
     * const Specification = await prisma.specification.create({
     *   data: {
     *     // ... data to create a Specification
     *   }
     * })
     * 
     */
    create<T extends SpecificationCreateArgs>(args: SelectSubset<T, SpecificationCreateArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Specifications.
     * @param {SpecificationCreateManyArgs} args - Arguments to create many Specifications.
     * @example
     * // Create many Specifications
     * const specification = await prisma.specification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecificationCreateManyArgs>(args?: SelectSubset<T, SpecificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specifications and returns the data saved in the database.
     * @param {SpecificationCreateManyAndReturnArgs} args - Arguments to create many Specifications.
     * @example
     * // Create many Specifications
     * const specification = await prisma.specification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specifications and only return the `id`
     * const specificationWithIdOnly = await prisma.specification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Specification.
     * @param {SpecificationDeleteArgs} args - Arguments to delete one Specification.
     * @example
     * // Delete one Specification
     * const Specification = await prisma.specification.delete({
     *   where: {
     *     // ... filter to delete one Specification
     *   }
     * })
     * 
     */
    delete<T extends SpecificationDeleteArgs>(args: SelectSubset<T, SpecificationDeleteArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Specification.
     * @param {SpecificationUpdateArgs} args - Arguments to update one Specification.
     * @example
     * // Update one Specification
     * const specification = await prisma.specification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecificationUpdateArgs>(args: SelectSubset<T, SpecificationUpdateArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Specifications.
     * @param {SpecificationDeleteManyArgs} args - Arguments to filter Specifications to delete.
     * @example
     * // Delete a few Specifications
     * const { count } = await prisma.specification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecificationDeleteManyArgs>(args?: SelectSubset<T, SpecificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specifications
     * const specification = await prisma.specification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecificationUpdateManyArgs>(args: SelectSubset<T, SpecificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specifications and returns the data updated in the database.
     * @param {SpecificationUpdateManyAndReturnArgs} args - Arguments to update many Specifications.
     * @example
     * // Update many Specifications
     * const specification = await prisma.specification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Specifications and only return the `id`
     * const specificationWithIdOnly = await prisma.specification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Specification.
     * @param {SpecificationUpsertArgs} args - Arguments to update or create a Specification.
     * @example
     * // Update or create a Specification
     * const specification = await prisma.specification.upsert({
     *   create: {
     *     // ... data to create a Specification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specification we want to update
     *   }
     * })
     */
    upsert<T extends SpecificationUpsertArgs>(args: SelectSubset<T, SpecificationUpsertArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationCountArgs} args - Arguments to filter Specifications to count.
     * @example
     * // Count the number of Specifications
     * const count = await prisma.specification.count({
     *   where: {
     *     // ... the filter for the Specifications we want to count
     *   }
     * })
    **/
    count<T extends SpecificationCountArgs>(
      args?: Subset<T, SpecificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecificationAggregateArgs>(args: Subset<T, SpecificationAggregateArgs>): Prisma.PrismaPromise<GetSpecificationAggregateType<T>>

    /**
     * Group by Specification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecificationGroupByArgs['orderBy'] }
        : { orderBy?: SpecificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specification model
   */
  readonly fields: SpecificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends Specification$productArgs<ExtArgs> = {}>(args?: Subset<T, Specification$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    translations<T extends Specification$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Specification$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends Specification$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, Specification$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specification model
   */
  interface SpecificationFieldRefs {
    readonly id: FieldRef<"Specification", 'Int'>
    readonly categoryId: FieldRef<"Specification", 'Int'>
    readonly productId: FieldRef<"Specification", 'Int'>
    readonly speed_en: FieldRef<"Specification", 'String'>
    readonly paperSpecification_en: FieldRef<"Specification", 'String'>
    readonly sizeRange_en: FieldRef<"Specification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Specification findUnique
   */
  export type SpecificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter, which Specification to fetch.
     */
    where: SpecificationWhereUniqueInput
  }

  /**
   * Specification findUniqueOrThrow
   */
  export type SpecificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter, which Specification to fetch.
     */
    where: SpecificationWhereUniqueInput
  }

  /**
   * Specification findFirst
   */
  export type SpecificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter, which Specification to fetch.
     */
    where?: SpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specifications to fetch.
     */
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specifications.
     */
    cursor?: SpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specifications.
     */
    distinct?: SpecificationScalarFieldEnum | SpecificationScalarFieldEnum[]
  }

  /**
   * Specification findFirstOrThrow
   */
  export type SpecificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter, which Specification to fetch.
     */
    where?: SpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specifications to fetch.
     */
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specifications.
     */
    cursor?: SpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specifications.
     */
    distinct?: SpecificationScalarFieldEnum | SpecificationScalarFieldEnum[]
  }

  /**
   * Specification findMany
   */
  export type SpecificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter, which Specifications to fetch.
     */
    where?: SpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specifications to fetch.
     */
    orderBy?: SpecificationOrderByWithRelationInput | SpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specifications.
     */
    cursor?: SpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specifications.
     */
    skip?: number
    distinct?: SpecificationScalarFieldEnum | SpecificationScalarFieldEnum[]
  }

  /**
   * Specification create
   */
  export type SpecificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Specification.
     */
    data?: XOR<SpecificationCreateInput, SpecificationUncheckedCreateInput>
  }

  /**
   * Specification createMany
   */
  export type SpecificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specifications.
     */
    data: SpecificationCreateManyInput | SpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specification createManyAndReturn
   */
  export type SpecificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * The data used to create many Specifications.
     */
    data: SpecificationCreateManyInput | SpecificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specification update
   */
  export type SpecificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Specification.
     */
    data: XOR<SpecificationUpdateInput, SpecificationUncheckedUpdateInput>
    /**
     * Choose, which Specification to update.
     */
    where: SpecificationWhereUniqueInput
  }

  /**
   * Specification updateMany
   */
  export type SpecificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specifications.
     */
    data: XOR<SpecificationUpdateManyMutationInput, SpecificationUncheckedUpdateManyInput>
    /**
     * Filter which Specifications to update
     */
    where?: SpecificationWhereInput
    /**
     * Limit how many Specifications to update.
     */
    limit?: number
  }

  /**
   * Specification updateManyAndReturn
   */
  export type SpecificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * The data used to update Specifications.
     */
    data: XOR<SpecificationUpdateManyMutationInput, SpecificationUncheckedUpdateManyInput>
    /**
     * Filter which Specifications to update
     */
    where?: SpecificationWhereInput
    /**
     * Limit how many Specifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specification upsert
   */
  export type SpecificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Specification to update in case it exists.
     */
    where: SpecificationWhereUniqueInput
    /**
     * In case the Specification found by the `where` argument doesn't exist, create a new Specification with this data.
     */
    create: XOR<SpecificationCreateInput, SpecificationUncheckedCreateInput>
    /**
     * In case the Specification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecificationUpdateInput, SpecificationUncheckedUpdateInput>
  }

  /**
   * Specification delete
   */
  export type SpecificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
    /**
     * Filter which Specification to delete.
     */
    where: SpecificationWhereUniqueInput
  }

  /**
   * Specification deleteMany
   */
  export type SpecificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specifications to delete
     */
    where?: SpecificationWhereInput
    /**
     * Limit how many Specifications to delete.
     */
    limit?: number
  }

  /**
   * Specification.product
   */
  export type Specification$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Specification.translations
   */
  export type Specification$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    where?: SpecificationTranslationWhereInput
    orderBy?: SpecificationTranslationOrderByWithRelationInput | SpecificationTranslationOrderByWithRelationInput[]
    cursor?: SpecificationTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificationTranslationScalarFieldEnum | SpecificationTranslationScalarFieldEnum[]
  }

  /**
   * Specification.productTranslations
   */
  export type Specification$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * Specification without action
   */
  export type SpecificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specification
     */
    select?: SpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specification
     */
    omit?: SpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationInclude<ExtArgs> | null
  }


  /**
   * Model SpecificationTranslation
   */

  export type AggregateSpecificationTranslation = {
    _count: SpecificationTranslationCountAggregateOutputType | null
    _avg: SpecificationTranslationAvgAggregateOutputType | null
    _sum: SpecificationTranslationSumAggregateOutputType | null
    _min: SpecificationTranslationMinAggregateOutputType | null
    _max: SpecificationTranslationMaxAggregateOutputType | null
  }

  export type SpecificationTranslationAvgAggregateOutputType = {
    id: number | null
    specificationId: number | null
  }

  export type SpecificationTranslationSumAggregateOutputType = {
    id: number | null
    specificationId: number | null
  }

  export type SpecificationTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    speed: string | null
    paperSpecification: string | null
    sizeRange: string | null
    specificationId: number | null
  }

  export type SpecificationTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    speed: string | null
    paperSpecification: string | null
    sizeRange: string | null
    specificationId: number | null
  }

  export type SpecificationTranslationCountAggregateOutputType = {
    id: number
    language: number
    speed: number
    paperSpecification: number
    sizeRange: number
    specificationId: number
    _all: number
  }


  export type SpecificationTranslationAvgAggregateInputType = {
    id?: true
    specificationId?: true
  }

  export type SpecificationTranslationSumAggregateInputType = {
    id?: true
    specificationId?: true
  }

  export type SpecificationTranslationMinAggregateInputType = {
    id?: true
    language?: true
    speed?: true
    paperSpecification?: true
    sizeRange?: true
    specificationId?: true
  }

  export type SpecificationTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    speed?: true
    paperSpecification?: true
    sizeRange?: true
    specificationId?: true
  }

  export type SpecificationTranslationCountAggregateInputType = {
    id?: true
    language?: true
    speed?: true
    paperSpecification?: true
    sizeRange?: true
    specificationId?: true
    _all?: true
  }

  export type SpecificationTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificationTranslation to aggregate.
     */
    where?: SpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificationTranslations to fetch.
     */
    orderBy?: SpecificationTranslationOrderByWithRelationInput | SpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecificationTranslations
    **/
    _count?: true | SpecificationTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecificationTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecificationTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecificationTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecificationTranslationMaxAggregateInputType
  }

  export type GetSpecificationTranslationAggregateType<T extends SpecificationTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecificationTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecificationTranslation[P]>
      : GetScalarType<T[P], AggregateSpecificationTranslation[P]>
  }




  export type SpecificationTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificationTranslationWhereInput
    orderBy?: SpecificationTranslationOrderByWithAggregationInput | SpecificationTranslationOrderByWithAggregationInput[]
    by: SpecificationTranslationScalarFieldEnum[] | SpecificationTranslationScalarFieldEnum
    having?: SpecificationTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecificationTranslationCountAggregateInputType | true
    _avg?: SpecificationTranslationAvgAggregateInputType
    _sum?: SpecificationTranslationSumAggregateInputType
    _min?: SpecificationTranslationMinAggregateInputType
    _max?: SpecificationTranslationMaxAggregateInputType
  }

  export type SpecificationTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    speed: string | null
    paperSpecification: string | null
    sizeRange: string | null
    specificationId: number
    _count: SpecificationTranslationCountAggregateOutputType | null
    _avg: SpecificationTranslationAvgAggregateOutputType | null
    _sum: SpecificationTranslationSumAggregateOutputType | null
    _min: SpecificationTranslationMinAggregateOutputType | null
    _max: SpecificationTranslationMaxAggregateOutputType | null
  }

  type GetSpecificationTranslationGroupByPayload<T extends SpecificationTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecificationTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecificationTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecificationTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], SpecificationTranslationGroupByOutputType[P]>
        }
      >
    >


  export type SpecificationTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    speed?: boolean
    paperSpecification?: boolean
    sizeRange?: boolean
    specificationId?: boolean
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificationTranslation"]>

  export type SpecificationTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    speed?: boolean
    paperSpecification?: boolean
    sizeRange?: boolean
    specificationId?: boolean
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificationTranslation"]>

  export type SpecificationTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    speed?: boolean
    paperSpecification?: boolean
    sizeRange?: boolean
    specificationId?: boolean
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificationTranslation"]>

  export type SpecificationTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    speed?: boolean
    paperSpecification?: boolean
    sizeRange?: boolean
    specificationId?: boolean
  }

  export type SpecificationTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "speed" | "paperSpecification" | "sizeRange" | "specificationId", ExtArgs["result"]["specificationTranslation"]>
  export type SpecificationTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }
  export type SpecificationTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }
  export type SpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specification?: boolean | SpecificationDefaultArgs<ExtArgs>
  }

  export type $SpecificationTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecificationTranslation"
    objects: {
      specification: Prisma.$SpecificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      speed: string | null
      paperSpecification: string | null
      sizeRange: string | null
      specificationId: number
    }, ExtArgs["result"]["specificationTranslation"]>
    composites: {}
  }

  type SpecificationTranslationGetPayload<S extends boolean | null | undefined | SpecificationTranslationDefaultArgs> = $Result.GetResult<Prisma.$SpecificationTranslationPayload, S>

  type SpecificationTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecificationTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecificationTranslationCountAggregateInputType | true
    }

  export interface SpecificationTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecificationTranslation'], meta: { name: 'SpecificationTranslation' } }
    /**
     * Find zero or one SpecificationTranslation that matches the filter.
     * @param {SpecificationTranslationFindUniqueArgs} args - Arguments to find a SpecificationTranslation
     * @example
     * // Get one SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecificationTranslationFindUniqueArgs>(args: SelectSubset<T, SpecificationTranslationFindUniqueArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecificationTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecificationTranslationFindUniqueOrThrowArgs} args - Arguments to find a SpecificationTranslation
     * @example
     * // Get one SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecificationTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecificationTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationFindFirstArgs} args - Arguments to find a SpecificationTranslation
     * @example
     * // Get one SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecificationTranslationFindFirstArgs>(args?: SelectSubset<T, SpecificationTranslationFindFirstArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecificationTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationFindFirstOrThrowArgs} args - Arguments to find a SpecificationTranslation
     * @example
     * // Get one SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecificationTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecificationTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecificationTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecificationTranslations
     * const specificationTranslations = await prisma.specificationTranslation.findMany()
     * 
     * // Get first 10 SpecificationTranslations
     * const specificationTranslations = await prisma.specificationTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specificationTranslationWithIdOnly = await prisma.specificationTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecificationTranslationFindManyArgs>(args?: SelectSubset<T, SpecificationTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecificationTranslation.
     * @param {SpecificationTranslationCreateArgs} args - Arguments to create a SpecificationTranslation.
     * @example
     * // Create one SpecificationTranslation
     * const SpecificationTranslation = await prisma.specificationTranslation.create({
     *   data: {
     *     // ... data to create a SpecificationTranslation
     *   }
     * })
     * 
     */
    create<T extends SpecificationTranslationCreateArgs>(args: SelectSubset<T, SpecificationTranslationCreateArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecificationTranslations.
     * @param {SpecificationTranslationCreateManyArgs} args - Arguments to create many SpecificationTranslations.
     * @example
     * // Create many SpecificationTranslations
     * const specificationTranslation = await prisma.specificationTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecificationTranslationCreateManyArgs>(args?: SelectSubset<T, SpecificationTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecificationTranslations and returns the data saved in the database.
     * @param {SpecificationTranslationCreateManyAndReturnArgs} args - Arguments to create many SpecificationTranslations.
     * @example
     * // Create many SpecificationTranslations
     * const specificationTranslation = await prisma.specificationTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecificationTranslations and only return the `id`
     * const specificationTranslationWithIdOnly = await prisma.specificationTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecificationTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecificationTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecificationTranslation.
     * @param {SpecificationTranslationDeleteArgs} args - Arguments to delete one SpecificationTranslation.
     * @example
     * // Delete one SpecificationTranslation
     * const SpecificationTranslation = await prisma.specificationTranslation.delete({
     *   where: {
     *     // ... filter to delete one SpecificationTranslation
     *   }
     * })
     * 
     */
    delete<T extends SpecificationTranslationDeleteArgs>(args: SelectSubset<T, SpecificationTranslationDeleteArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecificationTranslation.
     * @param {SpecificationTranslationUpdateArgs} args - Arguments to update one SpecificationTranslation.
     * @example
     * // Update one SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecificationTranslationUpdateArgs>(args: SelectSubset<T, SpecificationTranslationUpdateArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecificationTranslations.
     * @param {SpecificationTranslationDeleteManyArgs} args - Arguments to filter SpecificationTranslations to delete.
     * @example
     * // Delete a few SpecificationTranslations
     * const { count } = await prisma.specificationTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecificationTranslationDeleteManyArgs>(args?: SelectSubset<T, SpecificationTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecificationTranslations
     * const specificationTranslation = await prisma.specificationTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecificationTranslationUpdateManyArgs>(args: SelectSubset<T, SpecificationTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificationTranslations and returns the data updated in the database.
     * @param {SpecificationTranslationUpdateManyAndReturnArgs} args - Arguments to update many SpecificationTranslations.
     * @example
     * // Update many SpecificationTranslations
     * const specificationTranslation = await prisma.specificationTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecificationTranslations and only return the `id`
     * const specificationTranslationWithIdOnly = await prisma.specificationTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecificationTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecificationTranslation.
     * @param {SpecificationTranslationUpsertArgs} args - Arguments to update or create a SpecificationTranslation.
     * @example
     * // Update or create a SpecificationTranslation
     * const specificationTranslation = await prisma.specificationTranslation.upsert({
     *   create: {
     *     // ... data to create a SpecificationTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecificationTranslation we want to update
     *   }
     * })
     */
    upsert<T extends SpecificationTranslationUpsertArgs>(args: SelectSubset<T, SpecificationTranslationUpsertArgs<ExtArgs>>): Prisma__SpecificationTranslationClient<$Result.GetResult<Prisma.$SpecificationTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationCountArgs} args - Arguments to filter SpecificationTranslations to count.
     * @example
     * // Count the number of SpecificationTranslations
     * const count = await prisma.specificationTranslation.count({
     *   where: {
     *     // ... the filter for the SpecificationTranslations we want to count
     *   }
     * })
    **/
    count<T extends SpecificationTranslationCountArgs>(
      args?: Subset<T, SpecificationTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecificationTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecificationTranslationAggregateArgs>(args: Subset<T, SpecificationTranslationAggregateArgs>): Prisma.PrismaPromise<GetSpecificationTranslationAggregateType<T>>

    /**
     * Group by SpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificationTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecificationTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecificationTranslationGroupByArgs['orderBy'] }
        : { orderBy?: SpecificationTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecificationTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecificationTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecificationTranslation model
   */
  readonly fields: SpecificationTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecificationTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecificationTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specification<T extends SpecificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecificationDefaultArgs<ExtArgs>>): Prisma__SpecificationClient<$Result.GetResult<Prisma.$SpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecificationTranslation model
   */
  interface SpecificationTranslationFieldRefs {
    readonly id: FieldRef<"SpecificationTranslation", 'Int'>
    readonly language: FieldRef<"SpecificationTranslation", 'LanguageCode'>
    readonly speed: FieldRef<"SpecificationTranslation", 'String'>
    readonly paperSpecification: FieldRef<"SpecificationTranslation", 'String'>
    readonly sizeRange: FieldRef<"SpecificationTranslation", 'String'>
    readonly specificationId: FieldRef<"SpecificationTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpecificationTranslation findUnique
   */
  export type SpecificationTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SpecificationTranslation to fetch.
     */
    where: SpecificationTranslationWhereUniqueInput
  }

  /**
   * SpecificationTranslation findUniqueOrThrow
   */
  export type SpecificationTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SpecificationTranslation to fetch.
     */
    where: SpecificationTranslationWhereUniqueInput
  }

  /**
   * SpecificationTranslation findFirst
   */
  export type SpecificationTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SpecificationTranslation to fetch.
     */
    where?: SpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificationTranslations to fetch.
     */
    orderBy?: SpecificationTranslationOrderByWithRelationInput | SpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificationTranslations.
     */
    cursor?: SpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificationTranslations.
     */
    distinct?: SpecificationTranslationScalarFieldEnum | SpecificationTranslationScalarFieldEnum[]
  }

  /**
   * SpecificationTranslation findFirstOrThrow
   */
  export type SpecificationTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SpecificationTranslation to fetch.
     */
    where?: SpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificationTranslations to fetch.
     */
    orderBy?: SpecificationTranslationOrderByWithRelationInput | SpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificationTranslations.
     */
    cursor?: SpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificationTranslations.
     */
    distinct?: SpecificationTranslationScalarFieldEnum | SpecificationTranslationScalarFieldEnum[]
  }

  /**
   * SpecificationTranslation findMany
   */
  export type SpecificationTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which SpecificationTranslations to fetch.
     */
    where?: SpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificationTranslations to fetch.
     */
    orderBy?: SpecificationTranslationOrderByWithRelationInput | SpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecificationTranslations.
     */
    cursor?: SpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificationTranslations.
     */
    skip?: number
    distinct?: SpecificationTranslationScalarFieldEnum | SpecificationTranslationScalarFieldEnum[]
  }

  /**
   * SpecificationTranslation create
   */
  export type SpecificationTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecificationTranslation.
     */
    data: XOR<SpecificationTranslationCreateInput, SpecificationTranslationUncheckedCreateInput>
  }

  /**
   * SpecificationTranslation createMany
   */
  export type SpecificationTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecificationTranslations.
     */
    data: SpecificationTranslationCreateManyInput | SpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecificationTranslation createManyAndReturn
   */
  export type SpecificationTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many SpecificationTranslations.
     */
    data: SpecificationTranslationCreateManyInput | SpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecificationTranslation update
   */
  export type SpecificationTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecificationTranslation.
     */
    data: XOR<SpecificationTranslationUpdateInput, SpecificationTranslationUncheckedUpdateInput>
    /**
     * Choose, which SpecificationTranslation to update.
     */
    where: SpecificationTranslationWhereUniqueInput
  }

  /**
   * SpecificationTranslation updateMany
   */
  export type SpecificationTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecificationTranslations.
     */
    data: XOR<SpecificationTranslationUpdateManyMutationInput, SpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which SpecificationTranslations to update
     */
    where?: SpecificationTranslationWhereInput
    /**
     * Limit how many SpecificationTranslations to update.
     */
    limit?: number
  }

  /**
   * SpecificationTranslation updateManyAndReturn
   */
  export type SpecificationTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to update SpecificationTranslations.
     */
    data: XOR<SpecificationTranslationUpdateManyMutationInput, SpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which SpecificationTranslations to update
     */
    where?: SpecificationTranslationWhereInput
    /**
     * Limit how many SpecificationTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecificationTranslation upsert
   */
  export type SpecificationTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecificationTranslation to update in case it exists.
     */
    where: SpecificationTranslationWhereUniqueInput
    /**
     * In case the SpecificationTranslation found by the `where` argument doesn't exist, create a new SpecificationTranslation with this data.
     */
    create: XOR<SpecificationTranslationCreateInput, SpecificationTranslationUncheckedCreateInput>
    /**
     * In case the SpecificationTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecificationTranslationUpdateInput, SpecificationTranslationUncheckedUpdateInput>
  }

  /**
   * SpecificationTranslation delete
   */
  export type SpecificationTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter which SpecificationTranslation to delete.
     */
    where: SpecificationTranslationWhereUniqueInput
  }

  /**
   * SpecificationTranslation deleteMany
   */
  export type SpecificationTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificationTranslations to delete
     */
    where?: SpecificationTranslationWhereInput
    /**
     * Limit how many SpecificationTranslations to delete.
     */
    limit?: number
  }

  /**
   * SpecificationTranslation without action
   */
  export type SpecificationTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificationTranslation
     */
    select?: SpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecificationTranslation
     */
    omit?: SpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecificationTranslationInclude<ExtArgs> | null
  }


  /**
   * Model ApplicationData
   */

  export type AggregateApplicationData = {
    _count: ApplicationDataCountAggregateOutputType | null
    _avg: ApplicationDataAvgAggregateOutputType | null
    _sum: ApplicationDataSumAggregateOutputType | null
    _min: ApplicationDataMinAggregateOutputType | null
    _max: ApplicationDataMaxAggregateOutputType | null
  }

  export type ApplicationDataAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ApplicationDataSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ApplicationDataMinAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    src: string | null
    src_alt_en: string | null
  }

  export type ApplicationDataMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    src: string | null
    src_alt_en: string | null
  }

  export type ApplicationDataCountAggregateOutputType = {
    id: number
    productId: number
    title_en: number
    src: number
    src_alt_en: number
    _all: number
  }


  export type ApplicationDataAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ApplicationDataSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ApplicationDataMinAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    src?: true
    src_alt_en?: true
  }

  export type ApplicationDataMaxAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    src?: true
    src_alt_en?: true
  }

  export type ApplicationDataCountAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    src?: true
    src_alt_en?: true
    _all?: true
  }

  export type ApplicationDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationData to aggregate.
     */
    where?: ApplicationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationData to fetch.
     */
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicationData
    **/
    _count?: true | ApplicationDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationDataMaxAggregateInputType
  }

  export type GetApplicationDataAggregateType<T extends ApplicationDataAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationData[P]>
      : GetScalarType<T[P], AggregateApplicationData[P]>
  }




  export type ApplicationDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDataWhereInput
    orderBy?: ApplicationDataOrderByWithAggregationInput | ApplicationDataOrderByWithAggregationInput[]
    by: ApplicationDataScalarFieldEnum[] | ApplicationDataScalarFieldEnum
    having?: ApplicationDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationDataCountAggregateInputType | true
    _avg?: ApplicationDataAvgAggregateInputType
    _sum?: ApplicationDataSumAggregateInputType
    _min?: ApplicationDataMinAggregateInputType
    _max?: ApplicationDataMaxAggregateInputType
  }

  export type ApplicationDataGroupByOutputType = {
    id: number
    productId: number
    title_en: string
    src: string | null
    src_alt_en: string | null
    _count: ApplicationDataCountAggregateOutputType | null
    _avg: ApplicationDataAvgAggregateOutputType | null
    _sum: ApplicationDataSumAggregateOutputType | null
    _min: ApplicationDataMinAggregateOutputType | null
    _max: ApplicationDataMaxAggregateOutputType | null
  }

  type GetApplicationDataGroupByPayload<T extends ApplicationDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationDataGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationDataGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    src?: boolean
    src_alt_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | ApplicationData$translationsArgs<ExtArgs>
    productTranslations?: boolean | ApplicationData$productTranslationsArgs<ExtArgs>
    _count?: boolean | ApplicationDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationData"]>

  export type ApplicationDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    src?: boolean
    src_alt_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationData"]>

  export type ApplicationDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    src?: boolean
    src_alt_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationData"]>

  export type ApplicationDataSelectScalar = {
    id?: boolean
    productId?: boolean
    title_en?: boolean
    src?: boolean
    src_alt_en?: boolean
  }

  export type ApplicationDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "title_en" | "src" | "src_alt_en", ExtArgs["result"]["applicationData"]>
  export type ApplicationDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | ApplicationData$translationsArgs<ExtArgs>
    productTranslations?: boolean | ApplicationData$productTranslationsArgs<ExtArgs>
    _count?: boolean | ApplicationDataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ApplicationDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ApplicationDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicationData"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      translations: Prisma.$ApplicationDataTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      title_en: string
      src: string | null
      src_alt_en: string | null
    }, ExtArgs["result"]["applicationData"]>
    composites: {}
  }

  type ApplicationDataGetPayload<S extends boolean | null | undefined | ApplicationDataDefaultArgs> = $Result.GetResult<Prisma.$ApplicationDataPayload, S>

  type ApplicationDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationDataCountAggregateInputType | true
    }

  export interface ApplicationDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicationData'], meta: { name: 'ApplicationData' } }
    /**
     * Find zero or one ApplicationData that matches the filter.
     * @param {ApplicationDataFindUniqueArgs} args - Arguments to find a ApplicationData
     * @example
     * // Get one ApplicationData
     * const applicationData = await prisma.applicationData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationDataFindUniqueArgs>(args: SelectSubset<T, ApplicationDataFindUniqueArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApplicationData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationDataFindUniqueOrThrowArgs} args - Arguments to find a ApplicationData
     * @example
     * // Get one ApplicationData
     * const applicationData = await prisma.applicationData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataFindFirstArgs} args - Arguments to find a ApplicationData
     * @example
     * // Get one ApplicationData
     * const applicationData = await prisma.applicationData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationDataFindFirstArgs>(args?: SelectSubset<T, ApplicationDataFindFirstArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataFindFirstOrThrowArgs} args - Arguments to find a ApplicationData
     * @example
     * // Get one ApplicationData
     * const applicationData = await prisma.applicationData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApplicationData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicationData
     * const applicationData = await prisma.applicationData.findMany()
     * 
     * // Get first 10 ApplicationData
     * const applicationData = await prisma.applicationData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationDataWithIdOnly = await prisma.applicationData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationDataFindManyArgs>(args?: SelectSubset<T, ApplicationDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApplicationData.
     * @param {ApplicationDataCreateArgs} args - Arguments to create a ApplicationData.
     * @example
     * // Create one ApplicationData
     * const ApplicationData = await prisma.applicationData.create({
     *   data: {
     *     // ... data to create a ApplicationData
     *   }
     * })
     * 
     */
    create<T extends ApplicationDataCreateArgs>(args: SelectSubset<T, ApplicationDataCreateArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApplicationData.
     * @param {ApplicationDataCreateManyArgs} args - Arguments to create many ApplicationData.
     * @example
     * // Create many ApplicationData
     * const applicationData = await prisma.applicationData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationDataCreateManyArgs>(args?: SelectSubset<T, ApplicationDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicationData and returns the data saved in the database.
     * @param {ApplicationDataCreateManyAndReturnArgs} args - Arguments to create many ApplicationData.
     * @example
     * // Create many ApplicationData
     * const applicationData = await prisma.applicationData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicationData and only return the `id`
     * const applicationDataWithIdOnly = await prisma.applicationData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApplicationData.
     * @param {ApplicationDataDeleteArgs} args - Arguments to delete one ApplicationData.
     * @example
     * // Delete one ApplicationData
     * const ApplicationData = await prisma.applicationData.delete({
     *   where: {
     *     // ... filter to delete one ApplicationData
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDataDeleteArgs>(args: SelectSubset<T, ApplicationDataDeleteArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApplicationData.
     * @param {ApplicationDataUpdateArgs} args - Arguments to update one ApplicationData.
     * @example
     * // Update one ApplicationData
     * const applicationData = await prisma.applicationData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationDataUpdateArgs>(args: SelectSubset<T, ApplicationDataUpdateArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApplicationData.
     * @param {ApplicationDataDeleteManyArgs} args - Arguments to filter ApplicationData to delete.
     * @example
     * // Delete a few ApplicationData
     * const { count } = await prisma.applicationData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDataDeleteManyArgs>(args?: SelectSubset<T, ApplicationDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicationData
     * const applicationData = await prisma.applicationData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationDataUpdateManyArgs>(args: SelectSubset<T, ApplicationDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationData and returns the data updated in the database.
     * @param {ApplicationDataUpdateManyAndReturnArgs} args - Arguments to update many ApplicationData.
     * @example
     * // Update many ApplicationData
     * const applicationData = await prisma.applicationData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApplicationData and only return the `id`
     * const applicationDataWithIdOnly = await prisma.applicationData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApplicationData.
     * @param {ApplicationDataUpsertArgs} args - Arguments to update or create a ApplicationData.
     * @example
     * // Update or create a ApplicationData
     * const applicationData = await prisma.applicationData.upsert({
     *   create: {
     *     // ... data to create a ApplicationData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicationData we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationDataUpsertArgs>(args: SelectSubset<T, ApplicationDataUpsertArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApplicationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataCountArgs} args - Arguments to filter ApplicationData to count.
     * @example
     * // Count the number of ApplicationData
     * const count = await prisma.applicationData.count({
     *   where: {
     *     // ... the filter for the ApplicationData we want to count
     *   }
     * })
    **/
    count<T extends ApplicationDataCountArgs>(
      args?: Subset<T, ApplicationDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationDataAggregateArgs>(args: Subset<T, ApplicationDataAggregateArgs>): Prisma.PrismaPromise<GetApplicationDataAggregateType<T>>

    /**
     * Group by ApplicationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationDataGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicationData model
   */
  readonly fields: ApplicationDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicationData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    translations<T extends ApplicationData$translationsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationData$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends ApplicationData$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationData$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicationData model
   */
  interface ApplicationDataFieldRefs {
    readonly id: FieldRef<"ApplicationData", 'Int'>
    readonly productId: FieldRef<"ApplicationData", 'Int'>
    readonly title_en: FieldRef<"ApplicationData", 'String'>
    readonly src: FieldRef<"ApplicationData", 'String'>
    readonly src_alt_en: FieldRef<"ApplicationData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApplicationData findUnique
   */
  export type ApplicationDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationData to fetch.
     */
    where: ApplicationDataWhereUniqueInput
  }

  /**
   * ApplicationData findUniqueOrThrow
   */
  export type ApplicationDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationData to fetch.
     */
    where: ApplicationDataWhereUniqueInput
  }

  /**
   * ApplicationData findFirst
   */
  export type ApplicationDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationData to fetch.
     */
    where?: ApplicationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationData to fetch.
     */
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationData.
     */
    cursor?: ApplicationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationData.
     */
    distinct?: ApplicationDataScalarFieldEnum | ApplicationDataScalarFieldEnum[]
  }

  /**
   * ApplicationData findFirstOrThrow
   */
  export type ApplicationDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationData to fetch.
     */
    where?: ApplicationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationData to fetch.
     */
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationData.
     */
    cursor?: ApplicationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationData.
     */
    distinct?: ApplicationDataScalarFieldEnum | ApplicationDataScalarFieldEnum[]
  }

  /**
   * ApplicationData findMany
   */
  export type ApplicationDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationData to fetch.
     */
    where?: ApplicationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationData to fetch.
     */
    orderBy?: ApplicationDataOrderByWithRelationInput | ApplicationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicationData.
     */
    cursor?: ApplicationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationData.
     */
    skip?: number
    distinct?: ApplicationDataScalarFieldEnum | ApplicationDataScalarFieldEnum[]
  }

  /**
   * ApplicationData create
   */
  export type ApplicationDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicationData.
     */
    data: XOR<ApplicationDataCreateInput, ApplicationDataUncheckedCreateInput>
  }

  /**
   * ApplicationData createMany
   */
  export type ApplicationDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicationData.
     */
    data: ApplicationDataCreateManyInput | ApplicationDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationData createManyAndReturn
   */
  export type ApplicationDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * The data used to create many ApplicationData.
     */
    data: ApplicationDataCreateManyInput | ApplicationDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationData update
   */
  export type ApplicationDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicationData.
     */
    data: XOR<ApplicationDataUpdateInput, ApplicationDataUncheckedUpdateInput>
    /**
     * Choose, which ApplicationData to update.
     */
    where: ApplicationDataWhereUniqueInput
  }

  /**
   * ApplicationData updateMany
   */
  export type ApplicationDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicationData.
     */
    data: XOR<ApplicationDataUpdateManyMutationInput, ApplicationDataUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationData to update
     */
    where?: ApplicationDataWhereInput
    /**
     * Limit how many ApplicationData to update.
     */
    limit?: number
  }

  /**
   * ApplicationData updateManyAndReturn
   */
  export type ApplicationDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * The data used to update ApplicationData.
     */
    data: XOR<ApplicationDataUpdateManyMutationInput, ApplicationDataUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationData to update
     */
    where?: ApplicationDataWhereInput
    /**
     * Limit how many ApplicationData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationData upsert
   */
  export type ApplicationDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicationData to update in case it exists.
     */
    where: ApplicationDataWhereUniqueInput
    /**
     * In case the ApplicationData found by the `where` argument doesn't exist, create a new ApplicationData with this data.
     */
    create: XOR<ApplicationDataCreateInput, ApplicationDataUncheckedCreateInput>
    /**
     * In case the ApplicationData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationDataUpdateInput, ApplicationDataUncheckedUpdateInput>
  }

  /**
   * ApplicationData delete
   */
  export type ApplicationDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
    /**
     * Filter which ApplicationData to delete.
     */
    where: ApplicationDataWhereUniqueInput
  }

  /**
   * ApplicationData deleteMany
   */
  export type ApplicationDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationData to delete
     */
    where?: ApplicationDataWhereInput
    /**
     * Limit how many ApplicationData to delete.
     */
    limit?: number
  }

  /**
   * ApplicationData.translations
   */
  export type ApplicationData$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    where?: ApplicationDataTranslationWhereInput
    orderBy?: ApplicationDataTranslationOrderByWithRelationInput | ApplicationDataTranslationOrderByWithRelationInput[]
    cursor?: ApplicationDataTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationDataTranslationScalarFieldEnum | ApplicationDataTranslationScalarFieldEnum[]
  }

  /**
   * ApplicationData.productTranslations
   */
  export type ApplicationData$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ApplicationData without action
   */
  export type ApplicationDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationData
     */
    select?: ApplicationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationData
     */
    omit?: ApplicationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataInclude<ExtArgs> | null
  }


  /**
   * Model ApplicationDataTranslation
   */

  export type AggregateApplicationDataTranslation = {
    _count: ApplicationDataTranslationCountAggregateOutputType | null
    _avg: ApplicationDataTranslationAvgAggregateOutputType | null
    _sum: ApplicationDataTranslationSumAggregateOutputType | null
    _min: ApplicationDataTranslationMinAggregateOutputType | null
    _max: ApplicationDataTranslationMaxAggregateOutputType | null
  }

  export type ApplicationDataTranslationAvgAggregateOutputType = {
    id: number | null
    applicationDataId: number | null
  }

  export type ApplicationDataTranslationSumAggregateOutputType = {
    id: number | null
    applicationDataId: number | null
  }

  export type ApplicationDataTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    src_alt: string | null
    applicationDataId: number | null
  }

  export type ApplicationDataTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    src_alt: string | null
    applicationDataId: number | null
  }

  export type ApplicationDataTranslationCountAggregateOutputType = {
    id: number
    language: number
    title: number
    src_alt: number
    applicationDataId: number
    _all: number
  }


  export type ApplicationDataTranslationAvgAggregateInputType = {
    id?: true
    applicationDataId?: true
  }

  export type ApplicationDataTranslationSumAggregateInputType = {
    id?: true
    applicationDataId?: true
  }

  export type ApplicationDataTranslationMinAggregateInputType = {
    id?: true
    language?: true
    title?: true
    src_alt?: true
    applicationDataId?: true
  }

  export type ApplicationDataTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    title?: true
    src_alt?: true
    applicationDataId?: true
  }

  export type ApplicationDataTranslationCountAggregateInputType = {
    id?: true
    language?: true
    title?: true
    src_alt?: true
    applicationDataId?: true
    _all?: true
  }

  export type ApplicationDataTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDataTranslation to aggregate.
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDataTranslations to fetch.
     */
    orderBy?: ApplicationDataTranslationOrderByWithRelationInput | ApplicationDataTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationDataTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDataTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDataTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicationDataTranslations
    **/
    _count?: true | ApplicationDataTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationDataTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationDataTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationDataTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationDataTranslationMaxAggregateInputType
  }

  export type GetApplicationDataTranslationAggregateType<T extends ApplicationDataTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationDataTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationDataTranslation[P]>
      : GetScalarType<T[P], AggregateApplicationDataTranslation[P]>
  }




  export type ApplicationDataTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDataTranslationWhereInput
    orderBy?: ApplicationDataTranslationOrderByWithAggregationInput | ApplicationDataTranslationOrderByWithAggregationInput[]
    by: ApplicationDataTranslationScalarFieldEnum[] | ApplicationDataTranslationScalarFieldEnum
    having?: ApplicationDataTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationDataTranslationCountAggregateInputType | true
    _avg?: ApplicationDataTranslationAvgAggregateInputType
    _sum?: ApplicationDataTranslationSumAggregateInputType
    _min?: ApplicationDataTranslationMinAggregateInputType
    _max?: ApplicationDataTranslationMaxAggregateInputType
  }

  export type ApplicationDataTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    title: string
    src_alt: string | null
    applicationDataId: number
    _count: ApplicationDataTranslationCountAggregateOutputType | null
    _avg: ApplicationDataTranslationAvgAggregateOutputType | null
    _sum: ApplicationDataTranslationSumAggregateOutputType | null
    _min: ApplicationDataTranslationMinAggregateOutputType | null
    _max: ApplicationDataTranslationMaxAggregateOutputType | null
  }

  type GetApplicationDataTranslationGroupByPayload<T extends ApplicationDataTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationDataTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationDataTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationDataTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationDataTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationDataTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    src_alt?: boolean
    applicationDataId?: boolean
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDataTranslation"]>

  export type ApplicationDataTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    src_alt?: boolean
    applicationDataId?: boolean
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDataTranslation"]>

  export type ApplicationDataTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    src_alt?: boolean
    applicationDataId?: boolean
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDataTranslation"]>

  export type ApplicationDataTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    title?: boolean
    src_alt?: boolean
    applicationDataId?: boolean
  }

  export type ApplicationDataTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "title" | "src_alt" | "applicationDataId", ExtArgs["result"]["applicationDataTranslation"]>
  export type ApplicationDataTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }
  export type ApplicationDataTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }
  export type ApplicationDataTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicationData?: boolean | ApplicationDataDefaultArgs<ExtArgs>
  }

  export type $ApplicationDataTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicationDataTranslation"
    objects: {
      applicationData: Prisma.$ApplicationDataPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      title: string
      src_alt: string | null
      applicationDataId: number
    }, ExtArgs["result"]["applicationDataTranslation"]>
    composites: {}
  }

  type ApplicationDataTranslationGetPayload<S extends boolean | null | undefined | ApplicationDataTranslationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationDataTranslationPayload, S>

  type ApplicationDataTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationDataTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationDataTranslationCountAggregateInputType | true
    }

  export interface ApplicationDataTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicationDataTranslation'], meta: { name: 'ApplicationDataTranslation' } }
    /**
     * Find zero or one ApplicationDataTranslation that matches the filter.
     * @param {ApplicationDataTranslationFindUniqueArgs} args - Arguments to find a ApplicationDataTranslation
     * @example
     * // Get one ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationDataTranslationFindUniqueArgs>(args: SelectSubset<T, ApplicationDataTranslationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApplicationDataTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationDataTranslationFindUniqueOrThrowArgs} args - Arguments to find a ApplicationDataTranslation
     * @example
     * // Get one ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationDataTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationDataTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDataTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationFindFirstArgs} args - Arguments to find a ApplicationDataTranslation
     * @example
     * // Get one ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationDataTranslationFindFirstArgs>(args?: SelectSubset<T, ApplicationDataTranslationFindFirstArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDataTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationFindFirstOrThrowArgs} args - Arguments to find a ApplicationDataTranslation
     * @example
     * // Get one ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationDataTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationDataTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApplicationDataTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicationDataTranslations
     * const applicationDataTranslations = await prisma.applicationDataTranslation.findMany()
     * 
     * // Get first 10 ApplicationDataTranslations
     * const applicationDataTranslations = await prisma.applicationDataTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationDataTranslationWithIdOnly = await prisma.applicationDataTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationDataTranslationFindManyArgs>(args?: SelectSubset<T, ApplicationDataTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApplicationDataTranslation.
     * @param {ApplicationDataTranslationCreateArgs} args - Arguments to create a ApplicationDataTranslation.
     * @example
     * // Create one ApplicationDataTranslation
     * const ApplicationDataTranslation = await prisma.applicationDataTranslation.create({
     *   data: {
     *     // ... data to create a ApplicationDataTranslation
     *   }
     * })
     * 
     */
    create<T extends ApplicationDataTranslationCreateArgs>(args: SelectSubset<T, ApplicationDataTranslationCreateArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApplicationDataTranslations.
     * @param {ApplicationDataTranslationCreateManyArgs} args - Arguments to create many ApplicationDataTranslations.
     * @example
     * // Create many ApplicationDataTranslations
     * const applicationDataTranslation = await prisma.applicationDataTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationDataTranslationCreateManyArgs>(args?: SelectSubset<T, ApplicationDataTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicationDataTranslations and returns the data saved in the database.
     * @param {ApplicationDataTranslationCreateManyAndReturnArgs} args - Arguments to create many ApplicationDataTranslations.
     * @example
     * // Create many ApplicationDataTranslations
     * const applicationDataTranslation = await prisma.applicationDataTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicationDataTranslations and only return the `id`
     * const applicationDataTranslationWithIdOnly = await prisma.applicationDataTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationDataTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationDataTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApplicationDataTranslation.
     * @param {ApplicationDataTranslationDeleteArgs} args - Arguments to delete one ApplicationDataTranslation.
     * @example
     * // Delete one ApplicationDataTranslation
     * const ApplicationDataTranslation = await prisma.applicationDataTranslation.delete({
     *   where: {
     *     // ... filter to delete one ApplicationDataTranslation
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDataTranslationDeleteArgs>(args: SelectSubset<T, ApplicationDataTranslationDeleteArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApplicationDataTranslation.
     * @param {ApplicationDataTranslationUpdateArgs} args - Arguments to update one ApplicationDataTranslation.
     * @example
     * // Update one ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationDataTranslationUpdateArgs>(args: SelectSubset<T, ApplicationDataTranslationUpdateArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApplicationDataTranslations.
     * @param {ApplicationDataTranslationDeleteManyArgs} args - Arguments to filter ApplicationDataTranslations to delete.
     * @example
     * // Delete a few ApplicationDataTranslations
     * const { count } = await prisma.applicationDataTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDataTranslationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDataTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDataTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicationDataTranslations
     * const applicationDataTranslation = await prisma.applicationDataTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationDataTranslationUpdateManyArgs>(args: SelectSubset<T, ApplicationDataTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDataTranslations and returns the data updated in the database.
     * @param {ApplicationDataTranslationUpdateManyAndReturnArgs} args - Arguments to update many ApplicationDataTranslations.
     * @example
     * // Update many ApplicationDataTranslations
     * const applicationDataTranslation = await prisma.applicationDataTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApplicationDataTranslations and only return the `id`
     * const applicationDataTranslationWithIdOnly = await prisma.applicationDataTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationDataTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationDataTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApplicationDataTranslation.
     * @param {ApplicationDataTranslationUpsertArgs} args - Arguments to update or create a ApplicationDataTranslation.
     * @example
     * // Update or create a ApplicationDataTranslation
     * const applicationDataTranslation = await prisma.applicationDataTranslation.upsert({
     *   create: {
     *     // ... data to create a ApplicationDataTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicationDataTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationDataTranslationUpsertArgs>(args: SelectSubset<T, ApplicationDataTranslationUpsertArgs<ExtArgs>>): Prisma__ApplicationDataTranslationClient<$Result.GetResult<Prisma.$ApplicationDataTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApplicationDataTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationCountArgs} args - Arguments to filter ApplicationDataTranslations to count.
     * @example
     * // Count the number of ApplicationDataTranslations
     * const count = await prisma.applicationDataTranslation.count({
     *   where: {
     *     // ... the filter for the ApplicationDataTranslations we want to count
     *   }
     * })
    **/
    count<T extends ApplicationDataTranslationCountArgs>(
      args?: Subset<T, ApplicationDataTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationDataTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicationDataTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationDataTranslationAggregateArgs>(args: Subset<T, ApplicationDataTranslationAggregateArgs>): Prisma.PrismaPromise<GetApplicationDataTranslationAggregateType<T>>

    /**
     * Group by ApplicationDataTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDataTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationDataTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationDataTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationDataTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationDataTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationDataTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicationDataTranslation model
   */
  readonly fields: ApplicationDataTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicationDataTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationDataTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicationData<T extends ApplicationDataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDataDefaultArgs<ExtArgs>>): Prisma__ApplicationDataClient<$Result.GetResult<Prisma.$ApplicationDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicationDataTranslation model
   */
  interface ApplicationDataTranslationFieldRefs {
    readonly id: FieldRef<"ApplicationDataTranslation", 'Int'>
    readonly language: FieldRef<"ApplicationDataTranslation", 'LanguageCode'>
    readonly title: FieldRef<"ApplicationDataTranslation", 'String'>
    readonly src_alt: FieldRef<"ApplicationDataTranslation", 'String'>
    readonly applicationDataId: FieldRef<"ApplicationDataTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ApplicationDataTranslation findUnique
   */
  export type ApplicationDataTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDataTranslation to fetch.
     */
    where: ApplicationDataTranslationWhereUniqueInput
  }

  /**
   * ApplicationDataTranslation findUniqueOrThrow
   */
  export type ApplicationDataTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDataTranslation to fetch.
     */
    where: ApplicationDataTranslationWhereUniqueInput
  }

  /**
   * ApplicationDataTranslation findFirst
   */
  export type ApplicationDataTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDataTranslation to fetch.
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDataTranslations to fetch.
     */
    orderBy?: ApplicationDataTranslationOrderByWithRelationInput | ApplicationDataTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDataTranslations.
     */
    cursor?: ApplicationDataTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDataTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDataTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDataTranslations.
     */
    distinct?: ApplicationDataTranslationScalarFieldEnum | ApplicationDataTranslationScalarFieldEnum[]
  }

  /**
   * ApplicationDataTranslation findFirstOrThrow
   */
  export type ApplicationDataTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDataTranslation to fetch.
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDataTranslations to fetch.
     */
    orderBy?: ApplicationDataTranslationOrderByWithRelationInput | ApplicationDataTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDataTranslations.
     */
    cursor?: ApplicationDataTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDataTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDataTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDataTranslations.
     */
    distinct?: ApplicationDataTranslationScalarFieldEnum | ApplicationDataTranslationScalarFieldEnum[]
  }

  /**
   * ApplicationDataTranslation findMany
   */
  export type ApplicationDataTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDataTranslations to fetch.
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDataTranslations to fetch.
     */
    orderBy?: ApplicationDataTranslationOrderByWithRelationInput | ApplicationDataTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicationDataTranslations.
     */
    cursor?: ApplicationDataTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDataTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDataTranslations.
     */
    skip?: number
    distinct?: ApplicationDataTranslationScalarFieldEnum | ApplicationDataTranslationScalarFieldEnum[]
  }

  /**
   * ApplicationDataTranslation create
   */
  export type ApplicationDataTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicationDataTranslation.
     */
    data: XOR<ApplicationDataTranslationCreateInput, ApplicationDataTranslationUncheckedCreateInput>
  }

  /**
   * ApplicationDataTranslation createMany
   */
  export type ApplicationDataTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicationDataTranslations.
     */
    data: ApplicationDataTranslationCreateManyInput | ApplicationDataTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationDataTranslation createManyAndReturn
   */
  export type ApplicationDataTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ApplicationDataTranslations.
     */
    data: ApplicationDataTranslationCreateManyInput | ApplicationDataTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDataTranslation update
   */
  export type ApplicationDataTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicationDataTranslation.
     */
    data: XOR<ApplicationDataTranslationUpdateInput, ApplicationDataTranslationUncheckedUpdateInput>
    /**
     * Choose, which ApplicationDataTranslation to update.
     */
    where: ApplicationDataTranslationWhereUniqueInput
  }

  /**
   * ApplicationDataTranslation updateMany
   */
  export type ApplicationDataTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicationDataTranslations.
     */
    data: XOR<ApplicationDataTranslationUpdateManyMutationInput, ApplicationDataTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDataTranslations to update
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * Limit how many ApplicationDataTranslations to update.
     */
    limit?: number
  }

  /**
   * ApplicationDataTranslation updateManyAndReturn
   */
  export type ApplicationDataTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ApplicationDataTranslations.
     */
    data: XOR<ApplicationDataTranslationUpdateManyMutationInput, ApplicationDataTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDataTranslations to update
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * Limit how many ApplicationDataTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDataTranslation upsert
   */
  export type ApplicationDataTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicationDataTranslation to update in case it exists.
     */
    where: ApplicationDataTranslationWhereUniqueInput
    /**
     * In case the ApplicationDataTranslation found by the `where` argument doesn't exist, create a new ApplicationDataTranslation with this data.
     */
    create: XOR<ApplicationDataTranslationCreateInput, ApplicationDataTranslationUncheckedCreateInput>
    /**
     * In case the ApplicationDataTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationDataTranslationUpdateInput, ApplicationDataTranslationUncheckedUpdateInput>
  }

  /**
   * ApplicationDataTranslation delete
   */
  export type ApplicationDataTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
    /**
     * Filter which ApplicationDataTranslation to delete.
     */
    where: ApplicationDataTranslationWhereUniqueInput
  }

  /**
   * ApplicationDataTranslation deleteMany
   */
  export type ApplicationDataTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDataTranslations to delete
     */
    where?: ApplicationDataTranslationWhereInput
    /**
     * Limit how many ApplicationDataTranslations to delete.
     */
    limit?: number
  }

  /**
   * ApplicationDataTranslation without action
   */
  export type ApplicationDataTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDataTranslation
     */
    select?: ApplicationDataTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDataTranslation
     */
    omit?: ApplicationDataTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDataTranslationInclude<ExtArgs> | null
  }


  /**
   * Model TechnicalSpecification
   */

  export type AggregateTechnicalSpecification = {
    _count: TechnicalSpecificationCountAggregateOutputType | null
    _avg: TechnicalSpecificationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationSumAggregateOutputType | null
    _min: TechnicalSpecificationMinAggregateOutputType | null
    _max: TechnicalSpecificationMaxAggregateOutputType | null
  }

  export type TechnicalSpecificationAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type TechnicalSpecificationSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type TechnicalSpecificationMinAggregateOutputType = {
    id: number | null
    productId: number | null
    feature_en: string | null
    spec_en: string | null
  }

  export type TechnicalSpecificationMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    feature_en: string | null
    spec_en: string | null
  }

  export type TechnicalSpecificationCountAggregateOutputType = {
    id: number
    productId: number
    feature_en: number
    spec_en: number
    _all: number
  }


  export type TechnicalSpecificationAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type TechnicalSpecificationSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type TechnicalSpecificationMinAggregateInputType = {
    id?: true
    productId?: true
    feature_en?: true
    spec_en?: true
  }

  export type TechnicalSpecificationMaxAggregateInputType = {
    id?: true
    productId?: true
    feature_en?: true
    spec_en?: true
  }

  export type TechnicalSpecificationCountAggregateInputType = {
    id?: true
    productId?: true
    feature_en?: true
    spec_en?: true
    _all?: true
  }

  export type TechnicalSpecificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecification to aggregate.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicalSpecifications
    **/
    _count?: true | TechnicalSpecificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicalSpecificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicalSpecificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicalSpecificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicalSpecificationMaxAggregateInputType
  }

  export type GetTechnicalSpecificationAggregateType<T extends TechnicalSpecificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicalSpecification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicalSpecification[P]>
      : GetScalarType<T[P], AggregateTechnicalSpecification[P]>
  }




  export type TechnicalSpecificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationWhereInput
    orderBy?: TechnicalSpecificationOrderByWithAggregationInput | TechnicalSpecificationOrderByWithAggregationInput[]
    by: TechnicalSpecificationScalarFieldEnum[] | TechnicalSpecificationScalarFieldEnum
    having?: TechnicalSpecificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicalSpecificationCountAggregateInputType | true
    _avg?: TechnicalSpecificationAvgAggregateInputType
    _sum?: TechnicalSpecificationSumAggregateInputType
    _min?: TechnicalSpecificationMinAggregateInputType
    _max?: TechnicalSpecificationMaxAggregateInputType
  }

  export type TechnicalSpecificationGroupByOutputType = {
    id: number
    productId: number
    feature_en: string
    spec_en: string
    _count: TechnicalSpecificationCountAggregateOutputType | null
    _avg: TechnicalSpecificationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationSumAggregateOutputType | null
    _min: TechnicalSpecificationMinAggregateOutputType | null
    _max: TechnicalSpecificationMaxAggregateOutputType | null
  }

  type GetTechnicalSpecificationGroupByPayload<T extends TechnicalSpecificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicalSpecificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicalSpecificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicalSpecificationGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicalSpecificationGroupByOutputType[P]>
        }
      >
    >


  export type TechnicalSpecificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    feature_en?: boolean
    spec_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | TechnicalSpecification$translationsArgs<ExtArgs>
    productTranslations?: boolean | TechnicalSpecification$productTranslationsArgs<ExtArgs>
    _count?: boolean | TechnicalSpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    feature_en?: boolean
    spec_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    feature_en?: boolean
    spec_en?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecification"]>

  export type TechnicalSpecificationSelectScalar = {
    id?: boolean
    productId?: boolean
    feature_en?: boolean
    spec_en?: boolean
  }

  export type TechnicalSpecificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "feature_en" | "spec_en", ExtArgs["result"]["technicalSpecification"]>
  export type TechnicalSpecificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | TechnicalSpecification$translationsArgs<ExtArgs>
    productTranslations?: boolean | TechnicalSpecification$productTranslationsArgs<ExtArgs>
    _count?: boolean | TechnicalSpecificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TechnicalSpecificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicalSpecification"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      translations: Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      feature_en: string
      spec_en: string
    }, ExtArgs["result"]["technicalSpecification"]>
    composites: {}
  }

  type TechnicalSpecificationGetPayload<S extends boolean | null | undefined | TechnicalSpecificationDefaultArgs> = $Result.GetResult<Prisma.$TechnicalSpecificationPayload, S>

  type TechnicalSpecificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicalSpecificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicalSpecificationCountAggregateInputType | true
    }

  export interface TechnicalSpecificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicalSpecification'], meta: { name: 'TechnicalSpecification' } }
    /**
     * Find zero or one TechnicalSpecification that matches the filter.
     * @param {TechnicalSpecificationFindUniqueArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicalSpecificationFindUniqueArgs>(args: SelectSubset<T, TechnicalSpecificationFindUniqueArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicalSpecification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicalSpecificationFindUniqueOrThrowArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicalSpecificationFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindFirstArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicalSpecificationFindFirstArgs>(args?: SelectSubset<T, TechnicalSpecificationFindFirstArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindFirstOrThrowArgs} args - Arguments to find a TechnicalSpecification
     * @example
     * // Get one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicalSpecificationFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicalSpecifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicalSpecifications
     * const technicalSpecifications = await prisma.technicalSpecification.findMany()
     * 
     * // Get first 10 TechnicalSpecifications
     * const technicalSpecifications = await prisma.technicalSpecification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicalSpecificationFindManyArgs>(args?: SelectSubset<T, TechnicalSpecificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicalSpecification.
     * @param {TechnicalSpecificationCreateArgs} args - Arguments to create a TechnicalSpecification.
     * @example
     * // Create one TechnicalSpecification
     * const TechnicalSpecification = await prisma.technicalSpecification.create({
     *   data: {
     *     // ... data to create a TechnicalSpecification
     *   }
     * })
     * 
     */
    create<T extends TechnicalSpecificationCreateArgs>(args: SelectSubset<T, TechnicalSpecificationCreateArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicalSpecifications.
     * @param {TechnicalSpecificationCreateManyArgs} args - Arguments to create many TechnicalSpecifications.
     * @example
     * // Create many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicalSpecificationCreateManyArgs>(args?: SelectSubset<T, TechnicalSpecificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicalSpecifications and returns the data saved in the database.
     * @param {TechnicalSpecificationCreateManyAndReturnArgs} args - Arguments to create many TechnicalSpecifications.
     * @example
     * // Create many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicalSpecifications and only return the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicalSpecificationCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicalSpecification.
     * @param {TechnicalSpecificationDeleteArgs} args - Arguments to delete one TechnicalSpecification.
     * @example
     * // Delete one TechnicalSpecification
     * const TechnicalSpecification = await prisma.technicalSpecification.delete({
     *   where: {
     *     // ... filter to delete one TechnicalSpecification
     *   }
     * })
     * 
     */
    delete<T extends TechnicalSpecificationDeleteArgs>(args: SelectSubset<T, TechnicalSpecificationDeleteArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicalSpecification.
     * @param {TechnicalSpecificationUpdateArgs} args - Arguments to update one TechnicalSpecification.
     * @example
     * // Update one TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicalSpecificationUpdateArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicalSpecifications.
     * @param {TechnicalSpecificationDeleteManyArgs} args - Arguments to filter TechnicalSpecifications to delete.
     * @example
     * // Delete a few TechnicalSpecifications
     * const { count } = await prisma.technicalSpecification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicalSpecificationDeleteManyArgs>(args?: SelectSubset<T, TechnicalSpecificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicalSpecificationUpdateManyArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecifications and returns the data updated in the database.
     * @param {TechnicalSpecificationUpdateManyAndReturnArgs} args - Arguments to update many TechnicalSpecifications.
     * @example
     * // Update many TechnicalSpecifications
     * const technicalSpecification = await prisma.technicalSpecification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicalSpecifications and only return the `id`
     * const technicalSpecificationWithIdOnly = await prisma.technicalSpecification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicalSpecificationUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicalSpecification.
     * @param {TechnicalSpecificationUpsertArgs} args - Arguments to update or create a TechnicalSpecification.
     * @example
     * // Update or create a TechnicalSpecification
     * const technicalSpecification = await prisma.technicalSpecification.upsert({
     *   create: {
     *     // ... data to create a TechnicalSpecification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicalSpecification we want to update
     *   }
     * })
     */
    upsert<T extends TechnicalSpecificationUpsertArgs>(args: SelectSubset<T, TechnicalSpecificationUpsertArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicalSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationCountArgs} args - Arguments to filter TechnicalSpecifications to count.
     * @example
     * // Count the number of TechnicalSpecifications
     * const count = await prisma.technicalSpecification.count({
     *   where: {
     *     // ... the filter for the TechnicalSpecifications we want to count
     *   }
     * })
    **/
    count<T extends TechnicalSpecificationCountArgs>(
      args?: Subset<T, TechnicalSpecificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicalSpecificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicalSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicalSpecificationAggregateArgs>(args: Subset<T, TechnicalSpecificationAggregateArgs>): Prisma.PrismaPromise<GetTechnicalSpecificationAggregateType<T>>

    /**
     * Group by TechnicalSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicalSpecificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicalSpecificationGroupByArgs['orderBy'] }
        : { orderBy?: TechnicalSpecificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicalSpecificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicalSpecificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicalSpecification model
   */
  readonly fields: TechnicalSpecificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicalSpecification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicalSpecificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    translations<T extends TechnicalSpecification$translationsArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSpecification$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends TechnicalSpecification$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSpecification$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicalSpecification model
   */
  interface TechnicalSpecificationFieldRefs {
    readonly id: FieldRef<"TechnicalSpecification", 'Int'>
    readonly productId: FieldRef<"TechnicalSpecification", 'Int'>
    readonly feature_en: FieldRef<"TechnicalSpecification", 'String'>
    readonly spec_en: FieldRef<"TechnicalSpecification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TechnicalSpecification findUnique
   */
  export type TechnicalSpecificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification findUniqueOrThrow
   */
  export type TechnicalSpecificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification findFirst
   */
  export type TechnicalSpecificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecifications.
     */
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification findFirstOrThrow
   */
  export type TechnicalSpecificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecification to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecifications.
     */
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification findMany
   */
  export type TechnicalSpecificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecifications to fetch.
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecifications to fetch.
     */
    orderBy?: TechnicalSpecificationOrderByWithRelationInput | TechnicalSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicalSpecifications.
     */
    cursor?: TechnicalSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecifications.
     */
    skip?: number
    distinct?: TechnicalSpecificationScalarFieldEnum | TechnicalSpecificationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification create
   */
  export type TechnicalSpecificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicalSpecification.
     */
    data: XOR<TechnicalSpecificationCreateInput, TechnicalSpecificationUncheckedCreateInput>
  }

  /**
   * TechnicalSpecification createMany
   */
  export type TechnicalSpecificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicalSpecifications.
     */
    data: TechnicalSpecificationCreateManyInput | TechnicalSpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicalSpecification createManyAndReturn
   */
  export type TechnicalSpecificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicalSpecifications.
     */
    data: TechnicalSpecificationCreateManyInput | TechnicalSpecificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecification update
   */
  export type TechnicalSpecificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicalSpecification.
     */
    data: XOR<TechnicalSpecificationUpdateInput, TechnicalSpecificationUncheckedUpdateInput>
    /**
     * Choose, which TechnicalSpecification to update.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification updateMany
   */
  export type TechnicalSpecificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicalSpecifications.
     */
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecifications to update
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to update.
     */
    limit?: number
  }

  /**
   * TechnicalSpecification updateManyAndReturn
   */
  export type TechnicalSpecificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * The data used to update TechnicalSpecifications.
     */
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecifications to update
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecification upsert
   */
  export type TechnicalSpecificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicalSpecification to update in case it exists.
     */
    where: TechnicalSpecificationWhereUniqueInput
    /**
     * In case the TechnicalSpecification found by the `where` argument doesn't exist, create a new TechnicalSpecification with this data.
     */
    create: XOR<TechnicalSpecificationCreateInput, TechnicalSpecificationUncheckedCreateInput>
    /**
     * In case the TechnicalSpecification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicalSpecificationUpdateInput, TechnicalSpecificationUncheckedUpdateInput>
  }

  /**
   * TechnicalSpecification delete
   */
  export type TechnicalSpecificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
    /**
     * Filter which TechnicalSpecification to delete.
     */
    where: TechnicalSpecificationWhereUniqueInput
  }

  /**
   * TechnicalSpecification deleteMany
   */
  export type TechnicalSpecificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecifications to delete
     */
    where?: TechnicalSpecificationWhereInput
    /**
     * Limit how many TechnicalSpecifications to delete.
     */
    limit?: number
  }

  /**
   * TechnicalSpecification.translations
   */
  export type TechnicalSpecification$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    where?: TechnicalSpecificationTranslationWhereInput
    orderBy?: TechnicalSpecificationTranslationOrderByWithRelationInput | TechnicalSpecificationTranslationOrderByWithRelationInput[]
    cursor?: TechnicalSpecificationTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicalSpecificationTranslationScalarFieldEnum | TechnicalSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification.productTranslations
   */
  export type TechnicalSpecification$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecification without action
   */
  export type TechnicalSpecificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecification
     */
    select?: TechnicalSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecification
     */
    omit?: TechnicalSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationInclude<ExtArgs> | null
  }


  /**
   * Model TechnicalSpecificationTranslation
   */

  export type AggregateTechnicalSpecificationTranslation = {
    _count: TechnicalSpecificationTranslationCountAggregateOutputType | null
    _avg: TechnicalSpecificationTranslationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationTranslationSumAggregateOutputType | null
    _min: TechnicalSpecificationTranslationMinAggregateOutputType | null
    _max: TechnicalSpecificationTranslationMaxAggregateOutputType | null
  }

  export type TechnicalSpecificationTranslationAvgAggregateOutputType = {
    id: number | null
    technicalSpecificationId: number | null
  }

  export type TechnicalSpecificationTranslationSumAggregateOutputType = {
    id: number | null
    technicalSpecificationId: number | null
  }

  export type TechnicalSpecificationTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    feature: string | null
    spec: string | null
    technicalSpecificationId: number | null
  }

  export type TechnicalSpecificationTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    feature: string | null
    spec: string | null
    technicalSpecificationId: number | null
  }

  export type TechnicalSpecificationTranslationCountAggregateOutputType = {
    id: number
    language: number
    feature: number
    spec: number
    technicalSpecificationId: number
    _all: number
  }


  export type TechnicalSpecificationTranslationAvgAggregateInputType = {
    id?: true
    technicalSpecificationId?: true
  }

  export type TechnicalSpecificationTranslationSumAggregateInputType = {
    id?: true
    technicalSpecificationId?: true
  }

  export type TechnicalSpecificationTranslationMinAggregateInputType = {
    id?: true
    language?: true
    feature?: true
    spec?: true
    technicalSpecificationId?: true
  }

  export type TechnicalSpecificationTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    feature?: true
    spec?: true
    technicalSpecificationId?: true
  }

  export type TechnicalSpecificationTranslationCountAggregateInputType = {
    id?: true
    language?: true
    feature?: true
    spec?: true
    technicalSpecificationId?: true
    _all?: true
  }

  export type TechnicalSpecificationTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecificationTranslation to aggregate.
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecificationTranslations to fetch.
     */
    orderBy?: TechnicalSpecificationTranslationOrderByWithRelationInput | TechnicalSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicalSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicalSpecificationTranslations
    **/
    _count?: true | TechnicalSpecificationTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicalSpecificationTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicalSpecificationTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicalSpecificationTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicalSpecificationTranslationMaxAggregateInputType
  }

  export type GetTechnicalSpecificationTranslationAggregateType<T extends TechnicalSpecificationTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicalSpecificationTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicalSpecificationTranslation[P]>
      : GetScalarType<T[P], AggregateTechnicalSpecificationTranslation[P]>
  }




  export type TechnicalSpecificationTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSpecificationTranslationWhereInput
    orderBy?: TechnicalSpecificationTranslationOrderByWithAggregationInput | TechnicalSpecificationTranslationOrderByWithAggregationInput[]
    by: TechnicalSpecificationTranslationScalarFieldEnum[] | TechnicalSpecificationTranslationScalarFieldEnum
    having?: TechnicalSpecificationTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicalSpecificationTranslationCountAggregateInputType | true
    _avg?: TechnicalSpecificationTranslationAvgAggregateInputType
    _sum?: TechnicalSpecificationTranslationSumAggregateInputType
    _min?: TechnicalSpecificationTranslationMinAggregateInputType
    _max?: TechnicalSpecificationTranslationMaxAggregateInputType
  }

  export type TechnicalSpecificationTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    feature: string
    spec: string
    technicalSpecificationId: number
    _count: TechnicalSpecificationTranslationCountAggregateOutputType | null
    _avg: TechnicalSpecificationTranslationAvgAggregateOutputType | null
    _sum: TechnicalSpecificationTranslationSumAggregateOutputType | null
    _min: TechnicalSpecificationTranslationMinAggregateOutputType | null
    _max: TechnicalSpecificationTranslationMaxAggregateOutputType | null
  }

  type GetTechnicalSpecificationTranslationGroupByPayload<T extends TechnicalSpecificationTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicalSpecificationTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicalSpecificationTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicalSpecificationTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicalSpecificationTranslationGroupByOutputType[P]>
        }
      >
    >


  export type TechnicalSpecificationTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    feature?: boolean
    spec?: boolean
    technicalSpecificationId?: boolean
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecificationTranslation"]>

  export type TechnicalSpecificationTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    feature?: boolean
    spec?: boolean
    technicalSpecificationId?: boolean
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecificationTranslation"]>

  export type TechnicalSpecificationTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    feature?: boolean
    spec?: boolean
    technicalSpecificationId?: boolean
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSpecificationTranslation"]>

  export type TechnicalSpecificationTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    feature?: boolean
    spec?: boolean
    technicalSpecificationId?: boolean
  }

  export type TechnicalSpecificationTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "feature" | "spec" | "technicalSpecificationId", ExtArgs["result"]["technicalSpecificationTranslation"]>
  export type TechnicalSpecificationTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }
  export type TechnicalSpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalSpecification?: boolean | TechnicalSpecificationDefaultArgs<ExtArgs>
  }

  export type $TechnicalSpecificationTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicalSpecificationTranslation"
    objects: {
      technicalSpecification: Prisma.$TechnicalSpecificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      feature: string
      spec: string
      technicalSpecificationId: number
    }, ExtArgs["result"]["technicalSpecificationTranslation"]>
    composites: {}
  }

  type TechnicalSpecificationTranslationGetPayload<S extends boolean | null | undefined | TechnicalSpecificationTranslationDefaultArgs> = $Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload, S>

  type TechnicalSpecificationTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicalSpecificationTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicalSpecificationTranslationCountAggregateInputType | true
    }

  export interface TechnicalSpecificationTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicalSpecificationTranslation'], meta: { name: 'TechnicalSpecificationTranslation' } }
    /**
     * Find zero or one TechnicalSpecificationTranslation that matches the filter.
     * @param {TechnicalSpecificationTranslationFindUniqueArgs} args - Arguments to find a TechnicalSpecificationTranslation
     * @example
     * // Get one TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicalSpecificationTranslationFindUniqueArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationFindUniqueArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicalSpecificationTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicalSpecificationTranslationFindUniqueOrThrowArgs} args - Arguments to find a TechnicalSpecificationTranslation
     * @example
     * // Get one TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicalSpecificationTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecificationTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationFindFirstArgs} args - Arguments to find a TechnicalSpecificationTranslation
     * @example
     * // Get one TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicalSpecificationTranslationFindFirstArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationFindFirstArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalSpecificationTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationFindFirstOrThrowArgs} args - Arguments to find a TechnicalSpecificationTranslation
     * @example
     * // Get one TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicalSpecificationTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicalSpecificationTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicalSpecificationTranslations
     * const technicalSpecificationTranslations = await prisma.technicalSpecificationTranslation.findMany()
     * 
     * // Get first 10 TechnicalSpecificationTranslations
     * const technicalSpecificationTranslations = await prisma.technicalSpecificationTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicalSpecificationTranslationWithIdOnly = await prisma.technicalSpecificationTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicalSpecificationTranslationFindManyArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicalSpecificationTranslation.
     * @param {TechnicalSpecificationTranslationCreateArgs} args - Arguments to create a TechnicalSpecificationTranslation.
     * @example
     * // Create one TechnicalSpecificationTranslation
     * const TechnicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.create({
     *   data: {
     *     // ... data to create a TechnicalSpecificationTranslation
     *   }
     * })
     * 
     */
    create<T extends TechnicalSpecificationTranslationCreateArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationCreateArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicalSpecificationTranslations.
     * @param {TechnicalSpecificationTranslationCreateManyArgs} args - Arguments to create many TechnicalSpecificationTranslations.
     * @example
     * // Create many TechnicalSpecificationTranslations
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicalSpecificationTranslationCreateManyArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicalSpecificationTranslations and returns the data saved in the database.
     * @param {TechnicalSpecificationTranslationCreateManyAndReturnArgs} args - Arguments to create many TechnicalSpecificationTranslations.
     * @example
     * // Create many TechnicalSpecificationTranslations
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicalSpecificationTranslations and only return the `id`
     * const technicalSpecificationTranslationWithIdOnly = await prisma.technicalSpecificationTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicalSpecificationTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicalSpecificationTranslation.
     * @param {TechnicalSpecificationTranslationDeleteArgs} args - Arguments to delete one TechnicalSpecificationTranslation.
     * @example
     * // Delete one TechnicalSpecificationTranslation
     * const TechnicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.delete({
     *   where: {
     *     // ... filter to delete one TechnicalSpecificationTranslation
     *   }
     * })
     * 
     */
    delete<T extends TechnicalSpecificationTranslationDeleteArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationDeleteArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicalSpecificationTranslation.
     * @param {TechnicalSpecificationTranslationUpdateArgs} args - Arguments to update one TechnicalSpecificationTranslation.
     * @example
     * // Update one TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicalSpecificationTranslationUpdateArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationUpdateArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicalSpecificationTranslations.
     * @param {TechnicalSpecificationTranslationDeleteManyArgs} args - Arguments to filter TechnicalSpecificationTranslations to delete.
     * @example
     * // Delete a few TechnicalSpecificationTranslations
     * const { count } = await prisma.technicalSpecificationTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicalSpecificationTranslationDeleteManyArgs>(args?: SelectSubset<T, TechnicalSpecificationTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicalSpecificationTranslations
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicalSpecificationTranslationUpdateManyArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSpecificationTranslations and returns the data updated in the database.
     * @param {TechnicalSpecificationTranslationUpdateManyAndReturnArgs} args - Arguments to update many TechnicalSpecificationTranslations.
     * @example
     * // Update many TechnicalSpecificationTranslations
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicalSpecificationTranslations and only return the `id`
     * const technicalSpecificationTranslationWithIdOnly = await prisma.technicalSpecificationTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicalSpecificationTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicalSpecificationTranslation.
     * @param {TechnicalSpecificationTranslationUpsertArgs} args - Arguments to update or create a TechnicalSpecificationTranslation.
     * @example
     * // Update or create a TechnicalSpecificationTranslation
     * const technicalSpecificationTranslation = await prisma.technicalSpecificationTranslation.upsert({
     *   create: {
     *     // ... data to create a TechnicalSpecificationTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicalSpecificationTranslation we want to update
     *   }
     * })
     */
    upsert<T extends TechnicalSpecificationTranslationUpsertArgs>(args: SelectSubset<T, TechnicalSpecificationTranslationUpsertArgs<ExtArgs>>): Prisma__TechnicalSpecificationTranslationClient<$Result.GetResult<Prisma.$TechnicalSpecificationTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicalSpecificationTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationCountArgs} args - Arguments to filter TechnicalSpecificationTranslations to count.
     * @example
     * // Count the number of TechnicalSpecificationTranslations
     * const count = await prisma.technicalSpecificationTranslation.count({
     *   where: {
     *     // ... the filter for the TechnicalSpecificationTranslations we want to count
     *   }
     * })
    **/
    count<T extends TechnicalSpecificationTranslationCountArgs>(
      args?: Subset<T, TechnicalSpecificationTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicalSpecificationTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicalSpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicalSpecificationTranslationAggregateArgs>(args: Subset<T, TechnicalSpecificationTranslationAggregateArgs>): Prisma.PrismaPromise<GetTechnicalSpecificationTranslationAggregateType<T>>

    /**
     * Group by TechnicalSpecificationTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSpecificationTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicalSpecificationTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicalSpecificationTranslationGroupByArgs['orderBy'] }
        : { orderBy?: TechnicalSpecificationTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicalSpecificationTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicalSpecificationTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicalSpecificationTranslation model
   */
  readonly fields: TechnicalSpecificationTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicalSpecificationTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicalSpecificationTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    technicalSpecification<T extends TechnicalSpecificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSpecificationDefaultArgs<ExtArgs>>): Prisma__TechnicalSpecificationClient<$Result.GetResult<Prisma.$TechnicalSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicalSpecificationTranslation model
   */
  interface TechnicalSpecificationTranslationFieldRefs {
    readonly id: FieldRef<"TechnicalSpecificationTranslation", 'Int'>
    readonly language: FieldRef<"TechnicalSpecificationTranslation", 'LanguageCode'>
    readonly feature: FieldRef<"TechnicalSpecificationTranslation", 'String'>
    readonly spec: FieldRef<"TechnicalSpecificationTranslation", 'String'>
    readonly technicalSpecificationId: FieldRef<"TechnicalSpecificationTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TechnicalSpecificationTranslation findUnique
   */
  export type TechnicalSpecificationTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecificationTranslation to fetch.
     */
    where: TechnicalSpecificationTranslationWhereUniqueInput
  }

  /**
   * TechnicalSpecificationTranslation findUniqueOrThrow
   */
  export type TechnicalSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecificationTranslation to fetch.
     */
    where: TechnicalSpecificationTranslationWhereUniqueInput
  }

  /**
   * TechnicalSpecificationTranslation findFirst
   */
  export type TechnicalSpecificationTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecificationTranslation to fetch.
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecificationTranslations to fetch.
     */
    orderBy?: TechnicalSpecificationTranslationOrderByWithRelationInput | TechnicalSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecificationTranslations.
     */
    cursor?: TechnicalSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecificationTranslations.
     */
    distinct?: TechnicalSpecificationTranslationScalarFieldEnum | TechnicalSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecificationTranslation findFirstOrThrow
   */
  export type TechnicalSpecificationTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecificationTranslation to fetch.
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecificationTranslations to fetch.
     */
    orderBy?: TechnicalSpecificationTranslationOrderByWithRelationInput | TechnicalSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSpecificationTranslations.
     */
    cursor?: TechnicalSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecificationTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSpecificationTranslations.
     */
    distinct?: TechnicalSpecificationTranslationScalarFieldEnum | TechnicalSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecificationTranslation findMany
   */
  export type TechnicalSpecificationTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSpecificationTranslations to fetch.
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSpecificationTranslations to fetch.
     */
    orderBy?: TechnicalSpecificationTranslationOrderByWithRelationInput | TechnicalSpecificationTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicalSpecificationTranslations.
     */
    cursor?: TechnicalSpecificationTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSpecificationTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSpecificationTranslations.
     */
    skip?: number
    distinct?: TechnicalSpecificationTranslationScalarFieldEnum | TechnicalSpecificationTranslationScalarFieldEnum[]
  }

  /**
   * TechnicalSpecificationTranslation create
   */
  export type TechnicalSpecificationTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicalSpecificationTranslation.
     */
    data: XOR<TechnicalSpecificationTranslationCreateInput, TechnicalSpecificationTranslationUncheckedCreateInput>
  }

  /**
   * TechnicalSpecificationTranslation createMany
   */
  export type TechnicalSpecificationTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicalSpecificationTranslations.
     */
    data: TechnicalSpecificationTranslationCreateManyInput | TechnicalSpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicalSpecificationTranslation createManyAndReturn
   */
  export type TechnicalSpecificationTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicalSpecificationTranslations.
     */
    data: TechnicalSpecificationTranslationCreateManyInput | TechnicalSpecificationTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecificationTranslation update
   */
  export type TechnicalSpecificationTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicalSpecificationTranslation.
     */
    data: XOR<TechnicalSpecificationTranslationUpdateInput, TechnicalSpecificationTranslationUncheckedUpdateInput>
    /**
     * Choose, which TechnicalSpecificationTranslation to update.
     */
    where: TechnicalSpecificationTranslationWhereUniqueInput
  }

  /**
   * TechnicalSpecificationTranslation updateMany
   */
  export type TechnicalSpecificationTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicalSpecificationTranslations.
     */
    data: XOR<TechnicalSpecificationTranslationUpdateManyMutationInput, TechnicalSpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecificationTranslations to update
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * Limit how many TechnicalSpecificationTranslations to update.
     */
    limit?: number
  }

  /**
   * TechnicalSpecificationTranslation updateManyAndReturn
   */
  export type TechnicalSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * The data used to update TechnicalSpecificationTranslations.
     */
    data: XOR<TechnicalSpecificationTranslationUpdateManyMutationInput, TechnicalSpecificationTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSpecificationTranslations to update
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * Limit how many TechnicalSpecificationTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalSpecificationTranslation upsert
   */
  export type TechnicalSpecificationTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicalSpecificationTranslation to update in case it exists.
     */
    where: TechnicalSpecificationTranslationWhereUniqueInput
    /**
     * In case the TechnicalSpecificationTranslation found by the `where` argument doesn't exist, create a new TechnicalSpecificationTranslation with this data.
     */
    create: XOR<TechnicalSpecificationTranslationCreateInput, TechnicalSpecificationTranslationUncheckedCreateInput>
    /**
     * In case the TechnicalSpecificationTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicalSpecificationTranslationUpdateInput, TechnicalSpecificationTranslationUncheckedUpdateInput>
  }

  /**
   * TechnicalSpecificationTranslation delete
   */
  export type TechnicalSpecificationTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
    /**
     * Filter which TechnicalSpecificationTranslation to delete.
     */
    where: TechnicalSpecificationTranslationWhereUniqueInput
  }

  /**
   * TechnicalSpecificationTranslation deleteMany
   */
  export type TechnicalSpecificationTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSpecificationTranslations to delete
     */
    where?: TechnicalSpecificationTranslationWhereInput
    /**
     * Limit how many TechnicalSpecificationTranslations to delete.
     */
    limit?: number
  }

  /**
   * TechnicalSpecificationTranslation without action
   */
  export type TechnicalSpecificationTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSpecificationTranslation
     */
    select?: TechnicalSpecificationTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalSpecificationTranslation
     */
    omit?: TechnicalSpecificationTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalSpecificationTranslationInclude<ExtArgs> | null
  }


  /**
   * Model RelatedProduct
   */

  export type AggregateRelatedProduct = {
    _count: RelatedProductCountAggregateOutputType | null
    _avg: RelatedProductAvgAggregateOutputType | null
    _sum: RelatedProductSumAggregateOutputType | null
    _min: RelatedProductMinAggregateOutputType | null
    _max: RelatedProductMaxAggregateOutputType | null
  }

  export type RelatedProductAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type RelatedProductSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type RelatedProductMinAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    description_en: string | null
    image: string | null
    imageAlt_en: string | null
    category_icon: string | null
    category_Alt_en: string | null
    machineType: $Enums.MachineType | null
  }

  export type RelatedProductMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    description_en: string | null
    image: string | null
    imageAlt_en: string | null
    category_icon: string | null
    category_Alt_en: string | null
    machineType: $Enums.MachineType | null
  }

  export type RelatedProductCountAggregateOutputType = {
    id: number
    productId: number
    title_en: number
    description_en: number
    image: number
    imageAlt_en: number
    category_icon: number
    category_Alt_en: number
    machineType: number
    _all: number
  }


  export type RelatedProductAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type RelatedProductSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type RelatedProductMinAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    image?: true
    imageAlt_en?: true
    category_icon?: true
    category_Alt_en?: true
    machineType?: true
  }

  export type RelatedProductMaxAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    image?: true
    imageAlt_en?: true
    category_icon?: true
    category_Alt_en?: true
    machineType?: true
  }

  export type RelatedProductCountAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    image?: true
    imageAlt_en?: true
    category_icon?: true
    category_Alt_en?: true
    machineType?: true
    _all?: true
  }

  export type RelatedProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedProduct to aggregate.
     */
    where?: RelatedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProducts to fetch.
     */
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelatedProducts
    **/
    _count?: true | RelatedProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelatedProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelatedProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatedProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatedProductMaxAggregateInputType
  }

  export type GetRelatedProductAggregateType<T extends RelatedProductAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatedProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatedProduct[P]>
      : GetScalarType<T[P], AggregateRelatedProduct[P]>
  }




  export type RelatedProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedProductWhereInput
    orderBy?: RelatedProductOrderByWithAggregationInput | RelatedProductOrderByWithAggregationInput[]
    by: RelatedProductScalarFieldEnum[] | RelatedProductScalarFieldEnum
    having?: RelatedProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatedProductCountAggregateInputType | true
    _avg?: RelatedProductAvgAggregateInputType
    _sum?: RelatedProductSumAggregateInputType
    _min?: RelatedProductMinAggregateInputType
    _max?: RelatedProductMaxAggregateInputType
  }

  export type RelatedProductGroupByOutputType = {
    id: number
    productId: number
    title_en: string
    description_en: string | null
    image: string | null
    imageAlt_en: string | null
    category_icon: string | null
    category_Alt_en: string | null
    machineType: $Enums.MachineType
    _count: RelatedProductCountAggregateOutputType | null
    _avg: RelatedProductAvgAggregateOutputType | null
    _sum: RelatedProductSumAggregateOutputType | null
    _min: RelatedProductMinAggregateOutputType | null
    _max: RelatedProductMaxAggregateOutputType | null
  }

  type GetRelatedProductGroupByPayload<T extends RelatedProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelatedProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatedProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatedProductGroupByOutputType[P]>
            : GetScalarType<T[P], RelatedProductGroupByOutputType[P]>
        }
      >
    >


  export type RelatedProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    image?: boolean
    imageAlt_en?: boolean
    category_icon?: boolean
    category_Alt_en?: boolean
    machineType?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | RelatedProduct$translationsArgs<ExtArgs>
    productTranslations?: boolean | RelatedProduct$productTranslationsArgs<ExtArgs>
    _count?: boolean | RelatedProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProduct"]>

  export type RelatedProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    image?: boolean
    imageAlt_en?: boolean
    category_icon?: boolean
    category_Alt_en?: boolean
    machineType?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProduct"]>

  export type RelatedProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    image?: boolean
    imageAlt_en?: boolean
    category_icon?: boolean
    category_Alt_en?: boolean
    machineType?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProduct"]>

  export type RelatedProductSelectScalar = {
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    image?: boolean
    imageAlt_en?: boolean
    category_icon?: boolean
    category_Alt_en?: boolean
    machineType?: boolean
  }

  export type RelatedProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "title_en" | "description_en" | "image" | "imageAlt_en" | "category_icon" | "category_Alt_en" | "machineType", ExtArgs["result"]["relatedProduct"]>
  export type RelatedProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | RelatedProduct$translationsArgs<ExtArgs>
    productTranslations?: boolean | RelatedProduct$productTranslationsArgs<ExtArgs>
    _count?: boolean | RelatedProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RelatedProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RelatedProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $RelatedProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelatedProduct"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      translations: Prisma.$RelatedProductTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      title_en: string
      description_en: string | null
      image: string | null
      imageAlt_en: string | null
      category_icon: string | null
      category_Alt_en: string | null
      machineType: $Enums.MachineType
    }, ExtArgs["result"]["relatedProduct"]>
    composites: {}
  }

  type RelatedProductGetPayload<S extends boolean | null | undefined | RelatedProductDefaultArgs> = $Result.GetResult<Prisma.$RelatedProductPayload, S>

  type RelatedProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelatedProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelatedProductCountAggregateInputType | true
    }

  export interface RelatedProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelatedProduct'], meta: { name: 'RelatedProduct' } }
    /**
     * Find zero or one RelatedProduct that matches the filter.
     * @param {RelatedProductFindUniqueArgs} args - Arguments to find a RelatedProduct
     * @example
     * // Get one RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelatedProductFindUniqueArgs>(args: SelectSubset<T, RelatedProductFindUniqueArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelatedProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelatedProductFindUniqueOrThrowArgs} args - Arguments to find a RelatedProduct
     * @example
     * // Get one RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelatedProductFindUniqueOrThrowArgs>(args: SelectSubset<T, RelatedProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelatedProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductFindFirstArgs} args - Arguments to find a RelatedProduct
     * @example
     * // Get one RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelatedProductFindFirstArgs>(args?: SelectSubset<T, RelatedProductFindFirstArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelatedProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductFindFirstOrThrowArgs} args - Arguments to find a RelatedProduct
     * @example
     * // Get one RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelatedProductFindFirstOrThrowArgs>(args?: SelectSubset<T, RelatedProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelatedProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelatedProducts
     * const relatedProducts = await prisma.relatedProduct.findMany()
     * 
     * // Get first 10 RelatedProducts
     * const relatedProducts = await prisma.relatedProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatedProductWithIdOnly = await prisma.relatedProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelatedProductFindManyArgs>(args?: SelectSubset<T, RelatedProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelatedProduct.
     * @param {RelatedProductCreateArgs} args - Arguments to create a RelatedProduct.
     * @example
     * // Create one RelatedProduct
     * const RelatedProduct = await prisma.relatedProduct.create({
     *   data: {
     *     // ... data to create a RelatedProduct
     *   }
     * })
     * 
     */
    create<T extends RelatedProductCreateArgs>(args: SelectSubset<T, RelatedProductCreateArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelatedProducts.
     * @param {RelatedProductCreateManyArgs} args - Arguments to create many RelatedProducts.
     * @example
     * // Create many RelatedProducts
     * const relatedProduct = await prisma.relatedProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelatedProductCreateManyArgs>(args?: SelectSubset<T, RelatedProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelatedProducts and returns the data saved in the database.
     * @param {RelatedProductCreateManyAndReturnArgs} args - Arguments to create many RelatedProducts.
     * @example
     * // Create many RelatedProducts
     * const relatedProduct = await prisma.relatedProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelatedProducts and only return the `id`
     * const relatedProductWithIdOnly = await prisma.relatedProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelatedProductCreateManyAndReturnArgs>(args?: SelectSubset<T, RelatedProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelatedProduct.
     * @param {RelatedProductDeleteArgs} args - Arguments to delete one RelatedProduct.
     * @example
     * // Delete one RelatedProduct
     * const RelatedProduct = await prisma.relatedProduct.delete({
     *   where: {
     *     // ... filter to delete one RelatedProduct
     *   }
     * })
     * 
     */
    delete<T extends RelatedProductDeleteArgs>(args: SelectSubset<T, RelatedProductDeleteArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelatedProduct.
     * @param {RelatedProductUpdateArgs} args - Arguments to update one RelatedProduct.
     * @example
     * // Update one RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelatedProductUpdateArgs>(args: SelectSubset<T, RelatedProductUpdateArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelatedProducts.
     * @param {RelatedProductDeleteManyArgs} args - Arguments to filter RelatedProducts to delete.
     * @example
     * // Delete a few RelatedProducts
     * const { count } = await prisma.relatedProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelatedProductDeleteManyArgs>(args?: SelectSubset<T, RelatedProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelatedProducts
     * const relatedProduct = await prisma.relatedProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelatedProductUpdateManyArgs>(args: SelectSubset<T, RelatedProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedProducts and returns the data updated in the database.
     * @param {RelatedProductUpdateManyAndReturnArgs} args - Arguments to update many RelatedProducts.
     * @example
     * // Update many RelatedProducts
     * const relatedProduct = await prisma.relatedProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelatedProducts and only return the `id`
     * const relatedProductWithIdOnly = await prisma.relatedProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelatedProductUpdateManyAndReturnArgs>(args: SelectSubset<T, RelatedProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelatedProduct.
     * @param {RelatedProductUpsertArgs} args - Arguments to update or create a RelatedProduct.
     * @example
     * // Update or create a RelatedProduct
     * const relatedProduct = await prisma.relatedProduct.upsert({
     *   create: {
     *     // ... data to create a RelatedProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelatedProduct we want to update
     *   }
     * })
     */
    upsert<T extends RelatedProductUpsertArgs>(args: SelectSubset<T, RelatedProductUpsertArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelatedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductCountArgs} args - Arguments to filter RelatedProducts to count.
     * @example
     * // Count the number of RelatedProducts
     * const count = await prisma.relatedProduct.count({
     *   where: {
     *     // ... the filter for the RelatedProducts we want to count
     *   }
     * })
    **/
    count<T extends RelatedProductCountArgs>(
      args?: Subset<T, RelatedProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatedProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelatedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatedProductAggregateArgs>(args: Subset<T, RelatedProductAggregateArgs>): Prisma.PrismaPromise<GetRelatedProductAggregateType<T>>

    /**
     * Group by RelatedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatedProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatedProductGroupByArgs['orderBy'] }
        : { orderBy?: RelatedProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatedProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatedProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelatedProduct model
   */
  readonly fields: RelatedProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelatedProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelatedProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    translations<T extends RelatedProduct$translationsArgs<ExtArgs> = {}>(args?: Subset<T, RelatedProduct$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends RelatedProduct$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, RelatedProduct$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelatedProduct model
   */
  interface RelatedProductFieldRefs {
    readonly id: FieldRef<"RelatedProduct", 'Int'>
    readonly productId: FieldRef<"RelatedProduct", 'Int'>
    readonly title_en: FieldRef<"RelatedProduct", 'String'>
    readonly description_en: FieldRef<"RelatedProduct", 'String'>
    readonly image: FieldRef<"RelatedProduct", 'String'>
    readonly imageAlt_en: FieldRef<"RelatedProduct", 'String'>
    readonly category_icon: FieldRef<"RelatedProduct", 'String'>
    readonly category_Alt_en: FieldRef<"RelatedProduct", 'String'>
    readonly machineType: FieldRef<"RelatedProduct", 'MachineType'>
  }
    

  // Custom InputTypes
  /**
   * RelatedProduct findUnique
   */
  export type RelatedProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProduct to fetch.
     */
    where: RelatedProductWhereUniqueInput
  }

  /**
   * RelatedProduct findUniqueOrThrow
   */
  export type RelatedProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProduct to fetch.
     */
    where: RelatedProductWhereUniqueInput
  }

  /**
   * RelatedProduct findFirst
   */
  export type RelatedProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProduct to fetch.
     */
    where?: RelatedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProducts to fetch.
     */
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedProducts.
     */
    cursor?: RelatedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedProducts.
     */
    distinct?: RelatedProductScalarFieldEnum | RelatedProductScalarFieldEnum[]
  }

  /**
   * RelatedProduct findFirstOrThrow
   */
  export type RelatedProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProduct to fetch.
     */
    where?: RelatedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProducts to fetch.
     */
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedProducts.
     */
    cursor?: RelatedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedProducts.
     */
    distinct?: RelatedProductScalarFieldEnum | RelatedProductScalarFieldEnum[]
  }

  /**
   * RelatedProduct findMany
   */
  export type RelatedProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProducts to fetch.
     */
    where?: RelatedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProducts to fetch.
     */
    orderBy?: RelatedProductOrderByWithRelationInput | RelatedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelatedProducts.
     */
    cursor?: RelatedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProducts.
     */
    skip?: number
    distinct?: RelatedProductScalarFieldEnum | RelatedProductScalarFieldEnum[]
  }

  /**
   * RelatedProduct create
   */
  export type RelatedProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * The data needed to create a RelatedProduct.
     */
    data: XOR<RelatedProductCreateInput, RelatedProductUncheckedCreateInput>
  }

  /**
   * RelatedProduct createMany
   */
  export type RelatedProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelatedProducts.
     */
    data: RelatedProductCreateManyInput | RelatedProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelatedProduct createManyAndReturn
   */
  export type RelatedProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * The data used to create many RelatedProducts.
     */
    data: RelatedProductCreateManyInput | RelatedProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedProduct update
   */
  export type RelatedProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * The data needed to update a RelatedProduct.
     */
    data: XOR<RelatedProductUpdateInput, RelatedProductUncheckedUpdateInput>
    /**
     * Choose, which RelatedProduct to update.
     */
    where: RelatedProductWhereUniqueInput
  }

  /**
   * RelatedProduct updateMany
   */
  export type RelatedProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelatedProducts.
     */
    data: XOR<RelatedProductUpdateManyMutationInput, RelatedProductUncheckedUpdateManyInput>
    /**
     * Filter which RelatedProducts to update
     */
    where?: RelatedProductWhereInput
    /**
     * Limit how many RelatedProducts to update.
     */
    limit?: number
  }

  /**
   * RelatedProduct updateManyAndReturn
   */
  export type RelatedProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * The data used to update RelatedProducts.
     */
    data: XOR<RelatedProductUpdateManyMutationInput, RelatedProductUncheckedUpdateManyInput>
    /**
     * Filter which RelatedProducts to update
     */
    where?: RelatedProductWhereInput
    /**
     * Limit how many RelatedProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedProduct upsert
   */
  export type RelatedProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * The filter to search for the RelatedProduct to update in case it exists.
     */
    where: RelatedProductWhereUniqueInput
    /**
     * In case the RelatedProduct found by the `where` argument doesn't exist, create a new RelatedProduct with this data.
     */
    create: XOR<RelatedProductCreateInput, RelatedProductUncheckedCreateInput>
    /**
     * In case the RelatedProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatedProductUpdateInput, RelatedProductUncheckedUpdateInput>
  }

  /**
   * RelatedProduct delete
   */
  export type RelatedProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
    /**
     * Filter which RelatedProduct to delete.
     */
    where: RelatedProductWhereUniqueInput
  }

  /**
   * RelatedProduct deleteMany
   */
  export type RelatedProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedProducts to delete
     */
    where?: RelatedProductWhereInput
    /**
     * Limit how many RelatedProducts to delete.
     */
    limit?: number
  }

  /**
   * RelatedProduct.translations
   */
  export type RelatedProduct$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    where?: RelatedProductTranslationWhereInput
    orderBy?: RelatedProductTranslationOrderByWithRelationInput | RelatedProductTranslationOrderByWithRelationInput[]
    cursor?: RelatedProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatedProductTranslationScalarFieldEnum | RelatedProductTranslationScalarFieldEnum[]
  }

  /**
   * RelatedProduct.productTranslations
   */
  export type RelatedProduct$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * RelatedProduct without action
   */
  export type RelatedProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProduct
     */
    select?: RelatedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProduct
     */
    omit?: RelatedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductInclude<ExtArgs> | null
  }


  /**
   * Model RelatedProductTranslation
   */

  export type AggregateRelatedProductTranslation = {
    _count: RelatedProductTranslationCountAggregateOutputType | null
    _avg: RelatedProductTranslationAvgAggregateOutputType | null
    _sum: RelatedProductTranslationSumAggregateOutputType | null
    _min: RelatedProductTranslationMinAggregateOutputType | null
    _max: RelatedProductTranslationMaxAggregateOutputType | null
  }

  export type RelatedProductTranslationAvgAggregateOutputType = {
    id: number | null
    relatedProductId: number | null
  }

  export type RelatedProductTranslationSumAggregateOutputType = {
    id: number | null
    relatedProductId: number | null
  }

  export type RelatedProductTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    description: string | null
    imageAlt: string | null
    category_Alt: string | null
    machineType: $Enums.MachineType | null
    relatedProductId: number | null
  }

  export type RelatedProductTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    description: string | null
    imageAlt: string | null
    category_Alt: string | null
    machineType: $Enums.MachineType | null
    relatedProductId: number | null
  }

  export type RelatedProductTranslationCountAggregateOutputType = {
    id: number
    language: number
    title: number
    description: number
    imageAlt: number
    category_Alt: number
    machineType: number
    relatedProductId: number
    _all: number
  }


  export type RelatedProductTranslationAvgAggregateInputType = {
    id?: true
    relatedProductId?: true
  }

  export type RelatedProductTranslationSumAggregateInputType = {
    id?: true
    relatedProductId?: true
  }

  export type RelatedProductTranslationMinAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    imageAlt?: true
    category_Alt?: true
    machineType?: true
    relatedProductId?: true
  }

  export type RelatedProductTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    imageAlt?: true
    category_Alt?: true
    machineType?: true
    relatedProductId?: true
  }

  export type RelatedProductTranslationCountAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    imageAlt?: true
    category_Alt?: true
    machineType?: true
    relatedProductId?: true
    _all?: true
  }

  export type RelatedProductTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedProductTranslation to aggregate.
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProductTranslations to fetch.
     */
    orderBy?: RelatedProductTranslationOrderByWithRelationInput | RelatedProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatedProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelatedProductTranslations
    **/
    _count?: true | RelatedProductTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelatedProductTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelatedProductTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatedProductTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatedProductTranslationMaxAggregateInputType
  }

  export type GetRelatedProductTranslationAggregateType<T extends RelatedProductTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatedProductTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatedProductTranslation[P]>
      : GetScalarType<T[P], AggregateRelatedProductTranslation[P]>
  }




  export type RelatedProductTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatedProductTranslationWhereInput
    orderBy?: RelatedProductTranslationOrderByWithAggregationInput | RelatedProductTranslationOrderByWithAggregationInput[]
    by: RelatedProductTranslationScalarFieldEnum[] | RelatedProductTranslationScalarFieldEnum
    having?: RelatedProductTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatedProductTranslationCountAggregateInputType | true
    _avg?: RelatedProductTranslationAvgAggregateInputType
    _sum?: RelatedProductTranslationSumAggregateInputType
    _min?: RelatedProductTranslationMinAggregateInputType
    _max?: RelatedProductTranslationMaxAggregateInputType
  }

  export type RelatedProductTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    title: string
    description: string | null
    imageAlt: string | null
    category_Alt: string | null
    machineType: $Enums.MachineType
    relatedProductId: number
    _count: RelatedProductTranslationCountAggregateOutputType | null
    _avg: RelatedProductTranslationAvgAggregateOutputType | null
    _sum: RelatedProductTranslationSumAggregateOutputType | null
    _min: RelatedProductTranslationMinAggregateOutputType | null
    _max: RelatedProductTranslationMaxAggregateOutputType | null
  }

  type GetRelatedProductTranslationGroupByPayload<T extends RelatedProductTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelatedProductTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatedProductTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatedProductTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], RelatedProductTranslationGroupByOutputType[P]>
        }
      >
    >


  export type RelatedProductTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    imageAlt?: boolean
    category_Alt?: boolean
    machineType?: boolean
    relatedProductId?: boolean
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProductTranslation"]>

  export type RelatedProductTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    imageAlt?: boolean
    category_Alt?: boolean
    machineType?: boolean
    relatedProductId?: boolean
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProductTranslation"]>

  export type RelatedProductTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    imageAlt?: boolean
    category_Alt?: boolean
    machineType?: boolean
    relatedProductId?: boolean
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatedProductTranslation"]>

  export type RelatedProductTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    imageAlt?: boolean
    category_Alt?: boolean
    machineType?: boolean
    relatedProductId?: boolean
  }

  export type RelatedProductTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "title" | "description" | "imageAlt" | "category_Alt" | "machineType" | "relatedProductId", ExtArgs["result"]["relatedProductTranslation"]>
  export type RelatedProductTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }
  export type RelatedProductTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }
  export type RelatedProductTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedProduct?: boolean | RelatedProductDefaultArgs<ExtArgs>
  }

  export type $RelatedProductTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelatedProductTranslation"
    objects: {
      relatedProduct: Prisma.$RelatedProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      title: string
      description: string | null
      imageAlt: string | null
      category_Alt: string | null
      machineType: $Enums.MachineType
      relatedProductId: number
    }, ExtArgs["result"]["relatedProductTranslation"]>
    composites: {}
  }

  type RelatedProductTranslationGetPayload<S extends boolean | null | undefined | RelatedProductTranslationDefaultArgs> = $Result.GetResult<Prisma.$RelatedProductTranslationPayload, S>

  type RelatedProductTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelatedProductTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelatedProductTranslationCountAggregateInputType | true
    }

  export interface RelatedProductTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelatedProductTranslation'], meta: { name: 'RelatedProductTranslation' } }
    /**
     * Find zero or one RelatedProductTranslation that matches the filter.
     * @param {RelatedProductTranslationFindUniqueArgs} args - Arguments to find a RelatedProductTranslation
     * @example
     * // Get one RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelatedProductTranslationFindUniqueArgs>(args: SelectSubset<T, RelatedProductTranslationFindUniqueArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelatedProductTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelatedProductTranslationFindUniqueOrThrowArgs} args - Arguments to find a RelatedProductTranslation
     * @example
     * // Get one RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelatedProductTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, RelatedProductTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelatedProductTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationFindFirstArgs} args - Arguments to find a RelatedProductTranslation
     * @example
     * // Get one RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelatedProductTranslationFindFirstArgs>(args?: SelectSubset<T, RelatedProductTranslationFindFirstArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelatedProductTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationFindFirstOrThrowArgs} args - Arguments to find a RelatedProductTranslation
     * @example
     * // Get one RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelatedProductTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, RelatedProductTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelatedProductTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelatedProductTranslations
     * const relatedProductTranslations = await prisma.relatedProductTranslation.findMany()
     * 
     * // Get first 10 RelatedProductTranslations
     * const relatedProductTranslations = await prisma.relatedProductTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatedProductTranslationWithIdOnly = await prisma.relatedProductTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelatedProductTranslationFindManyArgs>(args?: SelectSubset<T, RelatedProductTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelatedProductTranslation.
     * @param {RelatedProductTranslationCreateArgs} args - Arguments to create a RelatedProductTranslation.
     * @example
     * // Create one RelatedProductTranslation
     * const RelatedProductTranslation = await prisma.relatedProductTranslation.create({
     *   data: {
     *     // ... data to create a RelatedProductTranslation
     *   }
     * })
     * 
     */
    create<T extends RelatedProductTranslationCreateArgs>(args: SelectSubset<T, RelatedProductTranslationCreateArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelatedProductTranslations.
     * @param {RelatedProductTranslationCreateManyArgs} args - Arguments to create many RelatedProductTranslations.
     * @example
     * // Create many RelatedProductTranslations
     * const relatedProductTranslation = await prisma.relatedProductTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelatedProductTranslationCreateManyArgs>(args?: SelectSubset<T, RelatedProductTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelatedProductTranslations and returns the data saved in the database.
     * @param {RelatedProductTranslationCreateManyAndReturnArgs} args - Arguments to create many RelatedProductTranslations.
     * @example
     * // Create many RelatedProductTranslations
     * const relatedProductTranslation = await prisma.relatedProductTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelatedProductTranslations and only return the `id`
     * const relatedProductTranslationWithIdOnly = await prisma.relatedProductTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelatedProductTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, RelatedProductTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelatedProductTranslation.
     * @param {RelatedProductTranslationDeleteArgs} args - Arguments to delete one RelatedProductTranslation.
     * @example
     * // Delete one RelatedProductTranslation
     * const RelatedProductTranslation = await prisma.relatedProductTranslation.delete({
     *   where: {
     *     // ... filter to delete one RelatedProductTranslation
     *   }
     * })
     * 
     */
    delete<T extends RelatedProductTranslationDeleteArgs>(args: SelectSubset<T, RelatedProductTranslationDeleteArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelatedProductTranslation.
     * @param {RelatedProductTranslationUpdateArgs} args - Arguments to update one RelatedProductTranslation.
     * @example
     * // Update one RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelatedProductTranslationUpdateArgs>(args: SelectSubset<T, RelatedProductTranslationUpdateArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelatedProductTranslations.
     * @param {RelatedProductTranslationDeleteManyArgs} args - Arguments to filter RelatedProductTranslations to delete.
     * @example
     * // Delete a few RelatedProductTranslations
     * const { count } = await prisma.relatedProductTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelatedProductTranslationDeleteManyArgs>(args?: SelectSubset<T, RelatedProductTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelatedProductTranslations
     * const relatedProductTranslation = await prisma.relatedProductTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelatedProductTranslationUpdateManyArgs>(args: SelectSubset<T, RelatedProductTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelatedProductTranslations and returns the data updated in the database.
     * @param {RelatedProductTranslationUpdateManyAndReturnArgs} args - Arguments to update many RelatedProductTranslations.
     * @example
     * // Update many RelatedProductTranslations
     * const relatedProductTranslation = await prisma.relatedProductTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelatedProductTranslations and only return the `id`
     * const relatedProductTranslationWithIdOnly = await prisma.relatedProductTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelatedProductTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, RelatedProductTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelatedProductTranslation.
     * @param {RelatedProductTranslationUpsertArgs} args - Arguments to update or create a RelatedProductTranslation.
     * @example
     * // Update or create a RelatedProductTranslation
     * const relatedProductTranslation = await prisma.relatedProductTranslation.upsert({
     *   create: {
     *     // ... data to create a RelatedProductTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelatedProductTranslation we want to update
     *   }
     * })
     */
    upsert<T extends RelatedProductTranslationUpsertArgs>(args: SelectSubset<T, RelatedProductTranslationUpsertArgs<ExtArgs>>): Prisma__RelatedProductTranslationClient<$Result.GetResult<Prisma.$RelatedProductTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelatedProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationCountArgs} args - Arguments to filter RelatedProductTranslations to count.
     * @example
     * // Count the number of RelatedProductTranslations
     * const count = await prisma.relatedProductTranslation.count({
     *   where: {
     *     // ... the filter for the RelatedProductTranslations we want to count
     *   }
     * })
    **/
    count<T extends RelatedProductTranslationCountArgs>(
      args?: Subset<T, RelatedProductTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatedProductTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelatedProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatedProductTranslationAggregateArgs>(args: Subset<T, RelatedProductTranslationAggregateArgs>): Prisma.PrismaPromise<GetRelatedProductTranslationAggregateType<T>>

    /**
     * Group by RelatedProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatedProductTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatedProductTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatedProductTranslationGroupByArgs['orderBy'] }
        : { orderBy?: RelatedProductTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatedProductTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatedProductTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelatedProductTranslation model
   */
  readonly fields: RelatedProductTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelatedProductTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelatedProductTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relatedProduct<T extends RelatedProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelatedProductDefaultArgs<ExtArgs>>): Prisma__RelatedProductClient<$Result.GetResult<Prisma.$RelatedProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelatedProductTranslation model
   */
  interface RelatedProductTranslationFieldRefs {
    readonly id: FieldRef<"RelatedProductTranslation", 'Int'>
    readonly language: FieldRef<"RelatedProductTranslation", 'LanguageCode'>
    readonly title: FieldRef<"RelatedProductTranslation", 'String'>
    readonly description: FieldRef<"RelatedProductTranslation", 'String'>
    readonly imageAlt: FieldRef<"RelatedProductTranslation", 'String'>
    readonly category_Alt: FieldRef<"RelatedProductTranslation", 'String'>
    readonly machineType: FieldRef<"RelatedProductTranslation", 'MachineType'>
    readonly relatedProductId: FieldRef<"RelatedProductTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RelatedProductTranslation findUnique
   */
  export type RelatedProductTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProductTranslation to fetch.
     */
    where: RelatedProductTranslationWhereUniqueInput
  }

  /**
   * RelatedProductTranslation findUniqueOrThrow
   */
  export type RelatedProductTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProductTranslation to fetch.
     */
    where: RelatedProductTranslationWhereUniqueInput
  }

  /**
   * RelatedProductTranslation findFirst
   */
  export type RelatedProductTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProductTranslation to fetch.
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProductTranslations to fetch.
     */
    orderBy?: RelatedProductTranslationOrderByWithRelationInput | RelatedProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedProductTranslations.
     */
    cursor?: RelatedProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedProductTranslations.
     */
    distinct?: RelatedProductTranslationScalarFieldEnum | RelatedProductTranslationScalarFieldEnum[]
  }

  /**
   * RelatedProductTranslation findFirstOrThrow
   */
  export type RelatedProductTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProductTranslation to fetch.
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProductTranslations to fetch.
     */
    orderBy?: RelatedProductTranslationOrderByWithRelationInput | RelatedProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelatedProductTranslations.
     */
    cursor?: RelatedProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelatedProductTranslations.
     */
    distinct?: RelatedProductTranslationScalarFieldEnum | RelatedProductTranslationScalarFieldEnum[]
  }

  /**
   * RelatedProductTranslation findMany
   */
  export type RelatedProductTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which RelatedProductTranslations to fetch.
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelatedProductTranslations to fetch.
     */
    orderBy?: RelatedProductTranslationOrderByWithRelationInput | RelatedProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelatedProductTranslations.
     */
    cursor?: RelatedProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelatedProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelatedProductTranslations.
     */
    skip?: number
    distinct?: RelatedProductTranslationScalarFieldEnum | RelatedProductTranslationScalarFieldEnum[]
  }

  /**
   * RelatedProductTranslation create
   */
  export type RelatedProductTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a RelatedProductTranslation.
     */
    data: XOR<RelatedProductTranslationCreateInput, RelatedProductTranslationUncheckedCreateInput>
  }

  /**
   * RelatedProductTranslation createMany
   */
  export type RelatedProductTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelatedProductTranslations.
     */
    data: RelatedProductTranslationCreateManyInput | RelatedProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelatedProductTranslation createManyAndReturn
   */
  export type RelatedProductTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many RelatedProductTranslations.
     */
    data: RelatedProductTranslationCreateManyInput | RelatedProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedProductTranslation update
   */
  export type RelatedProductTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a RelatedProductTranslation.
     */
    data: XOR<RelatedProductTranslationUpdateInput, RelatedProductTranslationUncheckedUpdateInput>
    /**
     * Choose, which RelatedProductTranslation to update.
     */
    where: RelatedProductTranslationWhereUniqueInput
  }

  /**
   * RelatedProductTranslation updateMany
   */
  export type RelatedProductTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelatedProductTranslations.
     */
    data: XOR<RelatedProductTranslationUpdateManyMutationInput, RelatedProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which RelatedProductTranslations to update
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * Limit how many RelatedProductTranslations to update.
     */
    limit?: number
  }

  /**
   * RelatedProductTranslation updateManyAndReturn
   */
  export type RelatedProductTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * The data used to update RelatedProductTranslations.
     */
    data: XOR<RelatedProductTranslationUpdateManyMutationInput, RelatedProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which RelatedProductTranslations to update
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * Limit how many RelatedProductTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelatedProductTranslation upsert
   */
  export type RelatedProductTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the RelatedProductTranslation to update in case it exists.
     */
    where: RelatedProductTranslationWhereUniqueInput
    /**
     * In case the RelatedProductTranslation found by the `where` argument doesn't exist, create a new RelatedProductTranslation with this data.
     */
    create: XOR<RelatedProductTranslationCreateInput, RelatedProductTranslationUncheckedCreateInput>
    /**
     * In case the RelatedProductTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatedProductTranslationUpdateInput, RelatedProductTranslationUncheckedUpdateInput>
  }

  /**
   * RelatedProductTranslation delete
   */
  export type RelatedProductTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
    /**
     * Filter which RelatedProductTranslation to delete.
     */
    where: RelatedProductTranslationWhereUniqueInput
  }

  /**
   * RelatedProductTranslation deleteMany
   */
  export type RelatedProductTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelatedProductTranslations to delete
     */
    where?: RelatedProductTranslationWhereInput
    /**
     * Limit how many RelatedProductTranslations to delete.
     */
    limit?: number
  }

  /**
   * RelatedProductTranslation without action
   */
  export type RelatedProductTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelatedProductTranslation
     */
    select?: RelatedProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelatedProductTranslation
     */
    omit?: RelatedProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatedProductTranslationInclude<ExtArgs> | null
  }


  /**
   * Model ProcessStep
   */

  export type AggregateProcessStep = {
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  export type ProcessStepAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProcessStepSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProcessStepMinAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    description_en: string | null
    process_image: string | null
    process_image_alt: string | null
  }

  export type ProcessStepMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    title_en: string | null
    description_en: string | null
    process_image: string | null
    process_image_alt: string | null
  }

  export type ProcessStepCountAggregateOutputType = {
    id: number
    productId: number
    title_en: number
    description_en: number
    process_image: number
    process_image_alt: number
    _all: number
  }


  export type ProcessStepAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProcessStepSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProcessStepMinAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    process_image?: true
    process_image_alt?: true
  }

  export type ProcessStepMaxAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    process_image?: true
    process_image_alt?: true
  }

  export type ProcessStepCountAggregateInputType = {
    id?: true
    productId?: true
    title_en?: true
    description_en?: true
    process_image?: true
    process_image_alt?: true
    _all?: true
  }

  export type ProcessStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessStep to aggregate.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessSteps
    **/
    _count?: true | ProcessStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessStepMaxAggregateInputType
  }

  export type GetProcessStepAggregateType<T extends ProcessStepAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessStep[P]>
      : GetScalarType<T[P], AggregateProcessStep[P]>
  }




  export type ProcessStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithAggregationInput | ProcessStepOrderByWithAggregationInput[]
    by: ProcessStepScalarFieldEnum[] | ProcessStepScalarFieldEnum
    having?: ProcessStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessStepCountAggregateInputType | true
    _avg?: ProcessStepAvgAggregateInputType
    _sum?: ProcessStepSumAggregateInputType
    _min?: ProcessStepMinAggregateInputType
    _max?: ProcessStepMaxAggregateInputType
  }

  export type ProcessStepGroupByOutputType = {
    id: number
    productId: number
    title_en: string
    description_en: string
    process_image: string | null
    process_image_alt: string | null
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  type GetProcessStepGroupByPayload<T extends ProcessStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
        }
      >
    >


  export type ProcessStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    process_image?: boolean
    process_image_alt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | ProcessStep$translationsArgs<ExtArgs>
    productTranslations?: boolean | ProcessStep$productTranslationsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    process_image?: boolean
    process_image_alt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    process_image?: boolean
    process_image_alt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectScalar = {
    id?: boolean
    productId?: boolean
    title_en?: boolean
    description_en?: boolean
    process_image?: boolean
    process_image_alt?: boolean
  }

  export type ProcessStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "title_en" | "description_en" | "process_image" | "process_image_alt", ExtArgs["result"]["processStep"]>
  export type ProcessStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    translations?: boolean | ProcessStep$translationsArgs<ExtArgs>
    productTranslations?: boolean | ProcessStep$productTranslationsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProcessStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProcessStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessStep"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      translations: Prisma.$ProcessStepTranslationPayload<ExtArgs>[]
      productTranslations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      title_en: string
      description_en: string
      process_image: string | null
      process_image_alt: string | null
    }, ExtArgs["result"]["processStep"]>
    composites: {}
  }

  type ProcessStepGetPayload<S extends boolean | null | undefined | ProcessStepDefaultArgs> = $Result.GetResult<Prisma.$ProcessStepPayload, S>

  type ProcessStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessStepCountAggregateInputType | true
    }

  export interface ProcessStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessStep'], meta: { name: 'ProcessStep' } }
    /**
     * Find zero or one ProcessStep that matches the filter.
     * @param {ProcessStepFindUniqueArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessStepFindUniqueArgs>(args: SelectSubset<T, ProcessStepFindUniqueArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessStepFindUniqueOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessStepFindFirstArgs>(args?: SelectSubset<T, ProcessStepFindFirstArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessSteps
     * const processSteps = await prisma.processStep.findMany()
     * 
     * // Get first 10 ProcessSteps
     * const processSteps = await prisma.processStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processStepWithIdOnly = await prisma.processStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessStepFindManyArgs>(args?: SelectSubset<T, ProcessStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessStep.
     * @param {ProcessStepCreateArgs} args - Arguments to create a ProcessStep.
     * @example
     * // Create one ProcessStep
     * const ProcessStep = await prisma.processStep.create({
     *   data: {
     *     // ... data to create a ProcessStep
     *   }
     * })
     * 
     */
    create<T extends ProcessStepCreateArgs>(args: SelectSubset<T, ProcessStepCreateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessSteps.
     * @param {ProcessStepCreateManyArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessStepCreateManyArgs>(args?: SelectSubset<T, ProcessStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessSteps and returns the data saved in the database.
     * @param {ProcessStepCreateManyAndReturnArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessSteps and only return the `id`
     * const processStepWithIdOnly = await prisma.processStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessStep.
     * @param {ProcessStepDeleteArgs} args - Arguments to delete one ProcessStep.
     * @example
     * // Delete one ProcessStep
     * const ProcessStep = await prisma.processStep.delete({
     *   where: {
     *     // ... filter to delete one ProcessStep
     *   }
     * })
     * 
     */
    delete<T extends ProcessStepDeleteArgs>(args: SelectSubset<T, ProcessStepDeleteArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessStep.
     * @param {ProcessStepUpdateArgs} args - Arguments to update one ProcessStep.
     * @example
     * // Update one ProcessStep
     * const processStep = await prisma.processStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessStepUpdateArgs>(args: SelectSubset<T, ProcessStepUpdateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessSteps.
     * @param {ProcessStepDeleteManyArgs} args - Arguments to filter ProcessSteps to delete.
     * @example
     * // Delete a few ProcessSteps
     * const { count } = await prisma.processStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessStepDeleteManyArgs>(args?: SelectSubset<T, ProcessStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessSteps
     * const processStep = await prisma.processStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessStepUpdateManyArgs>(args: SelectSubset<T, ProcessStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSteps and returns the data updated in the database.
     * @param {ProcessStepUpdateManyAndReturnArgs} args - Arguments to update many ProcessSteps.
     * @example
     * // Update many ProcessSteps
     * const processStep = await prisma.processStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessSteps and only return the `id`
     * const processStepWithIdOnly = await prisma.processStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessStep.
     * @param {ProcessStepUpsertArgs} args - Arguments to update or create a ProcessStep.
     * @example
     * // Update or create a ProcessStep
     * const processStep = await prisma.processStep.upsert({
     *   create: {
     *     // ... data to create a ProcessStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessStep we want to update
     *   }
     * })
     */
    upsert<T extends ProcessStepUpsertArgs>(args: SelectSubset<T, ProcessStepUpsertArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepCountArgs} args - Arguments to filter ProcessSteps to count.
     * @example
     * // Count the number of ProcessSteps
     * const count = await prisma.processStep.count({
     *   where: {
     *     // ... the filter for the ProcessSteps we want to count
     *   }
     * })
    **/
    count<T extends ProcessStepCountArgs>(
      args?: Subset<T, ProcessStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessStepAggregateArgs>(args: Subset<T, ProcessStepAggregateArgs>): Prisma.PrismaPromise<GetProcessStepAggregateType<T>>

    /**
     * Group by ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessStepGroupByArgs['orderBy'] }
        : { orderBy?: ProcessStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessStep model
   */
  readonly fields: ProcessStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    translations<T extends ProcessStep$translationsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productTranslations<T extends ProcessStep$productTranslationsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$productTranslationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessStep model
   */
  interface ProcessStepFieldRefs {
    readonly id: FieldRef<"ProcessStep", 'Int'>
    readonly productId: FieldRef<"ProcessStep", 'Int'>
    readonly title_en: FieldRef<"ProcessStep", 'String'>
    readonly description_en: FieldRef<"ProcessStep", 'String'>
    readonly process_image: FieldRef<"ProcessStep", 'String'>
    readonly process_image_alt: FieldRef<"ProcessStep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessStep findUnique
   */
  export type ProcessStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findUniqueOrThrow
   */
  export type ProcessStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findFirst
   */
  export type ProcessStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findFirstOrThrow
   */
  export type ProcessStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findMany
   */
  export type ProcessStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessSteps to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep create
   */
  export type ProcessStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessStep.
     */
    data: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
  }

  /**
   * ProcessStep createMany
   */
  export type ProcessStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessStep createManyAndReturn
   */
  export type ProcessStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStep update
   */
  export type ProcessStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessStep.
     */
    data: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
    /**
     * Choose, which ProcessStep to update.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep updateMany
   */
  export type ProcessStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessSteps.
     */
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSteps to update
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to update.
     */
    limit?: number
  }

  /**
   * ProcessStep updateManyAndReturn
   */
  export type ProcessStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * The data used to update ProcessSteps.
     */
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSteps to update
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStep upsert
   */
  export type ProcessStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessStep to update in case it exists.
     */
    where: ProcessStepWhereUniqueInput
    /**
     * In case the ProcessStep found by the `where` argument doesn't exist, create a new ProcessStep with this data.
     */
    create: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
    /**
     * In case the ProcessStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
  }

  /**
   * ProcessStep delete
   */
  export type ProcessStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter which ProcessStep to delete.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep deleteMany
   */
  export type ProcessStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessSteps to delete
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to delete.
     */
    limit?: number
  }

  /**
   * ProcessStep.translations
   */
  export type ProcessStep$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    where?: ProcessStepTranslationWhereInput
    orderBy?: ProcessStepTranslationOrderByWithRelationInput | ProcessStepTranslationOrderByWithRelationInput[]
    cursor?: ProcessStepTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepTranslationScalarFieldEnum | ProcessStepTranslationScalarFieldEnum[]
  }

  /**
   * ProcessStep.productTranslations
   */
  export type ProcessStep$productTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTranslation
     */
    omit?: ProductTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProcessStep without action
   */
  export type ProcessStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
  }


  /**
   * Model ProcessStepTranslation
   */

  export type AggregateProcessStepTranslation = {
    _count: ProcessStepTranslationCountAggregateOutputType | null
    _avg: ProcessStepTranslationAvgAggregateOutputType | null
    _sum: ProcessStepTranslationSumAggregateOutputType | null
    _min: ProcessStepTranslationMinAggregateOutputType | null
    _max: ProcessStepTranslationMaxAggregateOutputType | null
  }

  export type ProcessStepTranslationAvgAggregateOutputType = {
    id: number | null
    processStepId: number | null
  }

  export type ProcessStepTranslationSumAggregateOutputType = {
    id: number | null
    processStepId: number | null
  }

  export type ProcessStepTranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    description: string | null
    processStepId: number | null
  }

  export type ProcessStepTranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    title: string | null
    description: string | null
    processStepId: number | null
  }

  export type ProcessStepTranslationCountAggregateOutputType = {
    id: number
    language: number
    title: number
    description: number
    processStepId: number
    _all: number
  }


  export type ProcessStepTranslationAvgAggregateInputType = {
    id?: true
    processStepId?: true
  }

  export type ProcessStepTranslationSumAggregateInputType = {
    id?: true
    processStepId?: true
  }

  export type ProcessStepTranslationMinAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    processStepId?: true
  }

  export type ProcessStepTranslationMaxAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    processStepId?: true
  }

  export type ProcessStepTranslationCountAggregateInputType = {
    id?: true
    language?: true
    title?: true
    description?: true
    processStepId?: true
    _all?: true
  }

  export type ProcessStepTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessStepTranslation to aggregate.
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessStepTranslations to fetch.
     */
    orderBy?: ProcessStepTranslationOrderByWithRelationInput | ProcessStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessStepTranslations
    **/
    _count?: true | ProcessStepTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessStepTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessStepTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessStepTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessStepTranslationMaxAggregateInputType
  }

  export type GetProcessStepTranslationAggregateType<T extends ProcessStepTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessStepTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessStepTranslation[P]>
      : GetScalarType<T[P], AggregateProcessStepTranslation[P]>
  }




  export type ProcessStepTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepTranslationWhereInput
    orderBy?: ProcessStepTranslationOrderByWithAggregationInput | ProcessStepTranslationOrderByWithAggregationInput[]
    by: ProcessStepTranslationScalarFieldEnum[] | ProcessStepTranslationScalarFieldEnum
    having?: ProcessStepTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessStepTranslationCountAggregateInputType | true
    _avg?: ProcessStepTranslationAvgAggregateInputType
    _sum?: ProcessStepTranslationSumAggregateInputType
    _min?: ProcessStepTranslationMinAggregateInputType
    _max?: ProcessStepTranslationMaxAggregateInputType
  }

  export type ProcessStepTranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    title: string
    description: string
    processStepId: number
    _count: ProcessStepTranslationCountAggregateOutputType | null
    _avg: ProcessStepTranslationAvgAggregateOutputType | null
    _sum: ProcessStepTranslationSumAggregateOutputType | null
    _min: ProcessStepTranslationMinAggregateOutputType | null
    _max: ProcessStepTranslationMaxAggregateOutputType | null
  }

  type GetProcessStepTranslationGroupByPayload<T extends ProcessStepTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessStepTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessStepTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessStepTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessStepTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ProcessStepTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    processStepId?: boolean
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStepTranslation"]>

  export type ProcessStepTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    processStepId?: boolean
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStepTranslation"]>

  export type ProcessStepTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    processStepId?: boolean
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStepTranslation"]>

  export type ProcessStepTranslationSelectScalar = {
    id?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    processStepId?: boolean
  }

  export type ProcessStepTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "title" | "description" | "processStepId", ExtArgs["result"]["processStepTranslation"]>
  export type ProcessStepTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }
  export type ProcessStepTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }
  export type ProcessStepTranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processStep?: boolean | ProcessStepDefaultArgs<ExtArgs>
  }

  export type $ProcessStepTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessStepTranslation"
    objects: {
      processStep: Prisma.$ProcessStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      title: string
      description: string
      processStepId: number
    }, ExtArgs["result"]["processStepTranslation"]>
    composites: {}
  }

  type ProcessStepTranslationGetPayload<S extends boolean | null | undefined | ProcessStepTranslationDefaultArgs> = $Result.GetResult<Prisma.$ProcessStepTranslationPayload, S>

  type ProcessStepTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessStepTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessStepTranslationCountAggregateInputType | true
    }

  export interface ProcessStepTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessStepTranslation'], meta: { name: 'ProcessStepTranslation' } }
    /**
     * Find zero or one ProcessStepTranslation that matches the filter.
     * @param {ProcessStepTranslationFindUniqueArgs} args - Arguments to find a ProcessStepTranslation
     * @example
     * // Get one ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessStepTranslationFindUniqueArgs>(args: SelectSubset<T, ProcessStepTranslationFindUniqueArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessStepTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessStepTranslationFindUniqueOrThrowArgs} args - Arguments to find a ProcessStepTranslation
     * @example
     * // Get one ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessStepTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessStepTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStepTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationFindFirstArgs} args - Arguments to find a ProcessStepTranslation
     * @example
     * // Get one ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessStepTranslationFindFirstArgs>(args?: SelectSubset<T, ProcessStepTranslationFindFirstArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStepTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationFindFirstOrThrowArgs} args - Arguments to find a ProcessStepTranslation
     * @example
     * // Get one ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessStepTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessStepTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessStepTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessStepTranslations
     * const processStepTranslations = await prisma.processStepTranslation.findMany()
     * 
     * // Get first 10 ProcessStepTranslations
     * const processStepTranslations = await prisma.processStepTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processStepTranslationWithIdOnly = await prisma.processStepTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessStepTranslationFindManyArgs>(args?: SelectSubset<T, ProcessStepTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessStepTranslation.
     * @param {ProcessStepTranslationCreateArgs} args - Arguments to create a ProcessStepTranslation.
     * @example
     * // Create one ProcessStepTranslation
     * const ProcessStepTranslation = await prisma.processStepTranslation.create({
     *   data: {
     *     // ... data to create a ProcessStepTranslation
     *   }
     * })
     * 
     */
    create<T extends ProcessStepTranslationCreateArgs>(args: SelectSubset<T, ProcessStepTranslationCreateArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessStepTranslations.
     * @param {ProcessStepTranslationCreateManyArgs} args - Arguments to create many ProcessStepTranslations.
     * @example
     * // Create many ProcessStepTranslations
     * const processStepTranslation = await prisma.processStepTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessStepTranslationCreateManyArgs>(args?: SelectSubset<T, ProcessStepTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessStepTranslations and returns the data saved in the database.
     * @param {ProcessStepTranslationCreateManyAndReturnArgs} args - Arguments to create many ProcessStepTranslations.
     * @example
     * // Create many ProcessStepTranslations
     * const processStepTranslation = await prisma.processStepTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessStepTranslations and only return the `id`
     * const processStepTranslationWithIdOnly = await prisma.processStepTranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessStepTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessStepTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessStepTranslation.
     * @param {ProcessStepTranslationDeleteArgs} args - Arguments to delete one ProcessStepTranslation.
     * @example
     * // Delete one ProcessStepTranslation
     * const ProcessStepTranslation = await prisma.processStepTranslation.delete({
     *   where: {
     *     // ... filter to delete one ProcessStepTranslation
     *   }
     * })
     * 
     */
    delete<T extends ProcessStepTranslationDeleteArgs>(args: SelectSubset<T, ProcessStepTranslationDeleteArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessStepTranslation.
     * @param {ProcessStepTranslationUpdateArgs} args - Arguments to update one ProcessStepTranslation.
     * @example
     * // Update one ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessStepTranslationUpdateArgs>(args: SelectSubset<T, ProcessStepTranslationUpdateArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessStepTranslations.
     * @param {ProcessStepTranslationDeleteManyArgs} args - Arguments to filter ProcessStepTranslations to delete.
     * @example
     * // Delete a few ProcessStepTranslations
     * const { count } = await prisma.processStepTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessStepTranslationDeleteManyArgs>(args?: SelectSubset<T, ProcessStepTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessStepTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessStepTranslations
     * const processStepTranslation = await prisma.processStepTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessStepTranslationUpdateManyArgs>(args: SelectSubset<T, ProcessStepTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessStepTranslations and returns the data updated in the database.
     * @param {ProcessStepTranslationUpdateManyAndReturnArgs} args - Arguments to update many ProcessStepTranslations.
     * @example
     * // Update many ProcessStepTranslations
     * const processStepTranslation = await prisma.processStepTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessStepTranslations and only return the `id`
     * const processStepTranslationWithIdOnly = await prisma.processStepTranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessStepTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessStepTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessStepTranslation.
     * @param {ProcessStepTranslationUpsertArgs} args - Arguments to update or create a ProcessStepTranslation.
     * @example
     * // Update or create a ProcessStepTranslation
     * const processStepTranslation = await prisma.processStepTranslation.upsert({
     *   create: {
     *     // ... data to create a ProcessStepTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessStepTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ProcessStepTranslationUpsertArgs>(args: SelectSubset<T, ProcessStepTranslationUpsertArgs<ExtArgs>>): Prisma__ProcessStepTranslationClient<$Result.GetResult<Prisma.$ProcessStepTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessStepTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationCountArgs} args - Arguments to filter ProcessStepTranslations to count.
     * @example
     * // Count the number of ProcessStepTranslations
     * const count = await prisma.processStepTranslation.count({
     *   where: {
     *     // ... the filter for the ProcessStepTranslations we want to count
     *   }
     * })
    **/
    count<T extends ProcessStepTranslationCountArgs>(
      args?: Subset<T, ProcessStepTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessStepTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessStepTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessStepTranslationAggregateArgs>(args: Subset<T, ProcessStepTranslationAggregateArgs>): Prisma.PrismaPromise<GetProcessStepTranslationAggregateType<T>>

    /**
     * Group by ProcessStepTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessStepTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessStepTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ProcessStepTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessStepTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessStepTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessStepTranslation model
   */
  readonly fields: ProcessStepTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessStepTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessStepTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processStep<T extends ProcessStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStepDefaultArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessStepTranslation model
   */
  interface ProcessStepTranslationFieldRefs {
    readonly id: FieldRef<"ProcessStepTranslation", 'Int'>
    readonly language: FieldRef<"ProcessStepTranslation", 'LanguageCode'>
    readonly title: FieldRef<"ProcessStepTranslation", 'String'>
    readonly description: FieldRef<"ProcessStepTranslation", 'String'>
    readonly processStepId: FieldRef<"ProcessStepTranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProcessStepTranslation findUnique
   */
  export type ProcessStepTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStepTranslation to fetch.
     */
    where: ProcessStepTranslationWhereUniqueInput
  }

  /**
   * ProcessStepTranslation findUniqueOrThrow
   */
  export type ProcessStepTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStepTranslation to fetch.
     */
    where: ProcessStepTranslationWhereUniqueInput
  }

  /**
   * ProcessStepTranslation findFirst
   */
  export type ProcessStepTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStepTranslation to fetch.
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessStepTranslations to fetch.
     */
    orderBy?: ProcessStepTranslationOrderByWithRelationInput | ProcessStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessStepTranslations.
     */
    cursor?: ProcessStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessStepTranslations.
     */
    distinct?: ProcessStepTranslationScalarFieldEnum | ProcessStepTranslationScalarFieldEnum[]
  }

  /**
   * ProcessStepTranslation findFirstOrThrow
   */
  export type ProcessStepTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStepTranslation to fetch.
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessStepTranslations to fetch.
     */
    orderBy?: ProcessStepTranslationOrderByWithRelationInput | ProcessStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessStepTranslations.
     */
    cursor?: ProcessStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessStepTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessStepTranslations.
     */
    distinct?: ProcessStepTranslationScalarFieldEnum | ProcessStepTranslationScalarFieldEnum[]
  }

  /**
   * ProcessStepTranslation findMany
   */
  export type ProcessStepTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStepTranslations to fetch.
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessStepTranslations to fetch.
     */
    orderBy?: ProcessStepTranslationOrderByWithRelationInput | ProcessStepTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessStepTranslations.
     */
    cursor?: ProcessStepTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessStepTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessStepTranslations.
     */
    skip?: number
    distinct?: ProcessStepTranslationScalarFieldEnum | ProcessStepTranslationScalarFieldEnum[]
  }

  /**
   * ProcessStepTranslation create
   */
  export type ProcessStepTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessStepTranslation.
     */
    data: XOR<ProcessStepTranslationCreateInput, ProcessStepTranslationUncheckedCreateInput>
  }

  /**
   * ProcessStepTranslation createMany
   */
  export type ProcessStepTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessStepTranslations.
     */
    data: ProcessStepTranslationCreateManyInput | ProcessStepTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessStepTranslation createManyAndReturn
   */
  export type ProcessStepTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessStepTranslations.
     */
    data: ProcessStepTranslationCreateManyInput | ProcessStepTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStepTranslation update
   */
  export type ProcessStepTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessStepTranslation.
     */
    data: XOR<ProcessStepTranslationUpdateInput, ProcessStepTranslationUncheckedUpdateInput>
    /**
     * Choose, which ProcessStepTranslation to update.
     */
    where: ProcessStepTranslationWhereUniqueInput
  }

  /**
   * ProcessStepTranslation updateMany
   */
  export type ProcessStepTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessStepTranslations.
     */
    data: XOR<ProcessStepTranslationUpdateManyMutationInput, ProcessStepTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProcessStepTranslations to update
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * Limit how many ProcessStepTranslations to update.
     */
    limit?: number
  }

  /**
   * ProcessStepTranslation updateManyAndReturn
   */
  export type ProcessStepTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * The data used to update ProcessStepTranslations.
     */
    data: XOR<ProcessStepTranslationUpdateManyMutationInput, ProcessStepTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProcessStepTranslations to update
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * Limit how many ProcessStepTranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStepTranslation upsert
   */
  export type ProcessStepTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessStepTranslation to update in case it exists.
     */
    where: ProcessStepTranslationWhereUniqueInput
    /**
     * In case the ProcessStepTranslation found by the `where` argument doesn't exist, create a new ProcessStepTranslation with this data.
     */
    create: XOR<ProcessStepTranslationCreateInput, ProcessStepTranslationUncheckedCreateInput>
    /**
     * In case the ProcessStepTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessStepTranslationUpdateInput, ProcessStepTranslationUncheckedUpdateInput>
  }

  /**
   * ProcessStepTranslation delete
   */
  export type ProcessStepTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
    /**
     * Filter which ProcessStepTranslation to delete.
     */
    where: ProcessStepTranslationWhereUniqueInput
  }

  /**
   * ProcessStepTranslation deleteMany
   */
  export type ProcessStepTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessStepTranslations to delete
     */
    where?: ProcessStepTranslationWhereInput
    /**
     * Limit how many ProcessStepTranslations to delete.
     */
    limit?: number
  }

  /**
   * ProcessStepTranslation without action
   */
  export type ProcessStepTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepTranslation
     */
    select?: ProcessStepTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStepTranslation
     */
    omit?: ProcessStepTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepTranslationInclude<ExtArgs> | null
  }


  /**
   * Model CTA
   */

  export type AggregateCTA = {
    _count: CTACountAggregateOutputType | null
    _avg: CTAAvgAggregateOutputType | null
    _sum: CTASumAggregateOutputType | null
    _min: CTAMinAggregateOutputType | null
    _max: CTAMaxAggregateOutputType | null
  }

  export type CTAAvgAggregateOutputType = {
    id: number | null
  }

  export type CTASumAggregateOutputType = {
    id: number | null
  }

  export type CTAMinAggregateOutputType = {
    id: number | null
    text_en: string | null
    description_en: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CTAMaxAggregateOutputType = {
    id: number | null
    text_en: string | null
    description_en: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CTACountAggregateOutputType = {
    id: number
    text_en: number
    description_en: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CTAAvgAggregateInputType = {
    id?: true
  }

  export type CTASumAggregateInputType = {
    id?: true
  }

  export type CTAMinAggregateInputType = {
    id?: true
    text_en?: true
    description_en?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CTAMaxAggregateInputType = {
    id?: true
    text_en?: true
    description_en?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CTACountAggregateInputType = {
    id?: true
    text_en?: true
    description_en?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CTAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTA to aggregate.
     */
    where?: CTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTAS to fetch.
     */
    orderBy?: CTAOrderByWithRelationInput | CTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CTAS
    **/
    _count?: true | CTACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CTAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CTASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CTAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CTAMaxAggregateInputType
  }

  export type GetCTAAggregateType<T extends CTAAggregateArgs> = {
        [P in keyof T & keyof AggregateCTA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCTA[P]>
      : GetScalarType<T[P], AggregateCTA[P]>
  }




  export type CTAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CTAWhereInput
    orderBy?: CTAOrderByWithAggregationInput | CTAOrderByWithAggregationInput[]
    by: CTAScalarFieldEnum[] | CTAScalarFieldEnum
    having?: CTAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CTACountAggregateInputType | true
    _avg?: CTAAvgAggregateInputType
    _sum?: CTASumAggregateInputType
    _min?: CTAMinAggregateInputType
    _max?: CTAMaxAggregateInputType
  }

  export type CTAGroupByOutputType = {
    id: number
    text_en: string
    description_en: string | null
    createdAt: Date
    updatedAt: Date
    _count: CTACountAggregateOutputType | null
    _avg: CTAAvgAggregateOutputType | null
    _sum: CTASumAggregateOutputType | null
    _min: CTAMinAggregateOutputType | null
    _max: CTAMaxAggregateOutputType | null
  }

  type GetCTAGroupByPayload<T extends CTAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CTAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CTAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CTAGroupByOutputType[P]>
            : GetScalarType<T[P], CTAGroupByOutputType[P]>
        }
      >
    >


  export type CTASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text_en?: boolean
    description_en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | CTA$translationsArgs<ExtArgs>
    _count?: boolean | CTACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTA"]>

  export type CTASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text_en?: boolean
    description_en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cTA"]>

  export type CTASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text_en?: boolean
    description_en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cTA"]>

  export type CTASelectScalar = {
    id?: boolean
    text_en?: boolean
    description_en?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CTAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text_en" | "description_en" | "createdAt" | "updatedAt", ExtArgs["result"]["cTA"]>
  export type CTAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | CTA$translationsArgs<ExtArgs>
    _count?: boolean | CTACountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CTAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CTAIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CTAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CTA"
    objects: {
      translations: Prisma.$CTATranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text_en: string
      description_en: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cTA"]>
    composites: {}
  }

  type CTAGetPayload<S extends boolean | null | undefined | CTADefaultArgs> = $Result.GetResult<Prisma.$CTAPayload, S>

  type CTACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CTAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CTACountAggregateInputType | true
    }

  export interface CTADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CTA'], meta: { name: 'CTA' } }
    /**
     * Find zero or one CTA that matches the filter.
     * @param {CTAFindUniqueArgs} args - Arguments to find a CTA
     * @example
     * // Get one CTA
     * const cTA = await prisma.cTA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CTAFindUniqueArgs>(args: SelectSubset<T, CTAFindUniqueArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CTA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CTAFindUniqueOrThrowArgs} args - Arguments to find a CTA
     * @example
     * // Get one CTA
     * const cTA = await prisma.cTA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CTAFindUniqueOrThrowArgs>(args: SelectSubset<T, CTAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAFindFirstArgs} args - Arguments to find a CTA
     * @example
     * // Get one CTA
     * const cTA = await prisma.cTA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CTAFindFirstArgs>(args?: SelectSubset<T, CTAFindFirstArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAFindFirstOrThrowArgs} args - Arguments to find a CTA
     * @example
     * // Get one CTA
     * const cTA = await prisma.cTA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CTAFindFirstOrThrowArgs>(args?: SelectSubset<T, CTAFindFirstOrThrowArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CTAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CTAS
     * const cTAS = await prisma.cTA.findMany()
     * 
     * // Get first 10 CTAS
     * const cTAS = await prisma.cTA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cTAWithIdOnly = await prisma.cTA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CTAFindManyArgs>(args?: SelectSubset<T, CTAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CTA.
     * @param {CTACreateArgs} args - Arguments to create a CTA.
     * @example
     * // Create one CTA
     * const CTA = await prisma.cTA.create({
     *   data: {
     *     // ... data to create a CTA
     *   }
     * })
     * 
     */
    create<T extends CTACreateArgs>(args: SelectSubset<T, CTACreateArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CTAS.
     * @param {CTACreateManyArgs} args - Arguments to create many CTAS.
     * @example
     * // Create many CTAS
     * const cTA = await prisma.cTA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CTACreateManyArgs>(args?: SelectSubset<T, CTACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CTAS and returns the data saved in the database.
     * @param {CTACreateManyAndReturnArgs} args - Arguments to create many CTAS.
     * @example
     * // Create many CTAS
     * const cTA = await prisma.cTA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CTAS and only return the `id`
     * const cTAWithIdOnly = await prisma.cTA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CTACreateManyAndReturnArgs>(args?: SelectSubset<T, CTACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CTA.
     * @param {CTADeleteArgs} args - Arguments to delete one CTA.
     * @example
     * // Delete one CTA
     * const CTA = await prisma.cTA.delete({
     *   where: {
     *     // ... filter to delete one CTA
     *   }
     * })
     * 
     */
    delete<T extends CTADeleteArgs>(args: SelectSubset<T, CTADeleteArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CTA.
     * @param {CTAUpdateArgs} args - Arguments to update one CTA.
     * @example
     * // Update one CTA
     * const cTA = await prisma.cTA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CTAUpdateArgs>(args: SelectSubset<T, CTAUpdateArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CTAS.
     * @param {CTADeleteManyArgs} args - Arguments to filter CTAS to delete.
     * @example
     * // Delete a few CTAS
     * const { count } = await prisma.cTA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CTADeleteManyArgs>(args?: SelectSubset<T, CTADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CTAS
     * const cTA = await prisma.cTA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CTAUpdateManyArgs>(args: SelectSubset<T, CTAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTAS and returns the data updated in the database.
     * @param {CTAUpdateManyAndReturnArgs} args - Arguments to update many CTAS.
     * @example
     * // Update many CTAS
     * const cTA = await prisma.cTA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CTAS and only return the `id`
     * const cTAWithIdOnly = await prisma.cTA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CTAUpdateManyAndReturnArgs>(args: SelectSubset<T, CTAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CTA.
     * @param {CTAUpsertArgs} args - Arguments to update or create a CTA.
     * @example
     * // Update or create a CTA
     * const cTA = await prisma.cTA.upsert({
     *   create: {
     *     // ... data to create a CTA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CTA we want to update
     *   }
     * })
     */
    upsert<T extends CTAUpsertArgs>(args: SelectSubset<T, CTAUpsertArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTACountArgs} args - Arguments to filter CTAS to count.
     * @example
     * // Count the number of CTAS
     * const count = await prisma.cTA.count({
     *   where: {
     *     // ... the filter for the CTAS we want to count
     *   }
     * })
    **/
    count<T extends CTACountArgs>(
      args?: Subset<T, CTACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CTACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CTAAggregateArgs>(args: Subset<T, CTAAggregateArgs>): Prisma.PrismaPromise<GetCTAAggregateType<T>>

    /**
     * Group by CTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CTAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CTAGroupByArgs['orderBy'] }
        : { orderBy?: CTAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CTAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCTAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CTA model
   */
  readonly fields: CTAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CTA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CTAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends CTA$translationsArgs<ExtArgs> = {}>(args?: Subset<T, CTA$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CTA model
   */
  interface CTAFieldRefs {
    readonly id: FieldRef<"CTA", 'Int'>
    readonly text_en: FieldRef<"CTA", 'String'>
    readonly description_en: FieldRef<"CTA", 'String'>
    readonly createdAt: FieldRef<"CTA", 'DateTime'>
    readonly updatedAt: FieldRef<"CTA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CTA findUnique
   */
  export type CTAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter, which CTA to fetch.
     */
    where: CTAWhereUniqueInput
  }

  /**
   * CTA findUniqueOrThrow
   */
  export type CTAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter, which CTA to fetch.
     */
    where: CTAWhereUniqueInput
  }

  /**
   * CTA findFirst
   */
  export type CTAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter, which CTA to fetch.
     */
    where?: CTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTAS to fetch.
     */
    orderBy?: CTAOrderByWithRelationInput | CTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTAS.
     */
    cursor?: CTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTAS.
     */
    distinct?: CTAScalarFieldEnum | CTAScalarFieldEnum[]
  }

  /**
   * CTA findFirstOrThrow
   */
  export type CTAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter, which CTA to fetch.
     */
    where?: CTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTAS to fetch.
     */
    orderBy?: CTAOrderByWithRelationInput | CTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTAS.
     */
    cursor?: CTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTAS.
     */
    distinct?: CTAScalarFieldEnum | CTAScalarFieldEnum[]
  }

  /**
   * CTA findMany
   */
  export type CTAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter, which CTAS to fetch.
     */
    where?: CTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTAS to fetch.
     */
    orderBy?: CTAOrderByWithRelationInput | CTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CTAS.
     */
    cursor?: CTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTAS.
     */
    skip?: number
    distinct?: CTAScalarFieldEnum | CTAScalarFieldEnum[]
  }

  /**
   * CTA create
   */
  export type CTACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * The data needed to create a CTA.
     */
    data: XOR<CTACreateInput, CTAUncheckedCreateInput>
  }

  /**
   * CTA createMany
   */
  export type CTACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CTAS.
     */
    data: CTACreateManyInput | CTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CTA createManyAndReturn
   */
  export type CTACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * The data used to create many CTAS.
     */
    data: CTACreateManyInput | CTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CTA update
   */
  export type CTAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * The data needed to update a CTA.
     */
    data: XOR<CTAUpdateInput, CTAUncheckedUpdateInput>
    /**
     * Choose, which CTA to update.
     */
    where: CTAWhereUniqueInput
  }

  /**
   * CTA updateMany
   */
  export type CTAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CTAS.
     */
    data: XOR<CTAUpdateManyMutationInput, CTAUncheckedUpdateManyInput>
    /**
     * Filter which CTAS to update
     */
    where?: CTAWhereInput
    /**
     * Limit how many CTAS to update.
     */
    limit?: number
  }

  /**
   * CTA updateManyAndReturn
   */
  export type CTAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * The data used to update CTAS.
     */
    data: XOR<CTAUpdateManyMutationInput, CTAUncheckedUpdateManyInput>
    /**
     * Filter which CTAS to update
     */
    where?: CTAWhereInput
    /**
     * Limit how many CTAS to update.
     */
    limit?: number
  }

  /**
   * CTA upsert
   */
  export type CTAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * The filter to search for the CTA to update in case it exists.
     */
    where: CTAWhereUniqueInput
    /**
     * In case the CTA found by the `where` argument doesn't exist, create a new CTA with this data.
     */
    create: XOR<CTACreateInput, CTAUncheckedCreateInput>
    /**
     * In case the CTA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CTAUpdateInput, CTAUncheckedUpdateInput>
  }

  /**
   * CTA delete
   */
  export type CTADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
    /**
     * Filter which CTA to delete.
     */
    where: CTAWhereUniqueInput
  }

  /**
   * CTA deleteMany
   */
  export type CTADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTAS to delete
     */
    where?: CTAWhereInput
    /**
     * Limit how many CTAS to delete.
     */
    limit?: number
  }

  /**
   * CTA.translations
   */
  export type CTA$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    where?: CTATranslationWhereInput
    orderBy?: CTATranslationOrderByWithRelationInput | CTATranslationOrderByWithRelationInput[]
    cursor?: CTATranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CTATranslationScalarFieldEnum | CTATranslationScalarFieldEnum[]
  }

  /**
   * CTA without action
   */
  export type CTADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTA
     */
    select?: CTASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTA
     */
    omit?: CTAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTAInclude<ExtArgs> | null
  }


  /**
   * Model CTATranslation
   */

  export type AggregateCTATranslation = {
    _count: CTATranslationCountAggregateOutputType | null
    _avg: CTATranslationAvgAggregateOutputType | null
    _sum: CTATranslationSumAggregateOutputType | null
    _min: CTATranslationMinAggregateOutputType | null
    _max: CTATranslationMaxAggregateOutputType | null
  }

  export type CTATranslationAvgAggregateOutputType = {
    id: number | null
    ctaId: number | null
  }

  export type CTATranslationSumAggregateOutputType = {
    id: number | null
    ctaId: number | null
  }

  export type CTATranslationMinAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    text: string | null
    description: string | null
    ctaId: number | null
  }

  export type CTATranslationMaxAggregateOutputType = {
    id: number | null
    language: $Enums.LanguageCode | null
    text: string | null
    description: string | null
    ctaId: number | null
  }

  export type CTATranslationCountAggregateOutputType = {
    id: number
    language: number
    text: number
    description: number
    ctaId: number
    _all: number
  }


  export type CTATranslationAvgAggregateInputType = {
    id?: true
    ctaId?: true
  }

  export type CTATranslationSumAggregateInputType = {
    id?: true
    ctaId?: true
  }

  export type CTATranslationMinAggregateInputType = {
    id?: true
    language?: true
    text?: true
    description?: true
    ctaId?: true
  }

  export type CTATranslationMaxAggregateInputType = {
    id?: true
    language?: true
    text?: true
    description?: true
    ctaId?: true
  }

  export type CTATranslationCountAggregateInputType = {
    id?: true
    language?: true
    text?: true
    description?: true
    ctaId?: true
    _all?: true
  }

  export type CTATranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTATranslation to aggregate.
     */
    where?: CTATranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTATranslations to fetch.
     */
    orderBy?: CTATranslationOrderByWithRelationInput | CTATranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CTATranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTATranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTATranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CTATranslations
    **/
    _count?: true | CTATranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CTATranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CTATranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CTATranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CTATranslationMaxAggregateInputType
  }

  export type GetCTATranslationAggregateType<T extends CTATranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCTATranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCTATranslation[P]>
      : GetScalarType<T[P], AggregateCTATranslation[P]>
  }




  export type CTATranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CTATranslationWhereInput
    orderBy?: CTATranslationOrderByWithAggregationInput | CTATranslationOrderByWithAggregationInput[]
    by: CTATranslationScalarFieldEnum[] | CTATranslationScalarFieldEnum
    having?: CTATranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CTATranslationCountAggregateInputType | true
    _avg?: CTATranslationAvgAggregateInputType
    _sum?: CTATranslationSumAggregateInputType
    _min?: CTATranslationMinAggregateInputType
    _max?: CTATranslationMaxAggregateInputType
  }

  export type CTATranslationGroupByOutputType = {
    id: number
    language: $Enums.LanguageCode
    text: string
    description: string | null
    ctaId: number
    _count: CTATranslationCountAggregateOutputType | null
    _avg: CTATranslationAvgAggregateOutputType | null
    _sum: CTATranslationSumAggregateOutputType | null
    _min: CTATranslationMinAggregateOutputType | null
    _max: CTATranslationMaxAggregateOutputType | null
  }

  type GetCTATranslationGroupByPayload<T extends CTATranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CTATranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CTATranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CTATranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CTATranslationGroupByOutputType[P]>
        }
      >
    >


  export type CTATranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    text?: boolean
    description?: boolean
    ctaId?: boolean
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTATranslation"]>

  export type CTATranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    text?: boolean
    description?: boolean
    ctaId?: boolean
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTATranslation"]>

  export type CTATranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    text?: boolean
    description?: boolean
    ctaId?: boolean
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTATranslation"]>

  export type CTATranslationSelectScalar = {
    id?: boolean
    language?: boolean
    text?: boolean
    description?: boolean
    ctaId?: boolean
  }

  export type CTATranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "text" | "description" | "ctaId", ExtArgs["result"]["cTATranslation"]>
  export type CTATranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }
  export type CTATranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }
  export type CTATranslationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cta?: boolean | CTADefaultArgs<ExtArgs>
  }

  export type $CTATranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CTATranslation"
    objects: {
      cta: Prisma.$CTAPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: $Enums.LanguageCode
      text: string
      description: string | null
      ctaId: number
    }, ExtArgs["result"]["cTATranslation"]>
    composites: {}
  }

  type CTATranslationGetPayload<S extends boolean | null | undefined | CTATranslationDefaultArgs> = $Result.GetResult<Prisma.$CTATranslationPayload, S>

  type CTATranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CTATranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CTATranslationCountAggregateInputType | true
    }

  export interface CTATranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CTATranslation'], meta: { name: 'CTATranslation' } }
    /**
     * Find zero or one CTATranslation that matches the filter.
     * @param {CTATranslationFindUniqueArgs} args - Arguments to find a CTATranslation
     * @example
     * // Get one CTATranslation
     * const cTATranslation = await prisma.cTATranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CTATranslationFindUniqueArgs>(args: SelectSubset<T, CTATranslationFindUniqueArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CTATranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CTATranslationFindUniqueOrThrowArgs} args - Arguments to find a CTATranslation
     * @example
     * // Get one CTATranslation
     * const cTATranslation = await prisma.cTATranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CTATranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, CTATranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTATranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationFindFirstArgs} args - Arguments to find a CTATranslation
     * @example
     * // Get one CTATranslation
     * const cTATranslation = await prisma.cTATranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CTATranslationFindFirstArgs>(args?: SelectSubset<T, CTATranslationFindFirstArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTATranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationFindFirstOrThrowArgs} args - Arguments to find a CTATranslation
     * @example
     * // Get one CTATranslation
     * const cTATranslation = await prisma.cTATranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CTATranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, CTATranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CTATranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CTATranslations
     * const cTATranslations = await prisma.cTATranslation.findMany()
     * 
     * // Get first 10 CTATranslations
     * const cTATranslations = await prisma.cTATranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cTATranslationWithIdOnly = await prisma.cTATranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CTATranslationFindManyArgs>(args?: SelectSubset<T, CTATranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CTATranslation.
     * @param {CTATranslationCreateArgs} args - Arguments to create a CTATranslation.
     * @example
     * // Create one CTATranslation
     * const CTATranslation = await prisma.cTATranslation.create({
     *   data: {
     *     // ... data to create a CTATranslation
     *   }
     * })
     * 
     */
    create<T extends CTATranslationCreateArgs>(args: SelectSubset<T, CTATranslationCreateArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CTATranslations.
     * @param {CTATranslationCreateManyArgs} args - Arguments to create many CTATranslations.
     * @example
     * // Create many CTATranslations
     * const cTATranslation = await prisma.cTATranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CTATranslationCreateManyArgs>(args?: SelectSubset<T, CTATranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CTATranslations and returns the data saved in the database.
     * @param {CTATranslationCreateManyAndReturnArgs} args - Arguments to create many CTATranslations.
     * @example
     * // Create many CTATranslations
     * const cTATranslation = await prisma.cTATranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CTATranslations and only return the `id`
     * const cTATranslationWithIdOnly = await prisma.cTATranslation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CTATranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, CTATranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CTATranslation.
     * @param {CTATranslationDeleteArgs} args - Arguments to delete one CTATranslation.
     * @example
     * // Delete one CTATranslation
     * const CTATranslation = await prisma.cTATranslation.delete({
     *   where: {
     *     // ... filter to delete one CTATranslation
     *   }
     * })
     * 
     */
    delete<T extends CTATranslationDeleteArgs>(args: SelectSubset<T, CTATranslationDeleteArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CTATranslation.
     * @param {CTATranslationUpdateArgs} args - Arguments to update one CTATranslation.
     * @example
     * // Update one CTATranslation
     * const cTATranslation = await prisma.cTATranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CTATranslationUpdateArgs>(args: SelectSubset<T, CTATranslationUpdateArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CTATranslations.
     * @param {CTATranslationDeleteManyArgs} args - Arguments to filter CTATranslations to delete.
     * @example
     * // Delete a few CTATranslations
     * const { count } = await prisma.cTATranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CTATranslationDeleteManyArgs>(args?: SelectSubset<T, CTATranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTATranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CTATranslations
     * const cTATranslation = await prisma.cTATranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CTATranslationUpdateManyArgs>(args: SelectSubset<T, CTATranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTATranslations and returns the data updated in the database.
     * @param {CTATranslationUpdateManyAndReturnArgs} args - Arguments to update many CTATranslations.
     * @example
     * // Update many CTATranslations
     * const cTATranslation = await prisma.cTATranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CTATranslations and only return the `id`
     * const cTATranslationWithIdOnly = await prisma.cTATranslation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CTATranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, CTATranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CTATranslation.
     * @param {CTATranslationUpsertArgs} args - Arguments to update or create a CTATranslation.
     * @example
     * // Update or create a CTATranslation
     * const cTATranslation = await prisma.cTATranslation.upsert({
     *   create: {
     *     // ... data to create a CTATranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CTATranslation we want to update
     *   }
     * })
     */
    upsert<T extends CTATranslationUpsertArgs>(args: SelectSubset<T, CTATranslationUpsertArgs<ExtArgs>>): Prisma__CTATranslationClient<$Result.GetResult<Prisma.$CTATranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CTATranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationCountArgs} args - Arguments to filter CTATranslations to count.
     * @example
     * // Count the number of CTATranslations
     * const count = await prisma.cTATranslation.count({
     *   where: {
     *     // ... the filter for the CTATranslations we want to count
     *   }
     * })
    **/
    count<T extends CTATranslationCountArgs>(
      args?: Subset<T, CTATranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CTATranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CTATranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CTATranslationAggregateArgs>(args: Subset<T, CTATranslationAggregateArgs>): Prisma.PrismaPromise<GetCTATranslationAggregateType<T>>

    /**
     * Group by CTATranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTATranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CTATranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CTATranslationGroupByArgs['orderBy'] }
        : { orderBy?: CTATranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CTATranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCTATranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CTATranslation model
   */
  readonly fields: CTATranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CTATranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CTATranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cta<T extends CTADefaultArgs<ExtArgs> = {}>(args?: Subset<T, CTADefaultArgs<ExtArgs>>): Prisma__CTAClient<$Result.GetResult<Prisma.$CTAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CTATranslation model
   */
  interface CTATranslationFieldRefs {
    readonly id: FieldRef<"CTATranslation", 'Int'>
    readonly language: FieldRef<"CTATranslation", 'LanguageCode'>
    readonly text: FieldRef<"CTATranslation", 'String'>
    readonly description: FieldRef<"CTATranslation", 'String'>
    readonly ctaId: FieldRef<"CTATranslation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CTATranslation findUnique
   */
  export type CTATranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter, which CTATranslation to fetch.
     */
    where: CTATranslationWhereUniqueInput
  }

  /**
   * CTATranslation findUniqueOrThrow
   */
  export type CTATranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter, which CTATranslation to fetch.
     */
    where: CTATranslationWhereUniqueInput
  }

  /**
   * CTATranslation findFirst
   */
  export type CTATranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter, which CTATranslation to fetch.
     */
    where?: CTATranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTATranslations to fetch.
     */
    orderBy?: CTATranslationOrderByWithRelationInput | CTATranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTATranslations.
     */
    cursor?: CTATranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTATranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTATranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTATranslations.
     */
    distinct?: CTATranslationScalarFieldEnum | CTATranslationScalarFieldEnum[]
  }

  /**
   * CTATranslation findFirstOrThrow
   */
  export type CTATranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter, which CTATranslation to fetch.
     */
    where?: CTATranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTATranslations to fetch.
     */
    orderBy?: CTATranslationOrderByWithRelationInput | CTATranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTATranslations.
     */
    cursor?: CTATranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTATranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTATranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTATranslations.
     */
    distinct?: CTATranslationScalarFieldEnum | CTATranslationScalarFieldEnum[]
  }

  /**
   * CTATranslation findMany
   */
  export type CTATranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter, which CTATranslations to fetch.
     */
    where?: CTATranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTATranslations to fetch.
     */
    orderBy?: CTATranslationOrderByWithRelationInput | CTATranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CTATranslations.
     */
    cursor?: CTATranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTATranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTATranslations.
     */
    skip?: number
    distinct?: CTATranslationScalarFieldEnum | CTATranslationScalarFieldEnum[]
  }

  /**
   * CTATranslation create
   */
  export type CTATranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CTATranslation.
     */
    data: XOR<CTATranslationCreateInput, CTATranslationUncheckedCreateInput>
  }

  /**
   * CTATranslation createMany
   */
  export type CTATranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CTATranslations.
     */
    data: CTATranslationCreateManyInput | CTATranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CTATranslation createManyAndReturn
   */
  export type CTATranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * The data used to create many CTATranslations.
     */
    data: CTATranslationCreateManyInput | CTATranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CTATranslation update
   */
  export type CTATranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CTATranslation.
     */
    data: XOR<CTATranslationUpdateInput, CTATranslationUncheckedUpdateInput>
    /**
     * Choose, which CTATranslation to update.
     */
    where: CTATranslationWhereUniqueInput
  }

  /**
   * CTATranslation updateMany
   */
  export type CTATranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CTATranslations.
     */
    data: XOR<CTATranslationUpdateManyMutationInput, CTATranslationUncheckedUpdateManyInput>
    /**
     * Filter which CTATranslations to update
     */
    where?: CTATranslationWhereInput
    /**
     * Limit how many CTATranslations to update.
     */
    limit?: number
  }

  /**
   * CTATranslation updateManyAndReturn
   */
  export type CTATranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * The data used to update CTATranslations.
     */
    data: XOR<CTATranslationUpdateManyMutationInput, CTATranslationUncheckedUpdateManyInput>
    /**
     * Filter which CTATranslations to update
     */
    where?: CTATranslationWhereInput
    /**
     * Limit how many CTATranslations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CTATranslation upsert
   */
  export type CTATranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CTATranslation to update in case it exists.
     */
    where: CTATranslationWhereUniqueInput
    /**
     * In case the CTATranslation found by the `where` argument doesn't exist, create a new CTATranslation with this data.
     */
    create: XOR<CTATranslationCreateInput, CTATranslationUncheckedCreateInput>
    /**
     * In case the CTATranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CTATranslationUpdateInput, CTATranslationUncheckedUpdateInput>
  }

  /**
   * CTATranslation delete
   */
  export type CTATranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
    /**
     * Filter which CTATranslation to delete.
     */
    where: CTATranslationWhereUniqueInput
  }

  /**
   * CTATranslation deleteMany
   */
  export type CTATranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTATranslations to delete
     */
    where?: CTATranslationWhereInput
    /**
     * Limit how many CTATranslations to delete.
     */
    limit?: number
  }

  /**
   * CTATranslation without action
   */
  export type CTATranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTATranslation
     */
    select?: CTATranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTATranslation
     */
    omit?: CTATranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTATranslationInclude<ExtArgs> | null
  }


  /**
   * Model TranslationTask
   */

  export type AggregateTranslationTask = {
    _count: TranslationTaskCountAggregateOutputType | null
    _avg: TranslationTaskAvgAggregateOutputType | null
    _sum: TranslationTaskSumAggregateOutputType | null
    _min: TranslationTaskMinAggregateOutputType | null
    _max: TranslationTaskMaxAggregateOutputType | null
  }

  export type TranslationTaskAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    attempts: number | null
    apiKeyId: number | null
  }

  export type TranslationTaskSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    attempts: number | null
    apiKeyId: number | null
  }

  export type TranslationTaskMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    language: $Enums.LanguageCode | null
    status: string | null
    attempts: number | null
    lastError: string | null
    processingStartedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    apiKeyId: number | null
    apiUrl: string | null
  }

  export type TranslationTaskMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    language: $Enums.LanguageCode | null
    status: string | null
    attempts: number | null
    lastError: string | null
    processingStartedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    apiKeyId: number | null
    apiUrl: string | null
  }

  export type TranslationTaskCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    texts: number
    language: number
    status: number
    attempts: number
    lastError: number
    processingStartedAt: number
    createdAt: number
    updatedAt: number
    apiKeyId: number
    apiUrl: number
    _all: number
  }


  export type TranslationTaskAvgAggregateInputType = {
    id?: true
    entityId?: true
    attempts?: true
    apiKeyId?: true
  }

  export type TranslationTaskSumAggregateInputType = {
    id?: true
    entityId?: true
    attempts?: true
    apiKeyId?: true
  }

  export type TranslationTaskMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    language?: true
    status?: true
    attempts?: true
    lastError?: true
    processingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    apiKeyId?: true
    apiUrl?: true
  }

  export type TranslationTaskMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    language?: true
    status?: true
    attempts?: true
    lastError?: true
    processingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    apiKeyId?: true
    apiUrl?: true
  }

  export type TranslationTaskCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    texts?: true
    language?: true
    status?: true
    attempts?: true
    lastError?: true
    processingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    apiKeyId?: true
    apiUrl?: true
    _all?: true
  }

  export type TranslationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationTask to aggregate.
     */
    where?: TranslationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationTasks to fetch.
     */
    orderBy?: TranslationTaskOrderByWithRelationInput | TranslationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranslationTasks
    **/
    _count?: true | TranslationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationTaskMaxAggregateInputType
  }

  export type GetTranslationTaskAggregateType<T extends TranslationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslationTask[P]>
      : GetScalarType<T[P], AggregateTranslationTask[P]>
  }




  export type TranslationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationTaskWhereInput
    orderBy?: TranslationTaskOrderByWithAggregationInput | TranslationTaskOrderByWithAggregationInput[]
    by: TranslationTaskScalarFieldEnum[] | TranslationTaskScalarFieldEnum
    having?: TranslationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationTaskCountAggregateInputType | true
    _avg?: TranslationTaskAvgAggregateInputType
    _sum?: TranslationTaskSumAggregateInputType
    _min?: TranslationTaskMinAggregateInputType
    _max?: TranslationTaskMaxAggregateInputType
  }

  export type TranslationTaskGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    texts: JsonValue
    language: $Enums.LanguageCode
    status: string
    attempts: number
    lastError: string | null
    processingStartedAt: Date | null
    createdAt: Date
    updatedAt: Date
    apiKeyId: number | null
    apiUrl: string | null
    _count: TranslationTaskCountAggregateOutputType | null
    _avg: TranslationTaskAvgAggregateOutputType | null
    _sum: TranslationTaskSumAggregateOutputType | null
    _min: TranslationTaskMinAggregateOutputType | null
    _max: TranslationTaskMaxAggregateOutputType | null
  }

  type GetTranslationTaskGroupByPayload<T extends TranslationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationTaskGroupByOutputType[P]>
        }
      >
    >


  export type TranslationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    texts?: boolean
    language?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    processingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKeyId?: boolean
    apiUrl?: boolean
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }, ExtArgs["result"]["translationTask"]>

  export type TranslationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    texts?: boolean
    language?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    processingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKeyId?: boolean
    apiUrl?: boolean
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }, ExtArgs["result"]["translationTask"]>

  export type TranslationTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    texts?: boolean
    language?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    processingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKeyId?: boolean
    apiUrl?: boolean
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }, ExtArgs["result"]["translationTask"]>

  export type TranslationTaskSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    texts?: boolean
    language?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    processingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKeyId?: boolean
    apiUrl?: boolean
  }

  export type TranslationTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "texts" | "language" | "status" | "attempts" | "lastError" | "processingStartedAt" | "createdAt" | "updatedAt" | "apiKeyId" | "apiUrl", ExtArgs["result"]["translationTask"]>
  export type TranslationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }
  export type TranslationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }
  export type TranslationTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | TranslationTask$apiKeyArgs<ExtArgs>
  }

  export type $TranslationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranslationTask"
    objects: {
      apiKey: Prisma.$ApiKeyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      texts: Prisma.JsonValue
      language: $Enums.LanguageCode
      status: string
      attempts: number
      lastError: string | null
      processingStartedAt: Date | null
      createdAt: Date
      updatedAt: Date
      apiKeyId: number | null
      apiUrl: string | null
    }, ExtArgs["result"]["translationTask"]>
    composites: {}
  }

  type TranslationTaskGetPayload<S extends boolean | null | undefined | TranslationTaskDefaultArgs> = $Result.GetResult<Prisma.$TranslationTaskPayload, S>

  type TranslationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranslationTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranslationTaskCountAggregateInputType | true
    }

  export interface TranslationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranslationTask'], meta: { name: 'TranslationTask' } }
    /**
     * Find zero or one TranslationTask that matches the filter.
     * @param {TranslationTaskFindUniqueArgs} args - Arguments to find a TranslationTask
     * @example
     * // Get one TranslationTask
     * const translationTask = await prisma.translationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationTaskFindUniqueArgs>(args: SelectSubset<T, TranslationTaskFindUniqueArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranslationTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranslationTaskFindUniqueOrThrowArgs} args - Arguments to find a TranslationTask
     * @example
     * // Get one TranslationTask
     * const translationTask = await prisma.translationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranslationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskFindFirstArgs} args - Arguments to find a TranslationTask
     * @example
     * // Get one TranslationTask
     * const translationTask = await prisma.translationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationTaskFindFirstArgs>(args?: SelectSubset<T, TranslationTaskFindFirstArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranslationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskFindFirstOrThrowArgs} args - Arguments to find a TranslationTask
     * @example
     * // Get one TranslationTask
     * const translationTask = await prisma.translationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranslationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranslationTasks
     * const translationTasks = await prisma.translationTask.findMany()
     * 
     * // Get first 10 TranslationTasks
     * const translationTasks = await prisma.translationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationTaskWithIdOnly = await prisma.translationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationTaskFindManyArgs>(args?: SelectSubset<T, TranslationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranslationTask.
     * @param {TranslationTaskCreateArgs} args - Arguments to create a TranslationTask.
     * @example
     * // Create one TranslationTask
     * const TranslationTask = await prisma.translationTask.create({
     *   data: {
     *     // ... data to create a TranslationTask
     *   }
     * })
     * 
     */
    create<T extends TranslationTaskCreateArgs>(args: SelectSubset<T, TranslationTaskCreateArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranslationTasks.
     * @param {TranslationTaskCreateManyArgs} args - Arguments to create many TranslationTasks.
     * @example
     * // Create many TranslationTasks
     * const translationTask = await prisma.translationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationTaskCreateManyArgs>(args?: SelectSubset<T, TranslationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranslationTasks and returns the data saved in the database.
     * @param {TranslationTaskCreateManyAndReturnArgs} args - Arguments to create many TranslationTasks.
     * @example
     * // Create many TranslationTasks
     * const translationTask = await prisma.translationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranslationTasks and only return the `id`
     * const translationTaskWithIdOnly = await prisma.translationTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TranslationTask.
     * @param {TranslationTaskDeleteArgs} args - Arguments to delete one TranslationTask.
     * @example
     * // Delete one TranslationTask
     * const TranslationTask = await prisma.translationTask.delete({
     *   where: {
     *     // ... filter to delete one TranslationTask
     *   }
     * })
     * 
     */
    delete<T extends TranslationTaskDeleteArgs>(args: SelectSubset<T, TranslationTaskDeleteArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranslationTask.
     * @param {TranslationTaskUpdateArgs} args - Arguments to update one TranslationTask.
     * @example
     * // Update one TranslationTask
     * const translationTask = await prisma.translationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationTaskUpdateArgs>(args: SelectSubset<T, TranslationTaskUpdateArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranslationTasks.
     * @param {TranslationTaskDeleteManyArgs} args - Arguments to filter TranslationTasks to delete.
     * @example
     * // Delete a few TranslationTasks
     * const { count } = await prisma.translationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationTaskDeleteManyArgs>(args?: SelectSubset<T, TranslationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranslationTasks
     * const translationTask = await prisma.translationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationTaskUpdateManyArgs>(args: SelectSubset<T, TranslationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationTasks and returns the data updated in the database.
     * @param {TranslationTaskUpdateManyAndReturnArgs} args - Arguments to update many TranslationTasks.
     * @example
     * // Update many TranslationTasks
     * const translationTask = await prisma.translationTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TranslationTasks and only return the `id`
     * const translationTaskWithIdOnly = await prisma.translationTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranslationTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TranslationTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TranslationTask.
     * @param {TranslationTaskUpsertArgs} args - Arguments to update or create a TranslationTask.
     * @example
     * // Update or create a TranslationTask
     * const translationTask = await prisma.translationTask.upsert({
     *   create: {
     *     // ... data to create a TranslationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranslationTask we want to update
     *   }
     * })
     */
    upsert<T extends TranslationTaskUpsertArgs>(args: SelectSubset<T, TranslationTaskUpsertArgs<ExtArgs>>): Prisma__TranslationTaskClient<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranslationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskCountArgs} args - Arguments to filter TranslationTasks to count.
     * @example
     * // Count the number of TranslationTasks
     * const count = await prisma.translationTask.count({
     *   where: {
     *     // ... the filter for the TranslationTasks we want to count
     *   }
     * })
    **/
    count<T extends TranslationTaskCountArgs>(
      args?: Subset<T, TranslationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranslationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationTaskAggregateArgs>(args: Subset<T, TranslationTaskAggregateArgs>): Prisma.PrismaPromise<GetTranslationTaskAggregateType<T>>

    /**
     * Group by TranslationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationTaskGroupByArgs['orderBy'] }
        : { orderBy?: TranslationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranslationTask model
   */
  readonly fields: TranslationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranslationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKey<T extends TranslationTask$apiKeyArgs<ExtArgs> = {}>(args?: Subset<T, TranslationTask$apiKeyArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranslationTask model
   */
  interface TranslationTaskFieldRefs {
    readonly id: FieldRef<"TranslationTask", 'Int'>
    readonly entityType: FieldRef<"TranslationTask", 'String'>
    readonly entityId: FieldRef<"TranslationTask", 'Int'>
    readonly texts: FieldRef<"TranslationTask", 'Json'>
    readonly language: FieldRef<"TranslationTask", 'LanguageCode'>
    readonly status: FieldRef<"TranslationTask", 'String'>
    readonly attempts: FieldRef<"TranslationTask", 'Int'>
    readonly lastError: FieldRef<"TranslationTask", 'String'>
    readonly processingStartedAt: FieldRef<"TranslationTask", 'DateTime'>
    readonly createdAt: FieldRef<"TranslationTask", 'DateTime'>
    readonly updatedAt: FieldRef<"TranslationTask", 'DateTime'>
    readonly apiKeyId: FieldRef<"TranslationTask", 'Int'>
    readonly apiUrl: FieldRef<"TranslationTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TranslationTask findUnique
   */
  export type TranslationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter, which TranslationTask to fetch.
     */
    where: TranslationTaskWhereUniqueInput
  }

  /**
   * TranslationTask findUniqueOrThrow
   */
  export type TranslationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter, which TranslationTask to fetch.
     */
    where: TranslationTaskWhereUniqueInput
  }

  /**
   * TranslationTask findFirst
   */
  export type TranslationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter, which TranslationTask to fetch.
     */
    where?: TranslationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationTasks to fetch.
     */
    orderBy?: TranslationTaskOrderByWithRelationInput | TranslationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationTasks.
     */
    cursor?: TranslationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationTasks.
     */
    distinct?: TranslationTaskScalarFieldEnum | TranslationTaskScalarFieldEnum[]
  }

  /**
   * TranslationTask findFirstOrThrow
   */
  export type TranslationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter, which TranslationTask to fetch.
     */
    where?: TranslationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationTasks to fetch.
     */
    orderBy?: TranslationTaskOrderByWithRelationInput | TranslationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranslationTasks.
     */
    cursor?: TranslationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranslationTasks.
     */
    distinct?: TranslationTaskScalarFieldEnum | TranslationTaskScalarFieldEnum[]
  }

  /**
   * TranslationTask findMany
   */
  export type TranslationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter, which TranslationTasks to fetch.
     */
    where?: TranslationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranslationTasks to fetch.
     */
    orderBy?: TranslationTaskOrderByWithRelationInput | TranslationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranslationTasks.
     */
    cursor?: TranslationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranslationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranslationTasks.
     */
    skip?: number
    distinct?: TranslationTaskScalarFieldEnum | TranslationTaskScalarFieldEnum[]
  }

  /**
   * TranslationTask create
   */
  export type TranslationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a TranslationTask.
     */
    data: XOR<TranslationTaskCreateInput, TranslationTaskUncheckedCreateInput>
  }

  /**
   * TranslationTask createMany
   */
  export type TranslationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranslationTasks.
     */
    data: TranslationTaskCreateManyInput | TranslationTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranslationTask createManyAndReturn
   */
  export type TranslationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * The data used to create many TranslationTasks.
     */
    data: TranslationTaskCreateManyInput | TranslationTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranslationTask update
   */
  export type TranslationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a TranslationTask.
     */
    data: XOR<TranslationTaskUpdateInput, TranslationTaskUncheckedUpdateInput>
    /**
     * Choose, which TranslationTask to update.
     */
    where: TranslationTaskWhereUniqueInput
  }

  /**
   * TranslationTask updateMany
   */
  export type TranslationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranslationTasks.
     */
    data: XOR<TranslationTaskUpdateManyMutationInput, TranslationTaskUncheckedUpdateManyInput>
    /**
     * Filter which TranslationTasks to update
     */
    where?: TranslationTaskWhereInput
    /**
     * Limit how many TranslationTasks to update.
     */
    limit?: number
  }

  /**
   * TranslationTask updateManyAndReturn
   */
  export type TranslationTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * The data used to update TranslationTasks.
     */
    data: XOR<TranslationTaskUpdateManyMutationInput, TranslationTaskUncheckedUpdateManyInput>
    /**
     * Filter which TranslationTasks to update
     */
    where?: TranslationTaskWhereInput
    /**
     * Limit how many TranslationTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranslationTask upsert
   */
  export type TranslationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the TranslationTask to update in case it exists.
     */
    where: TranslationTaskWhereUniqueInput
    /**
     * In case the TranslationTask found by the `where` argument doesn't exist, create a new TranslationTask with this data.
     */
    create: XOR<TranslationTaskCreateInput, TranslationTaskUncheckedCreateInput>
    /**
     * In case the TranslationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationTaskUpdateInput, TranslationTaskUncheckedUpdateInput>
  }

  /**
   * TranslationTask delete
   */
  export type TranslationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    /**
     * Filter which TranslationTask to delete.
     */
    where: TranslationTaskWhereUniqueInput
  }

  /**
   * TranslationTask deleteMany
   */
  export type TranslationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranslationTasks to delete
     */
    where?: TranslationTaskWhereInput
    /**
     * Limit how many TranslationTasks to delete.
     */
    limit?: number
  }

  /**
   * TranslationTask.apiKey
   */
  export type TranslationTask$apiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
  }

  /**
   * TranslationTask without action
   */
  export type TranslationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
  }


  /**
   * Model ContactSubmission
   */

  export type AggregateContactSubmission = {
    _count: ContactSubmissionCountAggregateOutputType | null
    _avg: ContactSubmissionAvgAggregateOutputType | null
    _sum: ContactSubmissionSumAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  export type ContactSubmissionAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSubmissionSumAggregateOutputType = {
    id: number | null
  }

  export type ContactSubmissionMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fullName: number
    email: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactSubmissionAvgAggregateInputType = {
    id?: true
  }

  export type ContactSubmissionSumAggregateInputType = {
    id?: true
  }

  export type ContactSubmissionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fullName?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fullName?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fullName?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmission to aggregate.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSubmissions
    **/
    _count?: true | ContactSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type GetContactSubmissionAggregateType<T extends ContactSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSubmission[P]>
      : GetScalarType<T[P], AggregateContactSubmission[P]>
  }




  export type ContactSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSubmissionWhereInput
    orderBy?: ContactSubmissionOrderByWithAggregationInput | ContactSubmissionOrderByWithAggregationInput[]
    by: ContactSubmissionScalarFieldEnum[] | ContactSubmissionScalarFieldEnum
    having?: ContactSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSubmissionCountAggregateInputType | true
    _avg?: ContactSubmissionAvgAggregateInputType
    _sum?: ContactSubmissionSumAggregateInputType
    _min?: ContactSubmissionMinAggregateInputType
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type ContactSubmissionGroupByOutputType = {
    id: number
    title: string
    description: string | null
    fullName: string
    email: string
    phone: string
    createdAt: Date
    updatedAt: Date
    _count: ContactSubmissionCountAggregateOutputType | null
    _avg: ContactSubmissionAvgAggregateOutputType | null
    _sum: ContactSubmissionSumAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  type GetContactSubmissionGroupByPayload<T extends ContactSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ContactSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fullName" | "email" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["contactSubmission"]>

  export type $ContactSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      fullName: string
      email: string
      phone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactSubmission"]>
    composites: {}
  }

  type ContactSubmissionGetPayload<S extends boolean | null | undefined | ContactSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ContactSubmissionPayload, S>

  type ContactSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSubmissionCountAggregateInputType | true
    }

  export interface ContactSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSubmission'], meta: { name: 'ContactSubmission' } }
    /**
     * Find zero or one ContactSubmission that matches the filter.
     * @param {ContactSubmissionFindUniqueArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSubmissionFindUniqueArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSubmissionFindFirstArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany()
     * 
     * // Get first 10 ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSubmissionFindManyArgs>(args?: SelectSubset<T, ContactSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSubmission.
     * @param {ContactSubmissionCreateArgs} args - Arguments to create a ContactSubmission.
     * @example
     * // Create one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.create({
     *   data: {
     *     // ... data to create a ContactSubmission
     *   }
     * })
     * 
     */
    create<T extends ContactSubmissionCreateArgs>(args: SelectSubset<T, ContactSubmissionCreateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSubmissions.
     * @param {ContactSubmissionCreateManyArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSubmissionCreateManyArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSubmissions and returns the data saved in the database.
     * @param {ContactSubmissionCreateManyAndReturnArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSubmission.
     * @param {ContactSubmissionDeleteArgs} args - Arguments to delete one ContactSubmission.
     * @example
     * // Delete one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.delete({
     *   where: {
     *     // ... filter to delete one ContactSubmission
     *   }
     * })
     * 
     */
    delete<T extends ContactSubmissionDeleteArgs>(args: SelectSubset<T, ContactSubmissionDeleteArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSubmission.
     * @param {ContactSubmissionUpdateArgs} args - Arguments to update one ContactSubmission.
     * @example
     * // Update one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSubmissionUpdateArgs>(args: SelectSubset<T, ContactSubmissionUpdateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSubmissions.
     * @param {ContactSubmissionDeleteManyArgs} args - Arguments to filter ContactSubmissions to delete.
     * @example
     * // Delete a few ContactSubmissions
     * const { count } = await prisma.contactSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSubmissionDeleteManyArgs>(args?: SelectSubset<T, ContactSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSubmissionUpdateManyArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions and returns the data updated in the database.
     * @param {ContactSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ContactSubmissions.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSubmission.
     * @param {ContactSubmissionUpsertArgs} args - Arguments to update or create a ContactSubmission.
     * @example
     * // Update or create a ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.upsert({
     *   create: {
     *     // ... data to create a ContactSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ContactSubmissionUpsertArgs>(args: SelectSubset<T, ContactSubmissionUpsertArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionCountArgs} args - Arguments to filter ContactSubmissions to count.
     * @example
     * // Count the number of ContactSubmissions
     * const count = await prisma.contactSubmission.count({
     *   where: {
     *     // ... the filter for the ContactSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ContactSubmissionCountArgs>(
      args?: Subset<T, ContactSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSubmissionAggregateArgs>(args: Subset<T, ContactSubmissionAggregateArgs>): Prisma.PrismaPromise<GetContactSubmissionAggregateType<T>>

    /**
     * Group by ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ContactSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSubmission model
   */
  readonly fields: ContactSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSubmission model
   */
  interface ContactSubmissionFieldRefs {
    readonly id: FieldRef<"ContactSubmission", 'Int'>
    readonly title: FieldRef<"ContactSubmission", 'String'>
    readonly description: FieldRef<"ContactSubmission", 'String'>
    readonly fullName: FieldRef<"ContactSubmission", 'String'>
    readonly email: FieldRef<"ContactSubmission", 'String'>
    readonly phone: FieldRef<"ContactSubmission", 'String'>
    readonly createdAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactSubmission findUnique
   */
  export type ContactSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findUniqueOrThrow
   */
  export type ContactSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findFirst
   */
  export type ContactSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findFirstOrThrow
   */
  export type ContactSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findMany
   */
  export type ContactSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmissions to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission create
   */
  export type ContactSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactSubmission.
     */
    data: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
  }

  /**
   * ContactSubmission createMany
   */
  export type ContactSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission createManyAndReturn
   */
  export type ContactSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission update
   */
  export type ContactSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactSubmission.
     */
    data: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ContactSubmission to update.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission updateMany
   */
  export type ContactSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission updateManyAndReturn
   */
  export type ContactSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission upsert
   */
  export type ContactSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactSubmission to update in case it exists.
     */
    where: ContactSubmissionWhereUniqueInput
    /**
     * In case the ContactSubmission found by the `where` argument doesn't exist, create a new ContactSubmission with this data.
     */
    create: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
    /**
     * In case the ContactSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
  }

  /**
   * ContactSubmission delete
   */
  export type ContactSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter which ContactSubmission to delete.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission deleteMany
   */
  export type ContactSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmissions to delete
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ContactSubmission without action
   */
  export type ContactSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    id: number | null
    rateLimitPerMin: number | null
    rateLimitCount: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    id: number | null
    rateLimitPerMin: number | null
    rateLimitCount: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: number | null
    keyValue: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
    rateLimitPerMin: number | null
    rateLimitCount: number | null
    rateLimitReset: Date | null
    notes: string | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: number | null
    keyValue: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
    rateLimitPerMin: number | null
    rateLimitCount: number | null
    rateLimitReset: Date | null
    notes: string | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    keyValue: number
    status: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    rateLimitPerMin: number
    rateLimitCount: number
    rateLimitReset: number
    notes: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    id?: true
    rateLimitPerMin?: true
    rateLimitCount?: true
  }

  export type ApiKeySumAggregateInputType = {
    id?: true
    rateLimitPerMin?: true
    rateLimitCount?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    keyValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    rateLimitPerMin?: true
    rateLimitCount?: true
    rateLimitReset?: true
    notes?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    keyValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    rateLimitPerMin?: true
    rateLimitCount?: true
    rateLimitReset?: true
    notes?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    keyValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    rateLimitPerMin?: true
    rateLimitCount?: true
    rateLimitReset?: true
    notes?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: number
    keyValue: string
    status: string
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    rateLimitPerMin: number | null
    rateLimitCount: number
    rateLimitReset: Date | null
    notes: string | null
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    rateLimitPerMin?: boolean
    rateLimitCount?: boolean
    rateLimitReset?: boolean
    notes?: boolean
    usageLogs?: boolean | ApiKey$usageLogsArgs<ExtArgs>
    auditLogs?: boolean | ApiKey$auditLogsArgs<ExtArgs>
    translationTasks?: boolean | ApiKey$translationTasksArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    rateLimitPerMin?: boolean
    rateLimitCount?: boolean
    rateLimitReset?: boolean
    notes?: boolean
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    rateLimitPerMin?: boolean
    rateLimitCount?: boolean
    rateLimitReset?: boolean
    notes?: boolean
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    keyValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    rateLimitPerMin?: boolean
    rateLimitCount?: boolean
    rateLimitReset?: boolean
    notes?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyValue" | "status" | "createdAt" | "updatedAt" | "lastUsedAt" | "rateLimitPerMin" | "rateLimitCount" | "rateLimitReset" | "notes", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | ApiKey$usageLogsArgs<ExtArgs>
    auditLogs?: boolean | ApiKey$auditLogsArgs<ExtArgs>
    translationTasks?: boolean | ApiKey$translationTasksArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      usageLogs: Prisma.$ApiKeyUsagePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      translationTasks: Prisma.$TranslationTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      keyValue: string
      status: string
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
      rateLimitPerMin: number | null
      rateLimitCount: number
      rateLimitReset: Date | null
      notes: string | null
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usageLogs<T extends ApiKey$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends ApiKey$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    translationTasks<T extends ApiKey$translationTasksArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$translationTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'Int'>
    readonly keyValue: FieldRef<"ApiKey", 'String'>
    readonly status: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly rateLimitPerMin: FieldRef<"ApiKey", 'Int'>
    readonly rateLimitCount: FieldRef<"ApiKey", 'Int'>
    readonly rateLimitReset: FieldRef<"ApiKey", 'DateTime'>
    readonly notes: FieldRef<"ApiKey", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey.usageLogs
   */
  export type ApiKey$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    where?: ApiKeyUsageWhereInput
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    cursor?: ApiKeyUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKey.auditLogs
   */
  export type ApiKey$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * ApiKey.translationTasks
   */
  export type ApiKey$translationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationTask
     */
    select?: TranslationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranslationTask
     */
    omit?: TranslationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationTaskInclude<ExtArgs> | null
    where?: TranslationTaskWhereInput
    orderBy?: TranslationTaskOrderByWithRelationInput | TranslationTaskOrderByWithRelationInput[]
    cursor?: TranslationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationTaskScalarFieldEnum | TranslationTaskScalarFieldEnum[]
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model ApiKeyUsage
   */

  export type AggregateApiKeyUsage = {
    _count: ApiKeyUsageCountAggregateOutputType | null
    _avg: ApiKeyUsageAvgAggregateOutputType | null
    _sum: ApiKeyUsageSumAggregateOutputType | null
    _min: ApiKeyUsageMinAggregateOutputType | null
    _max: ApiKeyUsageMaxAggregateOutputType | null
  }

  export type ApiKeyUsageAvgAggregateOutputType = {
    id: number | null
    apiKeyId: number | null
    statusCode: number | null
    durationMs: number | null
  }

  export type ApiKeyUsageSumAggregateOutputType = {
    id: number | null
    apiKeyId: number | null
    statusCode: number | null
    durationMs: number | null
  }

  export type ApiKeyUsageMinAggregateOutputType = {
    id: number | null
    apiKeyId: number | null
    requestAt: Date | null
    statusCode: number | null
    durationMs: number | null
    endpoint: string | null
    errorMessage: string | null
  }

  export type ApiKeyUsageMaxAggregateOutputType = {
    id: number | null
    apiKeyId: number | null
    requestAt: Date | null
    statusCode: number | null
    durationMs: number | null
    endpoint: string | null
    errorMessage: string | null
  }

  export type ApiKeyUsageCountAggregateOutputType = {
    id: number
    apiKeyId: number
    requestAt: number
    statusCode: number
    durationMs: number
    endpoint: number
    errorMessage: number
    _all: number
  }


  export type ApiKeyUsageAvgAggregateInputType = {
    id?: true
    apiKeyId?: true
    statusCode?: true
    durationMs?: true
  }

  export type ApiKeyUsageSumAggregateInputType = {
    id?: true
    apiKeyId?: true
    statusCode?: true
    durationMs?: true
  }

  export type ApiKeyUsageMinAggregateInputType = {
    id?: true
    apiKeyId?: true
    requestAt?: true
    statusCode?: true
    durationMs?: true
    endpoint?: true
    errorMessage?: true
  }

  export type ApiKeyUsageMaxAggregateInputType = {
    id?: true
    apiKeyId?: true
    requestAt?: true
    statusCode?: true
    durationMs?: true
    endpoint?: true
    errorMessage?: true
  }

  export type ApiKeyUsageCountAggregateInputType = {
    id?: true
    apiKeyId?: true
    requestAt?: true
    statusCode?: true
    durationMs?: true
    endpoint?: true
    errorMessage?: true
    _all?: true
  }

  export type ApiKeyUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsage to aggregate.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeyUsages
    **/
    _count?: true | ApiKeyUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeyUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyUsageMaxAggregateInputType
  }

  export type GetApiKeyUsageAggregateType<T extends ApiKeyUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeyUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeyUsage[P]>
      : GetScalarType<T[P], AggregateApiKeyUsage[P]>
  }




  export type ApiKeyUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyUsageWhereInput
    orderBy?: ApiKeyUsageOrderByWithAggregationInput | ApiKeyUsageOrderByWithAggregationInput[]
    by: ApiKeyUsageScalarFieldEnum[] | ApiKeyUsageScalarFieldEnum
    having?: ApiKeyUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyUsageCountAggregateInputType | true
    _avg?: ApiKeyUsageAvgAggregateInputType
    _sum?: ApiKeyUsageSumAggregateInputType
    _min?: ApiKeyUsageMinAggregateInputType
    _max?: ApiKeyUsageMaxAggregateInputType
  }

  export type ApiKeyUsageGroupByOutputType = {
    id: number
    apiKeyId: number
    requestAt: Date
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage: string | null
    _count: ApiKeyUsageCountAggregateOutputType | null
    _avg: ApiKeyUsageAvgAggregateOutputType | null
    _sum: ApiKeyUsageSumAggregateOutputType | null
    _min: ApiKeyUsageMinAggregateOutputType | null
    _max: ApiKeyUsageMaxAggregateOutputType | null
  }

  type GetApiKeyUsageGroupByPayload<T extends ApiKeyUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyUsageGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeyUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    requestAt?: boolean
    statusCode?: boolean
    durationMs?: boolean
    endpoint?: boolean
    errorMessage?: boolean
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsage"]>

  export type ApiKeyUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    requestAt?: boolean
    statusCode?: boolean
    durationMs?: boolean
    endpoint?: boolean
    errorMessage?: boolean
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsage"]>

  export type ApiKeyUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiKeyId?: boolean
    requestAt?: boolean
    statusCode?: boolean
    durationMs?: boolean
    endpoint?: boolean
    errorMessage?: boolean
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKeyUsage"]>

  export type ApiKeyUsageSelectScalar = {
    id?: boolean
    apiKeyId?: boolean
    requestAt?: boolean
    statusCode?: boolean
    durationMs?: boolean
    endpoint?: boolean
    errorMessage?: boolean
  }

  export type ApiKeyUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apiKeyId" | "requestAt" | "statusCode" | "durationMs" | "endpoint" | "errorMessage", ExtArgs["result"]["apiKeyUsage"]>
  export type ApiKeyUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }
  export type ApiKeyUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }
  export type ApiKeyUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKey?: boolean | ApiKeyDefaultArgs<ExtArgs>
  }

  export type $ApiKeyUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeyUsage"
    objects: {
      apiKey: Prisma.$ApiKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      apiKeyId: number
      requestAt: Date
      statusCode: number
      durationMs: number
      endpoint: string
      errorMessage: string | null
    }, ExtArgs["result"]["apiKeyUsage"]>
    composites: {}
  }

  type ApiKeyUsageGetPayload<S extends boolean | null | undefined | ApiKeyUsageDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyUsagePayload, S>

  type ApiKeyUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyUsageCountAggregateInputType | true
    }

  export interface ApiKeyUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeyUsage'], meta: { name: 'ApiKeyUsage' } }
    /**
     * Find zero or one ApiKeyUsage that matches the filter.
     * @param {ApiKeyUsageFindUniqueArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyUsageFindUniqueArgs>(args: SelectSubset<T, ApiKeyUsageFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKeyUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyUsageFindUniqueOrThrowArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeyUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindFirstArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyUsageFindFirstArgs>(args?: SelectSubset<T, ApiKeyUsageFindFirstArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeyUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindFirstOrThrowArgs} args - Arguments to find a ApiKeyUsage
     * @example
     * // Get one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeyUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeyUsages
     * const apiKeyUsages = await prisma.apiKeyUsage.findMany()
     * 
     * // Get first 10 ApiKeyUsages
     * const apiKeyUsages = await prisma.apiKeyUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyUsageWithIdOnly = await prisma.apiKeyUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyUsageFindManyArgs>(args?: SelectSubset<T, ApiKeyUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKeyUsage.
     * @param {ApiKeyUsageCreateArgs} args - Arguments to create a ApiKeyUsage.
     * @example
     * // Create one ApiKeyUsage
     * const ApiKeyUsage = await prisma.apiKeyUsage.create({
     *   data: {
     *     // ... data to create a ApiKeyUsage
     *   }
     * })
     * 
     */
    create<T extends ApiKeyUsageCreateArgs>(args: SelectSubset<T, ApiKeyUsageCreateArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeyUsages.
     * @param {ApiKeyUsageCreateManyArgs} args - Arguments to create many ApiKeyUsages.
     * @example
     * // Create many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyUsageCreateManyArgs>(args?: SelectSubset<T, ApiKeyUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeyUsages and returns the data saved in the database.
     * @param {ApiKeyUsageCreateManyAndReturnArgs} args - Arguments to create many ApiKeyUsages.
     * @example
     * // Create many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeyUsages and only return the `id`
     * const apiKeyUsageWithIdOnly = await prisma.apiKeyUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKeyUsage.
     * @param {ApiKeyUsageDeleteArgs} args - Arguments to delete one ApiKeyUsage.
     * @example
     * // Delete one ApiKeyUsage
     * const ApiKeyUsage = await prisma.apiKeyUsage.delete({
     *   where: {
     *     // ... filter to delete one ApiKeyUsage
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyUsageDeleteArgs>(args: SelectSubset<T, ApiKeyUsageDeleteArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKeyUsage.
     * @param {ApiKeyUsageUpdateArgs} args - Arguments to update one ApiKeyUsage.
     * @example
     * // Update one ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUsageUpdateArgs>(args: SelectSubset<T, ApiKeyUsageUpdateArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeyUsages.
     * @param {ApiKeyUsageDeleteManyArgs} args - Arguments to filter ApiKeyUsages to delete.
     * @example
     * // Delete a few ApiKeyUsages
     * const { count } = await prisma.apiKeyUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyUsageDeleteManyArgs>(args?: SelectSubset<T, ApiKeyUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUsageUpdateManyArgs>(args: SelectSubset<T, ApiKeyUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeyUsages and returns the data updated in the database.
     * @param {ApiKeyUsageUpdateManyAndReturnArgs} args - Arguments to update many ApiKeyUsages.
     * @example
     * // Update many ApiKeyUsages
     * const apiKeyUsage = await prisma.apiKeyUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeyUsages and only return the `id`
     * const apiKeyUsageWithIdOnly = await prisma.apiKeyUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKeyUsage.
     * @param {ApiKeyUsageUpsertArgs} args - Arguments to update or create a ApiKeyUsage.
     * @example
     * // Update or create a ApiKeyUsage
     * const apiKeyUsage = await prisma.apiKeyUsage.upsert({
     *   create: {
     *     // ... data to create a ApiKeyUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeyUsage we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUsageUpsertArgs>(args: SelectSubset<T, ApiKeyUsageUpsertArgs<ExtArgs>>): Prisma__ApiKeyUsageClient<$Result.GetResult<Prisma.$ApiKeyUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeyUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageCountArgs} args - Arguments to filter ApiKeyUsages to count.
     * @example
     * // Count the number of ApiKeyUsages
     * const count = await prisma.apiKeyUsage.count({
     *   where: {
     *     // ... the filter for the ApiKeyUsages we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyUsageCountArgs>(
      args?: Subset<T, ApiKeyUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyUsageAggregateArgs>(args: Subset<T, ApiKeyUsageAggregateArgs>): Prisma.PrismaPromise<GetApiKeyUsageAggregateType<T>>

    /**
     * Group by ApiKeyUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyUsageGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeyUsage model
   */
  readonly fields: ApiKeyUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeyUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKey<T extends ApiKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiKeyDefaultArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeyUsage model
   */
  interface ApiKeyUsageFieldRefs {
    readonly id: FieldRef<"ApiKeyUsage", 'Int'>
    readonly apiKeyId: FieldRef<"ApiKeyUsage", 'Int'>
    readonly requestAt: FieldRef<"ApiKeyUsage", 'DateTime'>
    readonly statusCode: FieldRef<"ApiKeyUsage", 'Int'>
    readonly durationMs: FieldRef<"ApiKeyUsage", 'Int'>
    readonly endpoint: FieldRef<"ApiKeyUsage", 'String'>
    readonly errorMessage: FieldRef<"ApiKeyUsage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeyUsage findUnique
   */
  export type ApiKeyUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage findUniqueOrThrow
   */
  export type ApiKeyUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage findFirst
   */
  export type ApiKeyUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsages.
     */
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage findFirstOrThrow
   */
  export type ApiKeyUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsage to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeyUsages.
     */
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage findMany
   */
  export type ApiKeyUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeyUsages to fetch.
     */
    where?: ApiKeyUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeyUsages to fetch.
     */
    orderBy?: ApiKeyUsageOrderByWithRelationInput | ApiKeyUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeyUsages.
     */
    cursor?: ApiKeyUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeyUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeyUsages.
     */
    skip?: number
    distinct?: ApiKeyUsageScalarFieldEnum | ApiKeyUsageScalarFieldEnum[]
  }

  /**
   * ApiKeyUsage create
   */
  export type ApiKeyUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKeyUsage.
     */
    data: XOR<ApiKeyUsageCreateInput, ApiKeyUsageUncheckedCreateInput>
  }

  /**
   * ApiKeyUsage createMany
   */
  export type ApiKeyUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeyUsages.
     */
    data: ApiKeyUsageCreateManyInput | ApiKeyUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeyUsage createManyAndReturn
   */
  export type ApiKeyUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeyUsages.
     */
    data: ApiKeyUsageCreateManyInput | ApiKeyUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyUsage update
   */
  export type ApiKeyUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKeyUsage.
     */
    data: XOR<ApiKeyUsageUpdateInput, ApiKeyUsageUncheckedUpdateInput>
    /**
     * Choose, which ApiKeyUsage to update.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage updateMany
   */
  export type ApiKeyUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeyUsages.
     */
    data: XOR<ApiKeyUsageUpdateManyMutationInput, ApiKeyUsageUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyUsages to update
     */
    where?: ApiKeyUsageWhereInput
    /**
     * Limit how many ApiKeyUsages to update.
     */
    limit?: number
  }

  /**
   * ApiKeyUsage updateManyAndReturn
   */
  export type ApiKeyUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeyUsages.
     */
    data: XOR<ApiKeyUsageUpdateManyMutationInput, ApiKeyUsageUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeyUsages to update
     */
    where?: ApiKeyUsageWhereInput
    /**
     * Limit how many ApiKeyUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKeyUsage upsert
   */
  export type ApiKeyUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKeyUsage to update in case it exists.
     */
    where: ApiKeyUsageWhereUniqueInput
    /**
     * In case the ApiKeyUsage found by the `where` argument doesn't exist, create a new ApiKeyUsage with this data.
     */
    create: XOR<ApiKeyUsageCreateInput, ApiKeyUsageUncheckedCreateInput>
    /**
     * In case the ApiKeyUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUsageUpdateInput, ApiKeyUsageUncheckedUpdateInput>
  }

  /**
   * ApiKeyUsage delete
   */
  export type ApiKeyUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
    /**
     * Filter which ApiKeyUsage to delete.
     */
    where: ApiKeyUsageWhereUniqueInput
  }

  /**
   * ApiKeyUsage deleteMany
   */
  export type ApiKeyUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeyUsages to delete
     */
    where?: ApiKeyUsageWhereInput
    /**
     * Limit how many ApiKeyUsages to delete.
     */
    limit?: number
  }

  /**
   * ApiKeyUsage without action
   */
  export type ApiKeyUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyUsage
     */
    select?: ApiKeyUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeyUsage
     */
    omit?: ApiKeyUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyUsageInclude<ExtArgs> | null
  }


  /**
   * Model ApiConfig
   */

  export type AggregateApiConfig = {
    _count: ApiConfigCountAggregateOutputType | null
    _avg: ApiConfigAvgAggregateOutputType | null
    _sum: ApiConfigSumAggregateOutputType | null
    _min: ApiConfigMinAggregateOutputType | null
    _max: ApiConfigMaxAggregateOutputType | null
  }

  export type ApiConfigAvgAggregateOutputType = {
    id: number | null
  }

  export type ApiConfigSumAggregateOutputType = {
    id: number | null
  }

  export type ApiConfigMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type ApiConfigMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type ApiConfigCountAggregateOutputType = {
    id: number
    name: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type ApiConfigAvgAggregateInputType = {
    id?: true
  }

  export type ApiConfigSumAggregateInputType = {
    id?: true
  }

  export type ApiConfigMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type ApiConfigMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type ApiConfigCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiConfig to aggregate.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiConfigs
    **/
    _count?: true | ApiConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiConfigMaxAggregateInputType
  }

  export type GetApiConfigAggregateType<T extends ApiConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateApiConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiConfig[P]>
      : GetScalarType<T[P], AggregateApiConfig[P]>
  }




  export type ApiConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiConfigWhereInput
    orderBy?: ApiConfigOrderByWithAggregationInput | ApiConfigOrderByWithAggregationInput[]
    by: ApiConfigScalarFieldEnum[] | ApiConfigScalarFieldEnum
    having?: ApiConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiConfigCountAggregateInputType | true
    _avg?: ApiConfigAvgAggregateInputType
    _sum?: ApiConfigSumAggregateInputType
    _min?: ApiConfigMinAggregateInputType
    _max?: ApiConfigMaxAggregateInputType
  }

  export type ApiConfigGroupByOutputType = {
    id: number
    name: string
    value: string
    description: string | null
    updatedAt: Date
    _count: ApiConfigCountAggregateOutputType | null
    _avg: ApiConfigAvgAggregateOutputType | null
    _sum: ApiConfigSumAggregateOutputType | null
    _min: ApiConfigMinAggregateOutputType | null
    _max: ApiConfigMaxAggregateOutputType | null
  }

  type GetApiConfigGroupByPayload<T extends ApiConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ApiConfigGroupByOutputType[P]>
        }
      >
    >


  export type ApiConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
    auditLogs?: boolean | ApiConfig$auditLogsArgs<ExtArgs>
    _count?: boolean | ApiConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiConfig"]>

  export type ApiConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiConfig"]>

  export type ApiConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiConfig"]>

  export type ApiConfigSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }

  export type ApiConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "description" | "updatedAt", ExtArgs["result"]["apiConfig"]>
  export type ApiConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ApiConfig$auditLogsArgs<ExtArgs>
    _count?: boolean | ApiConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ApiConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApiConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiConfig"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["apiConfig"]>
    composites: {}
  }

  type ApiConfigGetPayload<S extends boolean | null | undefined | ApiConfigDefaultArgs> = $Result.GetResult<Prisma.$ApiConfigPayload, S>

  type ApiConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiConfigCountAggregateInputType | true
    }

  export interface ApiConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiConfig'], meta: { name: 'ApiConfig' } }
    /**
     * Find zero or one ApiConfig that matches the filter.
     * @param {ApiConfigFindUniqueArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiConfigFindUniqueArgs>(args: SelectSubset<T, ApiConfigFindUniqueArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiConfigFindUniqueOrThrowArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindFirstArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiConfigFindFirstArgs>(args?: SelectSubset<T, ApiConfigFindFirstArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindFirstOrThrowArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiConfigs
     * const apiConfigs = await prisma.apiConfig.findMany()
     * 
     * // Get first 10 ApiConfigs
     * const apiConfigs = await prisma.apiConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiConfigWithIdOnly = await prisma.apiConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiConfigFindManyArgs>(args?: SelectSubset<T, ApiConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiConfig.
     * @param {ApiConfigCreateArgs} args - Arguments to create a ApiConfig.
     * @example
     * // Create one ApiConfig
     * const ApiConfig = await prisma.apiConfig.create({
     *   data: {
     *     // ... data to create a ApiConfig
     *   }
     * })
     * 
     */
    create<T extends ApiConfigCreateArgs>(args: SelectSubset<T, ApiConfigCreateArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiConfigs.
     * @param {ApiConfigCreateManyArgs} args - Arguments to create many ApiConfigs.
     * @example
     * // Create many ApiConfigs
     * const apiConfig = await prisma.apiConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiConfigCreateManyArgs>(args?: SelectSubset<T, ApiConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiConfigs and returns the data saved in the database.
     * @param {ApiConfigCreateManyAndReturnArgs} args - Arguments to create many ApiConfigs.
     * @example
     * // Create many ApiConfigs
     * const apiConfig = await prisma.apiConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiConfigs and only return the `id`
     * const apiConfigWithIdOnly = await prisma.apiConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiConfig.
     * @param {ApiConfigDeleteArgs} args - Arguments to delete one ApiConfig.
     * @example
     * // Delete one ApiConfig
     * const ApiConfig = await prisma.apiConfig.delete({
     *   where: {
     *     // ... filter to delete one ApiConfig
     *   }
     * })
     * 
     */
    delete<T extends ApiConfigDeleteArgs>(args: SelectSubset<T, ApiConfigDeleteArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiConfig.
     * @param {ApiConfigUpdateArgs} args - Arguments to update one ApiConfig.
     * @example
     * // Update one ApiConfig
     * const apiConfig = await prisma.apiConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiConfigUpdateArgs>(args: SelectSubset<T, ApiConfigUpdateArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiConfigs.
     * @param {ApiConfigDeleteManyArgs} args - Arguments to filter ApiConfigs to delete.
     * @example
     * // Delete a few ApiConfigs
     * const { count } = await prisma.apiConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiConfigDeleteManyArgs>(args?: SelectSubset<T, ApiConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiConfigs
     * const apiConfig = await prisma.apiConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiConfigUpdateManyArgs>(args: SelectSubset<T, ApiConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiConfigs and returns the data updated in the database.
     * @param {ApiConfigUpdateManyAndReturnArgs} args - Arguments to update many ApiConfigs.
     * @example
     * // Update many ApiConfigs
     * const apiConfig = await prisma.apiConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiConfigs and only return the `id`
     * const apiConfigWithIdOnly = await prisma.apiConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiConfig.
     * @param {ApiConfigUpsertArgs} args - Arguments to update or create a ApiConfig.
     * @example
     * // Update or create a ApiConfig
     * const apiConfig = await prisma.apiConfig.upsert({
     *   create: {
     *     // ... data to create a ApiConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiConfig we want to update
     *   }
     * })
     */
    upsert<T extends ApiConfigUpsertArgs>(args: SelectSubset<T, ApiConfigUpsertArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigCountArgs} args - Arguments to filter ApiConfigs to count.
     * @example
     * // Count the number of ApiConfigs
     * const count = await prisma.apiConfig.count({
     *   where: {
     *     // ... the filter for the ApiConfigs we want to count
     *   }
     * })
    **/
    count<T extends ApiConfigCountArgs>(
      args?: Subset<T, ApiConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiConfigAggregateArgs>(args: Subset<T, ApiConfigAggregateArgs>): Prisma.PrismaPromise<GetApiConfigAggregateType<T>>

    /**
     * Group by ApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiConfigGroupByArgs['orderBy'] }
        : { orderBy?: ApiConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiConfig model
   */
  readonly fields: ApiConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends ApiConfig$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiConfig$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiConfig model
   */
  interface ApiConfigFieldRefs {
    readonly id: FieldRef<"ApiConfig", 'Int'>
    readonly name: FieldRef<"ApiConfig", 'String'>
    readonly value: FieldRef<"ApiConfig", 'String'>
    readonly description: FieldRef<"ApiConfig", 'String'>
    readonly updatedAt: FieldRef<"ApiConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiConfig findUnique
   */
  export type ApiConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig findUniqueOrThrow
   */
  export type ApiConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig findFirst
   */
  export type ApiConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiConfigs.
     */
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig findFirstOrThrow
   */
  export type ApiConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiConfigs.
     */
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig findMany
   */
  export type ApiConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfigs to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig create
   */
  export type ApiConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiConfig.
     */
    data: XOR<ApiConfigCreateInput, ApiConfigUncheckedCreateInput>
  }

  /**
   * ApiConfig createMany
   */
  export type ApiConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiConfigs.
     */
    data: ApiConfigCreateManyInput | ApiConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiConfig createManyAndReturn
   */
  export type ApiConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * The data used to create many ApiConfigs.
     */
    data: ApiConfigCreateManyInput | ApiConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiConfig update
   */
  export type ApiConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiConfig.
     */
    data: XOR<ApiConfigUpdateInput, ApiConfigUncheckedUpdateInput>
    /**
     * Choose, which ApiConfig to update.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig updateMany
   */
  export type ApiConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiConfigs.
     */
    data: XOR<ApiConfigUpdateManyMutationInput, ApiConfigUncheckedUpdateManyInput>
    /**
     * Filter which ApiConfigs to update
     */
    where?: ApiConfigWhereInput
    /**
     * Limit how many ApiConfigs to update.
     */
    limit?: number
  }

  /**
   * ApiConfig updateManyAndReturn
   */
  export type ApiConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * The data used to update ApiConfigs.
     */
    data: XOR<ApiConfigUpdateManyMutationInput, ApiConfigUncheckedUpdateManyInput>
    /**
     * Filter which ApiConfigs to update
     */
    where?: ApiConfigWhereInput
    /**
     * Limit how many ApiConfigs to update.
     */
    limit?: number
  }

  /**
   * ApiConfig upsert
   */
  export type ApiConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiConfig to update in case it exists.
     */
    where: ApiConfigWhereUniqueInput
    /**
     * In case the ApiConfig found by the `where` argument doesn't exist, create a new ApiConfig with this data.
     */
    create: XOR<ApiConfigCreateInput, ApiConfigUncheckedCreateInput>
    /**
     * In case the ApiConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiConfigUpdateInput, ApiConfigUncheckedUpdateInput>
  }

  /**
   * ApiConfig delete
   */
  export type ApiConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter which ApiConfig to delete.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig deleteMany
   */
  export type ApiConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiConfigs to delete
     */
    where?: ApiConfigWhereInput
    /**
     * Limit how many ApiConfigs to delete.
     */
    limit?: number
  }

  /**
   * ApiConfig.auditLogs
   */
  export type ApiConfig$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * ApiConfig without action
   */
  export type ApiConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    apiKeyId: number | null
    apiConfigId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    apiKeyId: number | null
    apiConfigId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    apiKeyId: number | null
    apiConfigId: number | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    apiKeyId: number | null
    apiConfigId: number | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    apiKeyId: number
    apiConfigId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    apiConfigId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    apiConfigId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    apiConfigId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    apiConfigId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    apiConfigId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number | null
    apiKeyId: number | null
    apiConfigId: number | null
    action: string
    details: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    apiConfigId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    apiConfigId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    apiConfigId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    apiConfigId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "apiKeyId" | "apiConfigId" | "action" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    apiKey?: boolean | AuditLog$apiKeyArgs<ExtArgs>
    apiConfig?: boolean | AuditLog$apiConfigArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      apiKey: Prisma.$ApiKeyPayload<ExtArgs> | null
      apiConfig: Prisma.$ApiConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      apiKeyId: number | null
      apiConfigId: number | null
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    apiKey<T extends AuditLog$apiKeyArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$apiKeyArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    apiConfig<T extends AuditLog$apiConfigArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$apiConfigArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly apiKeyId: FieldRef<"AuditLog", 'Int'>
    readonly apiConfigId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog.apiKey
   */
  export type AuditLog$apiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
  }

  /**
   * AuditLog.apiConfig
   */
  export type AuditLog$apiConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiConfig
     */
    omit?: ApiConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    where?: ApiConfigWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    avatar: 'avatar',
    otpToken: 'otpToken',
    otpExpires: 'otpExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    refreshToken: 'refreshToken',
    isApproved: 'isApproved'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    category_icon: 'category_icon',
    category_image: 'category_image',
    category_Alt_en: 'category_Alt_en',
    categoryLink_en: 'categoryLink_en',
    specification_image: 'specification_image',
    specification_image_alt: 'specification_image_alt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CategoryTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    name: 'name',
    iconAlt: 'iconAlt',
    categoryLink: 'categoryLink',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type CategoryTranslationScalarFieldEnum = (typeof CategoryTranslationScalarFieldEnum)[keyof typeof CategoryTranslationScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    model_name_en: 'model_name_en',
    product_name: 'product_name',
    productImage: 'productImage',
    productImage_Alt: 'productImage_Alt',
    status_en: 'status_en',
    stars: 'stars',
    reviews: 'reviews',
    productDescription_en: 'productDescription_en',
    model_description: 'model_description',
    introduction: 'introduction'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    name: 'name',
    imageAlt: 'imageAlt',
    status: 'status',
    productDescription: 'productDescription',
    model_description: 'model_description',
    introduction: 'introduction',
    productId: 'productId'
  };

  export type ProductTranslationScalarFieldEnum = (typeof ProductTranslationScalarFieldEnum)[keyof typeof ProductTranslationScalarFieldEnum]


  export const ModelSpecificationScalarFieldEnum: {
    id: 'id',
    title_en: 'title_en'
  };

  export type ModelSpecificationScalarFieldEnum = (typeof ModelSpecificationScalarFieldEnum)[keyof typeof ModelSpecificationScalarFieldEnum]


  export const ModelSpecificationTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    title: 'title',
    modelspecId: 'modelspecId'
  };

  export type ModelSpecificationTranslationScalarFieldEnum = (typeof ModelSpecificationTranslationScalarFieldEnum)[keyof typeof ModelSpecificationTranslationScalarFieldEnum]


  export const AdvantageScalarFieldEnum: {
    id: 'id',
    heading_en: 'heading_en',
    title_en: 'title_en'
  };

  export type AdvantageScalarFieldEnum = (typeof AdvantageScalarFieldEnum)[keyof typeof AdvantageScalarFieldEnum]


  export const AdvantageTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    heading: 'heading',
    title: 'title',
    advantageId: 'advantageId'
  };

  export type AdvantageTranslationScalarFieldEnum = (typeof AdvantageTranslationScalarFieldEnum)[keyof typeof AdvantageTranslationScalarFieldEnum]


  export const SpecificationScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    productId: 'productId',
    speed_en: 'speed_en',
    paperSpecification_en: 'paperSpecification_en',
    sizeRange_en: 'sizeRange_en'
  };

  export type SpecificationScalarFieldEnum = (typeof SpecificationScalarFieldEnum)[keyof typeof SpecificationScalarFieldEnum]


  export const SpecificationTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    speed: 'speed',
    paperSpecification: 'paperSpecification',
    sizeRange: 'sizeRange',
    specificationId: 'specificationId'
  };

  export type SpecificationTranslationScalarFieldEnum = (typeof SpecificationTranslationScalarFieldEnum)[keyof typeof SpecificationTranslationScalarFieldEnum]


  export const ApplicationDataScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    title_en: 'title_en',
    src: 'src',
    src_alt_en: 'src_alt_en'
  };

  export type ApplicationDataScalarFieldEnum = (typeof ApplicationDataScalarFieldEnum)[keyof typeof ApplicationDataScalarFieldEnum]


  export const ApplicationDataTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    title: 'title',
    src_alt: 'src_alt',
    applicationDataId: 'applicationDataId'
  };

  export type ApplicationDataTranslationScalarFieldEnum = (typeof ApplicationDataTranslationScalarFieldEnum)[keyof typeof ApplicationDataTranslationScalarFieldEnum]


  export const TechnicalSpecificationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    feature_en: 'feature_en',
    spec_en: 'spec_en'
  };

  export type TechnicalSpecificationScalarFieldEnum = (typeof TechnicalSpecificationScalarFieldEnum)[keyof typeof TechnicalSpecificationScalarFieldEnum]


  export const TechnicalSpecificationTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    feature: 'feature',
    spec: 'spec',
    technicalSpecificationId: 'technicalSpecificationId'
  };

  export type TechnicalSpecificationTranslationScalarFieldEnum = (typeof TechnicalSpecificationTranslationScalarFieldEnum)[keyof typeof TechnicalSpecificationTranslationScalarFieldEnum]


  export const RelatedProductScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    title_en: 'title_en',
    description_en: 'description_en',
    image: 'image',
    imageAlt_en: 'imageAlt_en',
    category_icon: 'category_icon',
    category_Alt_en: 'category_Alt_en',
    machineType: 'machineType'
  };

  export type RelatedProductScalarFieldEnum = (typeof RelatedProductScalarFieldEnum)[keyof typeof RelatedProductScalarFieldEnum]


  export const RelatedProductTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    title: 'title',
    description: 'description',
    imageAlt: 'imageAlt',
    category_Alt: 'category_Alt',
    machineType: 'machineType',
    relatedProductId: 'relatedProductId'
  };

  export type RelatedProductTranslationScalarFieldEnum = (typeof RelatedProductTranslationScalarFieldEnum)[keyof typeof RelatedProductTranslationScalarFieldEnum]


  export const ProcessStepScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    title_en: 'title_en',
    description_en: 'description_en',
    process_image: 'process_image',
    process_image_alt: 'process_image_alt'
  };

  export type ProcessStepScalarFieldEnum = (typeof ProcessStepScalarFieldEnum)[keyof typeof ProcessStepScalarFieldEnum]


  export const ProcessStepTranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    title: 'title',
    description: 'description',
    processStepId: 'processStepId'
  };

  export type ProcessStepTranslationScalarFieldEnum = (typeof ProcessStepTranslationScalarFieldEnum)[keyof typeof ProcessStepTranslationScalarFieldEnum]


  export const CTAScalarFieldEnum: {
    id: 'id',
    text_en: 'text_en',
    description_en: 'description_en',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CTAScalarFieldEnum = (typeof CTAScalarFieldEnum)[keyof typeof CTAScalarFieldEnum]


  export const CTATranslationScalarFieldEnum: {
    id: 'id',
    language: 'language',
    text: 'text',
    description: 'description',
    ctaId: 'ctaId'
  };

  export type CTATranslationScalarFieldEnum = (typeof CTATranslationScalarFieldEnum)[keyof typeof CTATranslationScalarFieldEnum]


  export const TranslationTaskScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    texts: 'texts',
    language: 'language',
    status: 'status',
    attempts: 'attempts',
    lastError: 'lastError',
    processingStartedAt: 'processingStartedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    apiKeyId: 'apiKeyId',
    apiUrl: 'apiUrl'
  };

  export type TranslationTaskScalarFieldEnum = (typeof TranslationTaskScalarFieldEnum)[keyof typeof TranslationTaskScalarFieldEnum]


  export const ContactSubmissionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactSubmissionScalarFieldEnum = (typeof ContactSubmissionScalarFieldEnum)[keyof typeof ContactSubmissionScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    keyValue: 'keyValue',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt',
    rateLimitPerMin: 'rateLimitPerMin',
    rateLimitCount: 'rateLimitCount',
    rateLimitReset: 'rateLimitReset',
    notes: 'notes'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ApiKeyUsageScalarFieldEnum: {
    id: 'id',
    apiKeyId: 'apiKeyId',
    requestAt: 'requestAt',
    statusCode: 'statusCode',
    durationMs: 'durationMs',
    endpoint: 'endpoint',
    errorMessage: 'errorMessage'
  };

  export type ApiKeyUsageScalarFieldEnum = (typeof ApiKeyUsageScalarFieldEnum)[keyof typeof ApiKeyUsageScalarFieldEnum]


  export const ApiConfigScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type ApiConfigScalarFieldEnum = (typeof ApiConfigScalarFieldEnum)[keyof typeof ApiConfigScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    apiKeyId: 'apiKeyId',
    apiConfigId: 'apiConfigId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LanguageCode'
   */
  export type EnumLanguageCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LanguageCode'>
    


  /**
   * Reference to a field of type 'LanguageCode[]'
   */
  export type ListEnumLanguageCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LanguageCode[]'>
    


  /**
   * Reference to a field of type 'MachineType'
   */
  export type EnumMachineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MachineType'>
    


  /**
   * Reference to a field of type 'MachineType[]'
   */
  export type ListEnumMachineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MachineType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    otpToken?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    refreshToken?: StringNullableFilter<"User"> | string | null
    isApproved?: BoolFilter<"User"> | boolean
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    otpToken?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    otpToken?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    refreshToken?: StringNullableFilter<"User"> | string | null
    isApproved?: BoolFilter<"User"> | boolean
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    otpToken?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    isApproved?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name_en?: StringFilter<"Category"> | string
    category_icon?: StringNullableFilter<"Category"> | string | null
    category_image?: StringNullableFilter<"Category"> | string | null
    category_Alt_en?: StringNullableFilter<"Category"> | string | null
    categoryLink_en?: StringNullableFilter<"Category"> | string | null
    specification_image?: StringNullableFilter<"Category"> | string | null
    specification_image_alt?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
    translations?: CategoryTranslationListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    category_icon?: SortOrderInput | SortOrder
    category_image?: SortOrderInput | SortOrder
    category_Alt_en?: SortOrderInput | SortOrder
    categoryLink_en?: SortOrderInput | SortOrder
    specification_image?: SortOrderInput | SortOrder
    specification_image_alt?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    translations?: CategoryTranslationOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_en?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    category_icon?: StringNullableFilter<"Category"> | string | null
    category_image?: StringNullableFilter<"Category"> | string | null
    category_Alt_en?: StringNullableFilter<"Category"> | string | null
    categoryLink_en?: StringNullableFilter<"Category"> | string | null
    specification_image?: StringNullableFilter<"Category"> | string | null
    specification_image_alt?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
    translations?: CategoryTranslationListRelationFilter
  }, "id" | "name_en">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    category_icon?: SortOrderInput | SortOrder
    category_image?: SortOrderInput | SortOrder
    category_Alt_en?: SortOrderInput | SortOrder
    categoryLink_en?: SortOrderInput | SortOrder
    specification_image?: SortOrderInput | SortOrder
    specification_image_alt?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name_en?: StringWithAggregatesFilter<"Category"> | string
    category_icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    category_image?: StringNullableWithAggregatesFilter<"Category"> | string | null
    category_Alt_en?: StringNullableWithAggregatesFilter<"Category"> | string | null
    categoryLink_en?: StringNullableWithAggregatesFilter<"Category"> | string | null
    specification_image?: StringNullableWithAggregatesFilter<"Category"> | string | null
    specification_image_alt?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type CategoryTranslationWhereInput = {
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    id?: IntFilter<"CategoryTranslation"> | number
    language?: EnumLanguageCodeFilter<"CategoryTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"CategoryTranslation"> | string
    iconAlt?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryLink?: StringNullableFilter<"CategoryTranslation"> | string | null
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryId?: IntFilter<"CategoryTranslation"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    products?: ProductTranslationListRelationFilter
  }

  export type CategoryTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    iconAlt?: SortOrderInput | SortOrder
    categoryLink?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    products?: ProductTranslationOrderByRelationAggregateInput
  }

  export type CategoryTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    categoryId_language?: CategoryTranslationCategoryIdLanguageCompoundUniqueInput
    AND?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    OR?: CategoryTranslationWhereInput[]
    NOT?: CategoryTranslationWhereInput | CategoryTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"CategoryTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"CategoryTranslation"> | string
    iconAlt?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryLink?: StringNullableFilter<"CategoryTranslation"> | string | null
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryId?: IntFilter<"CategoryTranslation"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    products?: ProductTranslationListRelationFilter
  }, "id" | "categoryId_language">

  export type CategoryTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    iconAlt?: SortOrderInput | SortOrder
    categoryLink?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: CategoryTranslationCountOrderByAggregateInput
    _avg?: CategoryTranslationAvgOrderByAggregateInput
    _max?: CategoryTranslationMaxOrderByAggregateInput
    _min?: CategoryTranslationMinOrderByAggregateInput
    _sum?: CategoryTranslationSumOrderByAggregateInput
  }

  export type CategoryTranslationScalarWhereWithAggregatesInput = {
    AND?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    OR?: CategoryTranslationScalarWhereWithAggregatesInput[]
    NOT?: CategoryTranslationScalarWhereWithAggregatesInput | CategoryTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CategoryTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"CategoryTranslation"> | $Enums.LanguageCode
    name?: StringWithAggregatesFilter<"CategoryTranslation"> | string
    iconAlt?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    categoryLink?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"CategoryTranslation"> | string | null
    categoryId?: IntWithAggregatesFilter<"CategoryTranslation"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    model_name_en?: StringFilter<"Product"> | string
    product_name?: StringNullableFilter<"Product"> | string | null
    productImage?: StringNullableFilter<"Product"> | string | null
    productImage_Alt?: StringNullableFilter<"Product"> | string | null
    status_en?: StringNullableFilter<"Product"> | string | null
    stars?: IntNullableFilter<"Product"> | number | null
    reviews?: IntNullableFilter<"Product"> | number | null
    productDescription_en?: StringNullableFilter<"Product"> | string | null
    model_description?: StringNullableFilter<"Product"> | string | null
    introduction?: StringNullableFilter<"Product"> | string | null
    categories?: CategoryListRelationFilter
    modelSpecification?: ModelSpecificationListRelationFilter
    advantages?: AdvantageListRelationFilter
    specifications?: SpecificationListRelationFilter
    applicationData?: ApplicationDataListRelationFilter
    technicalSpecifications?: TechnicalSpecificationListRelationFilter
    relatedProducts?: RelatedProductListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    translations?: ProductTranslationListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    model_name_en?: SortOrder
    product_name?: SortOrderInput | SortOrder
    productImage?: SortOrderInput | SortOrder
    productImage_Alt?: SortOrderInput | SortOrder
    status_en?: SortOrderInput | SortOrder
    stars?: SortOrderInput | SortOrder
    reviews?: SortOrderInput | SortOrder
    productDescription_en?: SortOrderInput | SortOrder
    model_description?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    modelSpecification?: modelSpecificationOrderByRelationAggregateInput
    advantages?: AdvantageOrderByRelationAggregateInput
    specifications?: SpecificationOrderByRelationAggregateInput
    applicationData?: ApplicationDataOrderByRelationAggregateInput
    technicalSpecifications?: TechnicalSpecificationOrderByRelationAggregateInput
    relatedProducts?: RelatedProductOrderByRelationAggregateInput
    processSteps?: ProcessStepOrderByRelationAggregateInput
    translations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    model_name_en?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    product_name?: StringNullableFilter<"Product"> | string | null
    productImage?: StringNullableFilter<"Product"> | string | null
    productImage_Alt?: StringNullableFilter<"Product"> | string | null
    status_en?: StringNullableFilter<"Product"> | string | null
    stars?: IntNullableFilter<"Product"> | number | null
    reviews?: IntNullableFilter<"Product"> | number | null
    productDescription_en?: StringNullableFilter<"Product"> | string | null
    model_description?: StringNullableFilter<"Product"> | string | null
    introduction?: StringNullableFilter<"Product"> | string | null
    categories?: CategoryListRelationFilter
    modelSpecification?: ModelSpecificationListRelationFilter
    advantages?: AdvantageListRelationFilter
    specifications?: SpecificationListRelationFilter
    applicationData?: ApplicationDataListRelationFilter
    technicalSpecifications?: TechnicalSpecificationListRelationFilter
    relatedProducts?: RelatedProductListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    translations?: ProductTranslationListRelationFilter
  }, "id" | "model_name_en">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    model_name_en?: SortOrder
    product_name?: SortOrderInput | SortOrder
    productImage?: SortOrderInput | SortOrder
    productImage_Alt?: SortOrderInput | SortOrder
    status_en?: SortOrderInput | SortOrder
    stars?: SortOrderInput | SortOrder
    reviews?: SortOrderInput | SortOrder
    productDescription_en?: SortOrderInput | SortOrder
    model_description?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    model_name_en?: StringWithAggregatesFilter<"Product"> | string
    product_name?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productImage?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productImage_Alt?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status_en?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stars?: IntNullableWithAggregatesFilter<"Product"> | number | null
    reviews?: IntNullableWithAggregatesFilter<"Product"> | number | null
    productDescription_en?: StringNullableWithAggregatesFilter<"Product"> | string | null
    model_description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    introduction?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type ProductTranslationWhereInput = {
    AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    OR?: ProductTranslationWhereInput[]
    NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    id?: IntFilter<"ProductTranslation"> | number
    language?: EnumLanguageCodeFilter<"ProductTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"ProductTranslation"> | string
    imageAlt?: StringNullableFilter<"ProductTranslation"> | string | null
    status?: StringNullableFilter<"ProductTranslation"> | string | null
    productDescription?: StringNullableFilter<"ProductTranslation"> | string | null
    model_description?: StringNullableFilter<"ProductTranslation"> | string | null
    introduction?: StringNullableFilter<"ProductTranslation"> | string | null
    productId?: IntFilter<"ProductTranslation"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    categories?: CategoryTranslationListRelationFilter
    advantages?: AdvantageListRelationFilter
    specifications?: SpecificationListRelationFilter
    applicationData?: ApplicationDataListRelationFilter
    technicalSpecifications?: TechnicalSpecificationListRelationFilter
    relatedProducts?: RelatedProductListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    modelSpecifications?: ModelSpecificationListRelationFilter
  }

  export type ProductTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    imageAlt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    model_description?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    categories?: CategoryTranslationOrderByRelationAggregateInput
    advantages?: AdvantageOrderByRelationAggregateInput
    specifications?: SpecificationOrderByRelationAggregateInput
    applicationData?: ApplicationDataOrderByRelationAggregateInput
    technicalSpecifications?: TechnicalSpecificationOrderByRelationAggregateInput
    relatedProducts?: RelatedProductOrderByRelationAggregateInput
    processSteps?: ProcessStepOrderByRelationAggregateInput
    modelSpecifications?: modelSpecificationOrderByRelationAggregateInput
  }

  export type ProductTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId_language?: ProductTranslationProductIdLanguageCompoundUniqueInput
    AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    OR?: ProductTranslationWhereInput[]
    NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"ProductTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"ProductTranslation"> | string
    imageAlt?: StringNullableFilter<"ProductTranslation"> | string | null
    status?: StringNullableFilter<"ProductTranslation"> | string | null
    productDescription?: StringNullableFilter<"ProductTranslation"> | string | null
    model_description?: StringNullableFilter<"ProductTranslation"> | string | null
    introduction?: StringNullableFilter<"ProductTranslation"> | string | null
    productId?: IntFilter<"ProductTranslation"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    categories?: CategoryTranslationListRelationFilter
    advantages?: AdvantageListRelationFilter
    specifications?: SpecificationListRelationFilter
    applicationData?: ApplicationDataListRelationFilter
    technicalSpecifications?: TechnicalSpecificationListRelationFilter
    relatedProducts?: RelatedProductListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    modelSpecifications?: ModelSpecificationListRelationFilter
  }, "id" | "productId_language">

  export type ProductTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    imageAlt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    model_description?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    productId?: SortOrder
    _count?: ProductTranslationCountOrderByAggregateInput
    _avg?: ProductTranslationAvgOrderByAggregateInput
    _max?: ProductTranslationMaxOrderByAggregateInput
    _min?: ProductTranslationMinOrderByAggregateInput
    _sum?: ProductTranslationSumOrderByAggregateInput
  }

  export type ProductTranslationScalarWhereWithAggregatesInput = {
    AND?: ProductTranslationScalarWhereWithAggregatesInput | ProductTranslationScalarWhereWithAggregatesInput[]
    OR?: ProductTranslationScalarWhereWithAggregatesInput[]
    NOT?: ProductTranslationScalarWhereWithAggregatesInput | ProductTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"ProductTranslation"> | $Enums.LanguageCode
    name?: StringWithAggregatesFilter<"ProductTranslation"> | string
    imageAlt?: StringNullableWithAggregatesFilter<"ProductTranslation"> | string | null
    status?: StringNullableWithAggregatesFilter<"ProductTranslation"> | string | null
    productDescription?: StringNullableWithAggregatesFilter<"ProductTranslation"> | string | null
    model_description?: StringNullableWithAggregatesFilter<"ProductTranslation"> | string | null
    introduction?: StringNullableWithAggregatesFilter<"ProductTranslation"> | string | null
    productId?: IntWithAggregatesFilter<"ProductTranslation"> | number
  }

  export type modelSpecificationWhereInput = {
    AND?: modelSpecificationWhereInput | modelSpecificationWhereInput[]
    OR?: modelSpecificationWhereInput[]
    NOT?: modelSpecificationWhereInput | modelSpecificationWhereInput[]
    id?: IntFilter<"modelSpecification"> | number
    title_en?: StringFilter<"modelSpecification"> | string
    products?: ProductListRelationFilter
    translations?: ModelSpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type modelSpecificationOrderByWithRelationInput = {
    id?: SortOrder
    title_en?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    translations?: modelSpecificationTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type modelSpecificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title_en?: string
    AND?: modelSpecificationWhereInput | modelSpecificationWhereInput[]
    OR?: modelSpecificationWhereInput[]
    NOT?: modelSpecificationWhereInput | modelSpecificationWhereInput[]
    products?: ProductListRelationFilter
    translations?: ModelSpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id" | "title_en">

  export type modelSpecificationOrderByWithAggregationInput = {
    id?: SortOrder
    title_en?: SortOrder
    _count?: modelSpecificationCountOrderByAggregateInput
    _avg?: modelSpecificationAvgOrderByAggregateInput
    _max?: modelSpecificationMaxOrderByAggregateInput
    _min?: modelSpecificationMinOrderByAggregateInput
    _sum?: modelSpecificationSumOrderByAggregateInput
  }

  export type modelSpecificationScalarWhereWithAggregatesInput = {
    AND?: modelSpecificationScalarWhereWithAggregatesInput | modelSpecificationScalarWhereWithAggregatesInput[]
    OR?: modelSpecificationScalarWhereWithAggregatesInput[]
    NOT?: modelSpecificationScalarWhereWithAggregatesInput | modelSpecificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"modelSpecification"> | number
    title_en?: StringWithAggregatesFilter<"modelSpecification"> | string
  }

  export type modelSpecificationTranslationWhereInput = {
    AND?: modelSpecificationTranslationWhereInput | modelSpecificationTranslationWhereInput[]
    OR?: modelSpecificationTranslationWhereInput[]
    NOT?: modelSpecificationTranslationWhereInput | modelSpecificationTranslationWhereInput[]
    id?: IntFilter<"modelSpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"modelSpecificationTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"modelSpecificationTranslation"> | string
    modelspecId?: IntFilter<"modelSpecificationTranslation"> | number
    modelSpec?: XOR<ModelSpecificationScalarRelationFilter, modelSpecificationWhereInput>
  }

  export type modelSpecificationTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    modelspecId?: SortOrder
    modelSpec?: modelSpecificationOrderByWithRelationInput
  }

  export type modelSpecificationTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    modelspecId_language?: modelSpecificationTranslationModelspecIdLanguageCompoundUniqueInput
    AND?: modelSpecificationTranslationWhereInput | modelSpecificationTranslationWhereInput[]
    OR?: modelSpecificationTranslationWhereInput[]
    NOT?: modelSpecificationTranslationWhereInput | modelSpecificationTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"modelSpecificationTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"modelSpecificationTranslation"> | string
    modelspecId?: IntFilter<"modelSpecificationTranslation"> | number
    modelSpec?: XOR<ModelSpecificationScalarRelationFilter, modelSpecificationWhereInput>
  }, "id" | "modelspecId_language">

  export type modelSpecificationTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    modelspecId?: SortOrder
    _count?: modelSpecificationTranslationCountOrderByAggregateInput
    _avg?: modelSpecificationTranslationAvgOrderByAggregateInput
    _max?: modelSpecificationTranslationMaxOrderByAggregateInput
    _min?: modelSpecificationTranslationMinOrderByAggregateInput
    _sum?: modelSpecificationTranslationSumOrderByAggregateInput
  }

  export type modelSpecificationTranslationScalarWhereWithAggregatesInput = {
    AND?: modelSpecificationTranslationScalarWhereWithAggregatesInput | modelSpecificationTranslationScalarWhereWithAggregatesInput[]
    OR?: modelSpecificationTranslationScalarWhereWithAggregatesInput[]
    NOT?: modelSpecificationTranslationScalarWhereWithAggregatesInput | modelSpecificationTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"modelSpecificationTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"modelSpecificationTranslation"> | $Enums.LanguageCode
    title?: StringWithAggregatesFilter<"modelSpecificationTranslation"> | string
    modelspecId?: IntWithAggregatesFilter<"modelSpecificationTranslation"> | number
  }

  export type AdvantageWhereInput = {
    AND?: AdvantageWhereInput | AdvantageWhereInput[]
    OR?: AdvantageWhereInput[]
    NOT?: AdvantageWhereInput | AdvantageWhereInput[]
    id?: IntFilter<"Advantage"> | number
    heading_en?: StringFilter<"Advantage"> | string
    title_en?: StringFilter<"Advantage"> | string
    products?: ProductListRelationFilter
    translations?: AdvantageTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type AdvantageOrderByWithRelationInput = {
    id?: SortOrder
    heading_en?: SortOrder
    title_en?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    translations?: AdvantageTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type AdvantageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title_en?: string
    AND?: AdvantageWhereInput | AdvantageWhereInput[]
    OR?: AdvantageWhereInput[]
    NOT?: AdvantageWhereInput | AdvantageWhereInput[]
    heading_en?: StringFilter<"Advantage"> | string
    products?: ProductListRelationFilter
    translations?: AdvantageTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id" | "title_en">

  export type AdvantageOrderByWithAggregationInput = {
    id?: SortOrder
    heading_en?: SortOrder
    title_en?: SortOrder
    _count?: AdvantageCountOrderByAggregateInput
    _avg?: AdvantageAvgOrderByAggregateInput
    _max?: AdvantageMaxOrderByAggregateInput
    _min?: AdvantageMinOrderByAggregateInput
    _sum?: AdvantageSumOrderByAggregateInput
  }

  export type AdvantageScalarWhereWithAggregatesInput = {
    AND?: AdvantageScalarWhereWithAggregatesInput | AdvantageScalarWhereWithAggregatesInput[]
    OR?: AdvantageScalarWhereWithAggregatesInput[]
    NOT?: AdvantageScalarWhereWithAggregatesInput | AdvantageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Advantage"> | number
    heading_en?: StringWithAggregatesFilter<"Advantage"> | string
    title_en?: StringWithAggregatesFilter<"Advantage"> | string
  }

  export type AdvantageTranslationWhereInput = {
    AND?: AdvantageTranslationWhereInput | AdvantageTranslationWhereInput[]
    OR?: AdvantageTranslationWhereInput[]
    NOT?: AdvantageTranslationWhereInput | AdvantageTranslationWhereInput[]
    id?: IntFilter<"AdvantageTranslation"> | number
    language?: EnumLanguageCodeFilter<"AdvantageTranslation"> | $Enums.LanguageCode
    heading?: StringFilter<"AdvantageTranslation"> | string
    title?: StringFilter<"AdvantageTranslation"> | string
    advantageId?: IntFilter<"AdvantageTranslation"> | number
    advantage?: XOR<AdvantageScalarRelationFilter, AdvantageWhereInput>
  }

  export type AdvantageTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    advantageId?: SortOrder
    advantage?: AdvantageOrderByWithRelationInput
  }

  export type AdvantageTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    advantageId_language?: AdvantageTranslationAdvantageIdLanguageCompoundUniqueInput
    AND?: AdvantageTranslationWhereInput | AdvantageTranslationWhereInput[]
    OR?: AdvantageTranslationWhereInput[]
    NOT?: AdvantageTranslationWhereInput | AdvantageTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"AdvantageTranslation"> | $Enums.LanguageCode
    heading?: StringFilter<"AdvantageTranslation"> | string
    title?: StringFilter<"AdvantageTranslation"> | string
    advantageId?: IntFilter<"AdvantageTranslation"> | number
    advantage?: XOR<AdvantageScalarRelationFilter, AdvantageWhereInput>
  }, "id" | "advantageId_language">

  export type AdvantageTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    advantageId?: SortOrder
    _count?: AdvantageTranslationCountOrderByAggregateInput
    _avg?: AdvantageTranslationAvgOrderByAggregateInput
    _max?: AdvantageTranslationMaxOrderByAggregateInput
    _min?: AdvantageTranslationMinOrderByAggregateInput
    _sum?: AdvantageTranslationSumOrderByAggregateInput
  }

  export type AdvantageTranslationScalarWhereWithAggregatesInput = {
    AND?: AdvantageTranslationScalarWhereWithAggregatesInput | AdvantageTranslationScalarWhereWithAggregatesInput[]
    OR?: AdvantageTranslationScalarWhereWithAggregatesInput[]
    NOT?: AdvantageTranslationScalarWhereWithAggregatesInput | AdvantageTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdvantageTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"AdvantageTranslation"> | $Enums.LanguageCode
    heading?: StringWithAggregatesFilter<"AdvantageTranslation"> | string
    title?: StringWithAggregatesFilter<"AdvantageTranslation"> | string
    advantageId?: IntWithAggregatesFilter<"AdvantageTranslation"> | number
  }

  export type SpecificationWhereInput = {
    AND?: SpecificationWhereInput | SpecificationWhereInput[]
    OR?: SpecificationWhereInput[]
    NOT?: SpecificationWhereInput | SpecificationWhereInput[]
    id?: IntFilter<"Specification"> | number
    categoryId?: IntNullableFilter<"Specification"> | number | null
    productId?: IntNullableFilter<"Specification"> | number | null
    speed_en?: StringNullableFilter<"Specification"> | string | null
    paperSpecification_en?: StringNullableFilter<"Specification"> | string | null
    sizeRange_en?: StringNullableFilter<"Specification"> | string | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    translations?: SpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type SpecificationOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    speed_en?: SortOrderInput | SortOrder
    paperSpecification_en?: SortOrderInput | SortOrder
    sizeRange_en?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    translations?: SpecificationTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type SpecificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpecificationWhereInput | SpecificationWhereInput[]
    OR?: SpecificationWhereInput[]
    NOT?: SpecificationWhereInput | SpecificationWhereInput[]
    categoryId?: IntNullableFilter<"Specification"> | number | null
    productId?: IntNullableFilter<"Specification"> | number | null
    speed_en?: StringNullableFilter<"Specification"> | string | null
    paperSpecification_en?: StringNullableFilter<"Specification"> | string | null
    sizeRange_en?: StringNullableFilter<"Specification"> | string | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    translations?: SpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id">

  export type SpecificationOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    speed_en?: SortOrderInput | SortOrder
    paperSpecification_en?: SortOrderInput | SortOrder
    sizeRange_en?: SortOrderInput | SortOrder
    _count?: SpecificationCountOrderByAggregateInput
    _avg?: SpecificationAvgOrderByAggregateInput
    _max?: SpecificationMaxOrderByAggregateInput
    _min?: SpecificationMinOrderByAggregateInput
    _sum?: SpecificationSumOrderByAggregateInput
  }

  export type SpecificationScalarWhereWithAggregatesInput = {
    AND?: SpecificationScalarWhereWithAggregatesInput | SpecificationScalarWhereWithAggregatesInput[]
    OR?: SpecificationScalarWhereWithAggregatesInput[]
    NOT?: SpecificationScalarWhereWithAggregatesInput | SpecificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Specification"> | number
    categoryId?: IntNullableWithAggregatesFilter<"Specification"> | number | null
    productId?: IntNullableWithAggregatesFilter<"Specification"> | number | null
    speed_en?: StringNullableWithAggregatesFilter<"Specification"> | string | null
    paperSpecification_en?: StringNullableWithAggregatesFilter<"Specification"> | string | null
    sizeRange_en?: StringNullableWithAggregatesFilter<"Specification"> | string | null
  }

  export type SpecificationTranslationWhereInput = {
    AND?: SpecificationTranslationWhereInput | SpecificationTranslationWhereInput[]
    OR?: SpecificationTranslationWhereInput[]
    NOT?: SpecificationTranslationWhereInput | SpecificationTranslationWhereInput[]
    id?: IntFilter<"SpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"SpecificationTranslation"> | $Enums.LanguageCode
    speed?: StringNullableFilter<"SpecificationTranslation"> | string | null
    paperSpecification?: StringNullableFilter<"SpecificationTranslation"> | string | null
    sizeRange?: StringNullableFilter<"SpecificationTranslation"> | string | null
    specificationId?: IntFilter<"SpecificationTranslation"> | number
    specification?: XOR<SpecificationScalarRelationFilter, SpecificationWhereInput>
  }

  export type SpecificationTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    speed?: SortOrderInput | SortOrder
    paperSpecification?: SortOrderInput | SortOrder
    sizeRange?: SortOrderInput | SortOrder
    specificationId?: SortOrder
    specification?: SpecificationOrderByWithRelationInput
  }

  export type SpecificationTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    specificationId_language?: SpecificationTranslationSpecificationIdLanguageCompoundUniqueInput
    AND?: SpecificationTranslationWhereInput | SpecificationTranslationWhereInput[]
    OR?: SpecificationTranslationWhereInput[]
    NOT?: SpecificationTranslationWhereInput | SpecificationTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"SpecificationTranslation"> | $Enums.LanguageCode
    speed?: StringNullableFilter<"SpecificationTranslation"> | string | null
    paperSpecification?: StringNullableFilter<"SpecificationTranslation"> | string | null
    sizeRange?: StringNullableFilter<"SpecificationTranslation"> | string | null
    specificationId?: IntFilter<"SpecificationTranslation"> | number
    specification?: XOR<SpecificationScalarRelationFilter, SpecificationWhereInput>
  }, "id" | "specificationId_language">

  export type SpecificationTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    speed?: SortOrderInput | SortOrder
    paperSpecification?: SortOrderInput | SortOrder
    sizeRange?: SortOrderInput | SortOrder
    specificationId?: SortOrder
    _count?: SpecificationTranslationCountOrderByAggregateInput
    _avg?: SpecificationTranslationAvgOrderByAggregateInput
    _max?: SpecificationTranslationMaxOrderByAggregateInput
    _min?: SpecificationTranslationMinOrderByAggregateInput
    _sum?: SpecificationTranslationSumOrderByAggregateInput
  }

  export type SpecificationTranslationScalarWhereWithAggregatesInput = {
    AND?: SpecificationTranslationScalarWhereWithAggregatesInput | SpecificationTranslationScalarWhereWithAggregatesInput[]
    OR?: SpecificationTranslationScalarWhereWithAggregatesInput[]
    NOT?: SpecificationTranslationScalarWhereWithAggregatesInput | SpecificationTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpecificationTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"SpecificationTranslation"> | $Enums.LanguageCode
    speed?: StringNullableWithAggregatesFilter<"SpecificationTranslation"> | string | null
    paperSpecification?: StringNullableWithAggregatesFilter<"SpecificationTranslation"> | string | null
    sizeRange?: StringNullableWithAggregatesFilter<"SpecificationTranslation"> | string | null
    specificationId?: IntWithAggregatesFilter<"SpecificationTranslation"> | number
  }

  export type ApplicationDataWhereInput = {
    AND?: ApplicationDataWhereInput | ApplicationDataWhereInput[]
    OR?: ApplicationDataWhereInput[]
    NOT?: ApplicationDataWhereInput | ApplicationDataWhereInput[]
    id?: IntFilter<"ApplicationData"> | number
    productId?: IntFilter<"ApplicationData"> | number
    title_en?: StringFilter<"ApplicationData"> | string
    src?: StringNullableFilter<"ApplicationData"> | string | null
    src_alt_en?: StringNullableFilter<"ApplicationData"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: ApplicationDataTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type ApplicationDataOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    src?: SortOrderInput | SortOrder
    src_alt_en?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    translations?: ApplicationDataTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type ApplicationDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApplicationDataWhereInput | ApplicationDataWhereInput[]
    OR?: ApplicationDataWhereInput[]
    NOT?: ApplicationDataWhereInput | ApplicationDataWhereInput[]
    productId?: IntFilter<"ApplicationData"> | number
    title_en?: StringFilter<"ApplicationData"> | string
    src?: StringNullableFilter<"ApplicationData"> | string | null
    src_alt_en?: StringNullableFilter<"ApplicationData"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: ApplicationDataTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id">

  export type ApplicationDataOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    src?: SortOrderInput | SortOrder
    src_alt_en?: SortOrderInput | SortOrder
    _count?: ApplicationDataCountOrderByAggregateInput
    _avg?: ApplicationDataAvgOrderByAggregateInput
    _max?: ApplicationDataMaxOrderByAggregateInput
    _min?: ApplicationDataMinOrderByAggregateInput
    _sum?: ApplicationDataSumOrderByAggregateInput
  }

  export type ApplicationDataScalarWhereWithAggregatesInput = {
    AND?: ApplicationDataScalarWhereWithAggregatesInput | ApplicationDataScalarWhereWithAggregatesInput[]
    OR?: ApplicationDataScalarWhereWithAggregatesInput[]
    NOT?: ApplicationDataScalarWhereWithAggregatesInput | ApplicationDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApplicationData"> | number
    productId?: IntWithAggregatesFilter<"ApplicationData"> | number
    title_en?: StringWithAggregatesFilter<"ApplicationData"> | string
    src?: StringNullableWithAggregatesFilter<"ApplicationData"> | string | null
    src_alt_en?: StringNullableWithAggregatesFilter<"ApplicationData"> | string | null
  }

  export type ApplicationDataTranslationWhereInput = {
    AND?: ApplicationDataTranslationWhereInput | ApplicationDataTranslationWhereInput[]
    OR?: ApplicationDataTranslationWhereInput[]
    NOT?: ApplicationDataTranslationWhereInput | ApplicationDataTranslationWhereInput[]
    id?: IntFilter<"ApplicationDataTranslation"> | number
    language?: EnumLanguageCodeFilter<"ApplicationDataTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ApplicationDataTranslation"> | string
    src_alt?: StringNullableFilter<"ApplicationDataTranslation"> | string | null
    applicationDataId?: IntFilter<"ApplicationDataTranslation"> | number
    applicationData?: XOR<ApplicationDataScalarRelationFilter, ApplicationDataWhereInput>
  }

  export type ApplicationDataTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    src_alt?: SortOrderInput | SortOrder
    applicationDataId?: SortOrder
    applicationData?: ApplicationDataOrderByWithRelationInput
  }

  export type ApplicationDataTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    applicationDataId_language?: ApplicationDataTranslationApplicationDataIdLanguageCompoundUniqueInput
    AND?: ApplicationDataTranslationWhereInput | ApplicationDataTranslationWhereInput[]
    OR?: ApplicationDataTranslationWhereInput[]
    NOT?: ApplicationDataTranslationWhereInput | ApplicationDataTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"ApplicationDataTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ApplicationDataTranslation"> | string
    src_alt?: StringNullableFilter<"ApplicationDataTranslation"> | string | null
    applicationDataId?: IntFilter<"ApplicationDataTranslation"> | number
    applicationData?: XOR<ApplicationDataScalarRelationFilter, ApplicationDataWhereInput>
  }, "id" | "applicationDataId_language">

  export type ApplicationDataTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    src_alt?: SortOrderInput | SortOrder
    applicationDataId?: SortOrder
    _count?: ApplicationDataTranslationCountOrderByAggregateInput
    _avg?: ApplicationDataTranslationAvgOrderByAggregateInput
    _max?: ApplicationDataTranslationMaxOrderByAggregateInput
    _min?: ApplicationDataTranslationMinOrderByAggregateInput
    _sum?: ApplicationDataTranslationSumOrderByAggregateInput
  }

  export type ApplicationDataTranslationScalarWhereWithAggregatesInput = {
    AND?: ApplicationDataTranslationScalarWhereWithAggregatesInput | ApplicationDataTranslationScalarWhereWithAggregatesInput[]
    OR?: ApplicationDataTranslationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationDataTranslationScalarWhereWithAggregatesInput | ApplicationDataTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApplicationDataTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"ApplicationDataTranslation"> | $Enums.LanguageCode
    title?: StringWithAggregatesFilter<"ApplicationDataTranslation"> | string
    src_alt?: StringNullableWithAggregatesFilter<"ApplicationDataTranslation"> | string | null
    applicationDataId?: IntWithAggregatesFilter<"ApplicationDataTranslation"> | number
  }

  export type TechnicalSpecificationWhereInput = {
    AND?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    OR?: TechnicalSpecificationWhereInput[]
    NOT?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    id?: IntFilter<"TechnicalSpecification"> | number
    productId?: IntFilter<"TechnicalSpecification"> | number
    feature_en?: StringFilter<"TechnicalSpecification"> | string
    spec_en?: StringFilter<"TechnicalSpecification"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: TechnicalSpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type TechnicalSpecificationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    feature_en?: SortOrder
    spec_en?: SortOrder
    product?: ProductOrderByWithRelationInput
    translations?: TechnicalSpecificationTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type TechnicalSpecificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    OR?: TechnicalSpecificationWhereInput[]
    NOT?: TechnicalSpecificationWhereInput | TechnicalSpecificationWhereInput[]
    productId?: IntFilter<"TechnicalSpecification"> | number
    feature_en?: StringFilter<"TechnicalSpecification"> | string
    spec_en?: StringFilter<"TechnicalSpecification"> | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: TechnicalSpecificationTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id">

  export type TechnicalSpecificationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    feature_en?: SortOrder
    spec_en?: SortOrder
    _count?: TechnicalSpecificationCountOrderByAggregateInput
    _avg?: TechnicalSpecificationAvgOrderByAggregateInput
    _max?: TechnicalSpecificationMaxOrderByAggregateInput
    _min?: TechnicalSpecificationMinOrderByAggregateInput
    _sum?: TechnicalSpecificationSumOrderByAggregateInput
  }

  export type TechnicalSpecificationScalarWhereWithAggregatesInput = {
    AND?: TechnicalSpecificationScalarWhereWithAggregatesInput | TechnicalSpecificationScalarWhereWithAggregatesInput[]
    OR?: TechnicalSpecificationScalarWhereWithAggregatesInput[]
    NOT?: TechnicalSpecificationScalarWhereWithAggregatesInput | TechnicalSpecificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TechnicalSpecification"> | number
    productId?: IntWithAggregatesFilter<"TechnicalSpecification"> | number
    feature_en?: StringWithAggregatesFilter<"TechnicalSpecification"> | string
    spec_en?: StringWithAggregatesFilter<"TechnicalSpecification"> | string
  }

  export type TechnicalSpecificationTranslationWhereInput = {
    AND?: TechnicalSpecificationTranslationWhereInput | TechnicalSpecificationTranslationWhereInput[]
    OR?: TechnicalSpecificationTranslationWhereInput[]
    NOT?: TechnicalSpecificationTranslationWhereInput | TechnicalSpecificationTranslationWhereInput[]
    id?: IntFilter<"TechnicalSpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"TechnicalSpecificationTranslation"> | $Enums.LanguageCode
    feature?: StringFilter<"TechnicalSpecificationTranslation"> | string
    spec?: StringFilter<"TechnicalSpecificationTranslation"> | string
    technicalSpecificationId?: IntFilter<"TechnicalSpecificationTranslation"> | number
    technicalSpecification?: XOR<TechnicalSpecificationScalarRelationFilter, TechnicalSpecificationWhereInput>
  }

  export type TechnicalSpecificationTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    feature?: SortOrder
    spec?: SortOrder
    technicalSpecificationId?: SortOrder
    technicalSpecification?: TechnicalSpecificationOrderByWithRelationInput
  }

  export type TechnicalSpecificationTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    technicalSpecificationId_language?: TechnicalSpecificationTranslationTechnicalSpecificationIdLanguageCompoundUniqueInput
    AND?: TechnicalSpecificationTranslationWhereInput | TechnicalSpecificationTranslationWhereInput[]
    OR?: TechnicalSpecificationTranslationWhereInput[]
    NOT?: TechnicalSpecificationTranslationWhereInput | TechnicalSpecificationTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"TechnicalSpecificationTranslation"> | $Enums.LanguageCode
    feature?: StringFilter<"TechnicalSpecificationTranslation"> | string
    spec?: StringFilter<"TechnicalSpecificationTranslation"> | string
    technicalSpecificationId?: IntFilter<"TechnicalSpecificationTranslation"> | number
    technicalSpecification?: XOR<TechnicalSpecificationScalarRelationFilter, TechnicalSpecificationWhereInput>
  }, "id" | "technicalSpecificationId_language">

  export type TechnicalSpecificationTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    feature?: SortOrder
    spec?: SortOrder
    technicalSpecificationId?: SortOrder
    _count?: TechnicalSpecificationTranslationCountOrderByAggregateInput
    _avg?: TechnicalSpecificationTranslationAvgOrderByAggregateInput
    _max?: TechnicalSpecificationTranslationMaxOrderByAggregateInput
    _min?: TechnicalSpecificationTranslationMinOrderByAggregateInput
    _sum?: TechnicalSpecificationTranslationSumOrderByAggregateInput
  }

  export type TechnicalSpecificationTranslationScalarWhereWithAggregatesInput = {
    AND?: TechnicalSpecificationTranslationScalarWhereWithAggregatesInput | TechnicalSpecificationTranslationScalarWhereWithAggregatesInput[]
    OR?: TechnicalSpecificationTranslationScalarWhereWithAggregatesInput[]
    NOT?: TechnicalSpecificationTranslationScalarWhereWithAggregatesInput | TechnicalSpecificationTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TechnicalSpecificationTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"TechnicalSpecificationTranslation"> | $Enums.LanguageCode
    feature?: StringWithAggregatesFilter<"TechnicalSpecificationTranslation"> | string
    spec?: StringWithAggregatesFilter<"TechnicalSpecificationTranslation"> | string
    technicalSpecificationId?: IntWithAggregatesFilter<"TechnicalSpecificationTranslation"> | number
  }

  export type RelatedProductWhereInput = {
    AND?: RelatedProductWhereInput | RelatedProductWhereInput[]
    OR?: RelatedProductWhereInput[]
    NOT?: RelatedProductWhereInput | RelatedProductWhereInput[]
    id?: IntFilter<"RelatedProduct"> | number
    productId?: IntFilter<"RelatedProduct"> | number
    title_en?: StringFilter<"RelatedProduct"> | string
    description_en?: StringNullableFilter<"RelatedProduct"> | string | null
    image?: StringNullableFilter<"RelatedProduct"> | string | null
    imageAlt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    category_icon?: StringNullableFilter<"RelatedProduct"> | string | null
    category_Alt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProduct"> | $Enums.MachineType
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: RelatedProductTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type RelatedProductOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    imageAlt_en?: SortOrderInput | SortOrder
    category_icon?: SortOrderInput | SortOrder
    category_Alt_en?: SortOrderInput | SortOrder
    machineType?: SortOrder
    product?: ProductOrderByWithRelationInput
    translations?: RelatedProductTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type RelatedProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelatedProductWhereInput | RelatedProductWhereInput[]
    OR?: RelatedProductWhereInput[]
    NOT?: RelatedProductWhereInput | RelatedProductWhereInput[]
    productId?: IntFilter<"RelatedProduct"> | number
    title_en?: StringFilter<"RelatedProduct"> | string
    description_en?: StringNullableFilter<"RelatedProduct"> | string | null
    image?: StringNullableFilter<"RelatedProduct"> | string | null
    imageAlt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    category_icon?: StringNullableFilter<"RelatedProduct"> | string | null
    category_Alt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProduct"> | $Enums.MachineType
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: RelatedProductTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id">

  export type RelatedProductOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    imageAlt_en?: SortOrderInput | SortOrder
    category_icon?: SortOrderInput | SortOrder
    category_Alt_en?: SortOrderInput | SortOrder
    machineType?: SortOrder
    _count?: RelatedProductCountOrderByAggregateInput
    _avg?: RelatedProductAvgOrderByAggregateInput
    _max?: RelatedProductMaxOrderByAggregateInput
    _min?: RelatedProductMinOrderByAggregateInput
    _sum?: RelatedProductSumOrderByAggregateInput
  }

  export type RelatedProductScalarWhereWithAggregatesInput = {
    AND?: RelatedProductScalarWhereWithAggregatesInput | RelatedProductScalarWhereWithAggregatesInput[]
    OR?: RelatedProductScalarWhereWithAggregatesInput[]
    NOT?: RelatedProductScalarWhereWithAggregatesInput | RelatedProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelatedProduct"> | number
    productId?: IntWithAggregatesFilter<"RelatedProduct"> | number
    title_en?: StringWithAggregatesFilter<"RelatedProduct"> | string
    description_en?: StringNullableWithAggregatesFilter<"RelatedProduct"> | string | null
    image?: StringNullableWithAggregatesFilter<"RelatedProduct"> | string | null
    imageAlt_en?: StringNullableWithAggregatesFilter<"RelatedProduct"> | string | null
    category_icon?: StringNullableWithAggregatesFilter<"RelatedProduct"> | string | null
    category_Alt_en?: StringNullableWithAggregatesFilter<"RelatedProduct"> | string | null
    machineType?: EnumMachineTypeWithAggregatesFilter<"RelatedProduct"> | $Enums.MachineType
  }

  export type RelatedProductTranslationWhereInput = {
    AND?: RelatedProductTranslationWhereInput | RelatedProductTranslationWhereInput[]
    OR?: RelatedProductTranslationWhereInput[]
    NOT?: RelatedProductTranslationWhereInput | RelatedProductTranslationWhereInput[]
    id?: IntFilter<"RelatedProductTranslation"> | number
    language?: EnumLanguageCodeFilter<"RelatedProductTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"RelatedProductTranslation"> | string
    description?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    imageAlt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    category_Alt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProductTranslation"> | $Enums.MachineType
    relatedProductId?: IntFilter<"RelatedProductTranslation"> | number
    relatedProduct?: XOR<RelatedProductScalarRelationFilter, RelatedProductWhereInput>
  }

  export type RelatedProductTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageAlt?: SortOrderInput | SortOrder
    category_Alt?: SortOrderInput | SortOrder
    machineType?: SortOrder
    relatedProductId?: SortOrder
    relatedProduct?: RelatedProductOrderByWithRelationInput
  }

  export type RelatedProductTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    relatedProductId_language?: RelatedProductTranslationRelatedProductIdLanguageCompoundUniqueInput
    AND?: RelatedProductTranslationWhereInput | RelatedProductTranslationWhereInput[]
    OR?: RelatedProductTranslationWhereInput[]
    NOT?: RelatedProductTranslationWhereInput | RelatedProductTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"RelatedProductTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"RelatedProductTranslation"> | string
    description?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    imageAlt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    category_Alt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProductTranslation"> | $Enums.MachineType
    relatedProductId?: IntFilter<"RelatedProductTranslation"> | number
    relatedProduct?: XOR<RelatedProductScalarRelationFilter, RelatedProductWhereInput>
  }, "id" | "relatedProductId_language">

  export type RelatedProductTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageAlt?: SortOrderInput | SortOrder
    category_Alt?: SortOrderInput | SortOrder
    machineType?: SortOrder
    relatedProductId?: SortOrder
    _count?: RelatedProductTranslationCountOrderByAggregateInput
    _avg?: RelatedProductTranslationAvgOrderByAggregateInput
    _max?: RelatedProductTranslationMaxOrderByAggregateInput
    _min?: RelatedProductTranslationMinOrderByAggregateInput
    _sum?: RelatedProductTranslationSumOrderByAggregateInput
  }

  export type RelatedProductTranslationScalarWhereWithAggregatesInput = {
    AND?: RelatedProductTranslationScalarWhereWithAggregatesInput | RelatedProductTranslationScalarWhereWithAggregatesInput[]
    OR?: RelatedProductTranslationScalarWhereWithAggregatesInput[]
    NOT?: RelatedProductTranslationScalarWhereWithAggregatesInput | RelatedProductTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelatedProductTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"RelatedProductTranslation"> | $Enums.LanguageCode
    title?: StringWithAggregatesFilter<"RelatedProductTranslation"> | string
    description?: StringNullableWithAggregatesFilter<"RelatedProductTranslation"> | string | null
    imageAlt?: StringNullableWithAggregatesFilter<"RelatedProductTranslation"> | string | null
    category_Alt?: StringNullableWithAggregatesFilter<"RelatedProductTranslation"> | string | null
    machineType?: EnumMachineTypeWithAggregatesFilter<"RelatedProductTranslation"> | $Enums.MachineType
    relatedProductId?: IntWithAggregatesFilter<"RelatedProductTranslation"> | number
  }

  export type ProcessStepWhereInput = {
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    id?: IntFilter<"ProcessStep"> | number
    productId?: IntFilter<"ProcessStep"> | number
    title_en?: StringFilter<"ProcessStep"> | string
    description_en?: StringFilter<"ProcessStep"> | string
    process_image?: StringNullableFilter<"ProcessStep"> | string | null
    process_image_alt?: StringNullableFilter<"ProcessStep"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: ProcessStepTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }

  export type ProcessStepOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    process_image?: SortOrderInput | SortOrder
    process_image_alt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    translations?: ProcessStepTranslationOrderByRelationAggregateInput
    productTranslations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type ProcessStepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    productId?: IntFilter<"ProcessStep"> | number
    title_en?: StringFilter<"ProcessStep"> | string
    description_en?: StringFilter<"ProcessStep"> | string
    process_image?: StringNullableFilter<"ProcessStep"> | string | null
    process_image_alt?: StringNullableFilter<"ProcessStep"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    translations?: ProcessStepTranslationListRelationFilter
    productTranslations?: ProductTranslationListRelationFilter
  }, "id">

  export type ProcessStepOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    process_image?: SortOrderInput | SortOrder
    process_image_alt?: SortOrderInput | SortOrder
    _count?: ProcessStepCountOrderByAggregateInput
    _avg?: ProcessStepAvgOrderByAggregateInput
    _max?: ProcessStepMaxOrderByAggregateInput
    _min?: ProcessStepMinOrderByAggregateInput
    _sum?: ProcessStepSumOrderByAggregateInput
  }

  export type ProcessStepScalarWhereWithAggregatesInput = {
    AND?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    OR?: ProcessStepScalarWhereWithAggregatesInput[]
    NOT?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessStep"> | number
    productId?: IntWithAggregatesFilter<"ProcessStep"> | number
    title_en?: StringWithAggregatesFilter<"ProcessStep"> | string
    description_en?: StringWithAggregatesFilter<"ProcessStep"> | string
    process_image?: StringNullableWithAggregatesFilter<"ProcessStep"> | string | null
    process_image_alt?: StringNullableWithAggregatesFilter<"ProcessStep"> | string | null
  }

  export type ProcessStepTranslationWhereInput = {
    AND?: ProcessStepTranslationWhereInput | ProcessStepTranslationWhereInput[]
    OR?: ProcessStepTranslationWhereInput[]
    NOT?: ProcessStepTranslationWhereInput | ProcessStepTranslationWhereInput[]
    id?: IntFilter<"ProcessStepTranslation"> | number
    language?: EnumLanguageCodeFilter<"ProcessStepTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ProcessStepTranslation"> | string
    description?: StringFilter<"ProcessStepTranslation"> | string
    processStepId?: IntFilter<"ProcessStepTranslation"> | number
    processStep?: XOR<ProcessStepScalarRelationFilter, ProcessStepWhereInput>
  }

  export type ProcessStepTranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    processStepId?: SortOrder
    processStep?: ProcessStepOrderByWithRelationInput
  }

  export type ProcessStepTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    processStepId_language?: ProcessStepTranslationProcessStepIdLanguageCompoundUniqueInput
    AND?: ProcessStepTranslationWhereInput | ProcessStepTranslationWhereInput[]
    OR?: ProcessStepTranslationWhereInput[]
    NOT?: ProcessStepTranslationWhereInput | ProcessStepTranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"ProcessStepTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ProcessStepTranslation"> | string
    description?: StringFilter<"ProcessStepTranslation"> | string
    processStepId?: IntFilter<"ProcessStepTranslation"> | number
    processStep?: XOR<ProcessStepScalarRelationFilter, ProcessStepWhereInput>
  }, "id" | "processStepId_language">

  export type ProcessStepTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    processStepId?: SortOrder
    _count?: ProcessStepTranslationCountOrderByAggregateInput
    _avg?: ProcessStepTranslationAvgOrderByAggregateInput
    _max?: ProcessStepTranslationMaxOrderByAggregateInput
    _min?: ProcessStepTranslationMinOrderByAggregateInput
    _sum?: ProcessStepTranslationSumOrderByAggregateInput
  }

  export type ProcessStepTranslationScalarWhereWithAggregatesInput = {
    AND?: ProcessStepTranslationScalarWhereWithAggregatesInput | ProcessStepTranslationScalarWhereWithAggregatesInput[]
    OR?: ProcessStepTranslationScalarWhereWithAggregatesInput[]
    NOT?: ProcessStepTranslationScalarWhereWithAggregatesInput | ProcessStepTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProcessStepTranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"ProcessStepTranslation"> | $Enums.LanguageCode
    title?: StringWithAggregatesFilter<"ProcessStepTranslation"> | string
    description?: StringWithAggregatesFilter<"ProcessStepTranslation"> | string
    processStepId?: IntWithAggregatesFilter<"ProcessStepTranslation"> | number
  }

  export type CTAWhereInput = {
    AND?: CTAWhereInput | CTAWhereInput[]
    OR?: CTAWhereInput[]
    NOT?: CTAWhereInput | CTAWhereInput[]
    id?: IntFilter<"CTA"> | number
    text_en?: StringFilter<"CTA"> | string
    description_en?: StringNullableFilter<"CTA"> | string | null
    createdAt?: DateTimeFilter<"CTA"> | Date | string
    updatedAt?: DateTimeFilter<"CTA"> | Date | string
    translations?: CTATranslationListRelationFilter
  }

  export type CTAOrderByWithRelationInput = {
    id?: SortOrder
    text_en?: SortOrder
    description_en?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: CTATranslationOrderByRelationAggregateInput
  }

  export type CTAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    text_en?: string
    AND?: CTAWhereInput | CTAWhereInput[]
    OR?: CTAWhereInput[]
    NOT?: CTAWhereInput | CTAWhereInput[]
    description_en?: StringNullableFilter<"CTA"> | string | null
    createdAt?: DateTimeFilter<"CTA"> | Date | string
    updatedAt?: DateTimeFilter<"CTA"> | Date | string
    translations?: CTATranslationListRelationFilter
  }, "id" | "text_en">

  export type CTAOrderByWithAggregationInput = {
    id?: SortOrder
    text_en?: SortOrder
    description_en?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CTACountOrderByAggregateInput
    _avg?: CTAAvgOrderByAggregateInput
    _max?: CTAMaxOrderByAggregateInput
    _min?: CTAMinOrderByAggregateInput
    _sum?: CTASumOrderByAggregateInput
  }

  export type CTAScalarWhereWithAggregatesInput = {
    AND?: CTAScalarWhereWithAggregatesInput | CTAScalarWhereWithAggregatesInput[]
    OR?: CTAScalarWhereWithAggregatesInput[]
    NOT?: CTAScalarWhereWithAggregatesInput | CTAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CTA"> | number
    text_en?: StringWithAggregatesFilter<"CTA"> | string
    description_en?: StringNullableWithAggregatesFilter<"CTA"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CTA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CTA"> | Date | string
  }

  export type CTATranslationWhereInput = {
    AND?: CTATranslationWhereInput | CTATranslationWhereInput[]
    OR?: CTATranslationWhereInput[]
    NOT?: CTATranslationWhereInput | CTATranslationWhereInput[]
    id?: IntFilter<"CTATranslation"> | number
    language?: EnumLanguageCodeFilter<"CTATranslation"> | $Enums.LanguageCode
    text?: StringFilter<"CTATranslation"> | string
    description?: StringNullableFilter<"CTATranslation"> | string | null
    ctaId?: IntFilter<"CTATranslation"> | number
    cta?: XOR<CTAScalarRelationFilter, CTAWhereInput>
  }

  export type CTATranslationOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    ctaId?: SortOrder
    cta?: CTAOrderByWithRelationInput
  }

  export type CTATranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ctaId_language?: CTATranslationCtaIdLanguageCompoundUniqueInput
    AND?: CTATranslationWhereInput | CTATranslationWhereInput[]
    OR?: CTATranslationWhereInput[]
    NOT?: CTATranslationWhereInput | CTATranslationWhereInput[]
    language?: EnumLanguageCodeFilter<"CTATranslation"> | $Enums.LanguageCode
    text?: StringFilter<"CTATranslation"> | string
    description?: StringNullableFilter<"CTATranslation"> | string | null
    ctaId?: IntFilter<"CTATranslation"> | number
    cta?: XOR<CTAScalarRelationFilter, CTAWhereInput>
  }, "id" | "ctaId_language">

  export type CTATranslationOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    ctaId?: SortOrder
    _count?: CTATranslationCountOrderByAggregateInput
    _avg?: CTATranslationAvgOrderByAggregateInput
    _max?: CTATranslationMaxOrderByAggregateInput
    _min?: CTATranslationMinOrderByAggregateInput
    _sum?: CTATranslationSumOrderByAggregateInput
  }

  export type CTATranslationScalarWhereWithAggregatesInput = {
    AND?: CTATranslationScalarWhereWithAggregatesInput | CTATranslationScalarWhereWithAggregatesInput[]
    OR?: CTATranslationScalarWhereWithAggregatesInput[]
    NOT?: CTATranslationScalarWhereWithAggregatesInput | CTATranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CTATranslation"> | number
    language?: EnumLanguageCodeWithAggregatesFilter<"CTATranslation"> | $Enums.LanguageCode
    text?: StringWithAggregatesFilter<"CTATranslation"> | string
    description?: StringNullableWithAggregatesFilter<"CTATranslation"> | string | null
    ctaId?: IntWithAggregatesFilter<"CTATranslation"> | number
  }

  export type TranslationTaskWhereInput = {
    AND?: TranslationTaskWhereInput | TranslationTaskWhereInput[]
    OR?: TranslationTaskWhereInput[]
    NOT?: TranslationTaskWhereInput | TranslationTaskWhereInput[]
    id?: IntFilter<"TranslationTask"> | number
    entityType?: StringFilter<"TranslationTask"> | string
    entityId?: IntFilter<"TranslationTask"> | number
    texts?: JsonFilter<"TranslationTask">
    language?: EnumLanguageCodeFilter<"TranslationTask"> | $Enums.LanguageCode
    status?: StringFilter<"TranslationTask"> | string
    attempts?: IntFilter<"TranslationTask"> | number
    lastError?: StringNullableFilter<"TranslationTask"> | string | null
    processingStartedAt?: DateTimeNullableFilter<"TranslationTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TranslationTask"> | Date | string
    updatedAt?: DateTimeFilter<"TranslationTask"> | Date | string
    apiKeyId?: IntNullableFilter<"TranslationTask"> | number | null
    apiUrl?: StringNullableFilter<"TranslationTask"> | string | null
    apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null
  }

  export type TranslationTaskOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    texts?: SortOrder
    language?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: ApiKeyOrderByWithRelationInput
  }

  export type TranslationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    entityType_entityId_language?: TranslationTaskEntityTypeEntityIdLanguageCompoundUniqueInput
    AND?: TranslationTaskWhereInput | TranslationTaskWhereInput[]
    OR?: TranslationTaskWhereInput[]
    NOT?: TranslationTaskWhereInput | TranslationTaskWhereInput[]
    entityType?: StringFilter<"TranslationTask"> | string
    entityId?: IntFilter<"TranslationTask"> | number
    texts?: JsonFilter<"TranslationTask">
    language?: EnumLanguageCodeFilter<"TranslationTask"> | $Enums.LanguageCode
    status?: StringFilter<"TranslationTask"> | string
    attempts?: IntFilter<"TranslationTask"> | number
    lastError?: StringNullableFilter<"TranslationTask"> | string | null
    processingStartedAt?: DateTimeNullableFilter<"TranslationTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TranslationTask"> | Date | string
    updatedAt?: DateTimeFilter<"TranslationTask"> | Date | string
    apiKeyId?: IntNullableFilter<"TranslationTask"> | number | null
    apiUrl?: StringNullableFilter<"TranslationTask"> | string | null
    apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null
  }, "id" | "entityType_entityId_language">

  export type TranslationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    texts?: SortOrder
    language?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    _count?: TranslationTaskCountOrderByAggregateInput
    _avg?: TranslationTaskAvgOrderByAggregateInput
    _max?: TranslationTaskMaxOrderByAggregateInput
    _min?: TranslationTaskMinOrderByAggregateInput
    _sum?: TranslationTaskSumOrderByAggregateInput
  }

  export type TranslationTaskScalarWhereWithAggregatesInput = {
    AND?: TranslationTaskScalarWhereWithAggregatesInput | TranslationTaskScalarWhereWithAggregatesInput[]
    OR?: TranslationTaskScalarWhereWithAggregatesInput[]
    NOT?: TranslationTaskScalarWhereWithAggregatesInput | TranslationTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TranslationTask"> | number
    entityType?: StringWithAggregatesFilter<"TranslationTask"> | string
    entityId?: IntWithAggregatesFilter<"TranslationTask"> | number
    texts?: JsonWithAggregatesFilter<"TranslationTask">
    language?: EnumLanguageCodeWithAggregatesFilter<"TranslationTask"> | $Enums.LanguageCode
    status?: StringWithAggregatesFilter<"TranslationTask"> | string
    attempts?: IntWithAggregatesFilter<"TranslationTask"> | number
    lastError?: StringNullableWithAggregatesFilter<"TranslationTask"> | string | null
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"TranslationTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TranslationTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TranslationTask"> | Date | string
    apiKeyId?: IntNullableWithAggregatesFilter<"TranslationTask"> | number | null
    apiUrl?: StringNullableWithAggregatesFilter<"TranslationTask"> | string | null
  }

  export type ContactSubmissionWhereInput = {
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    id?: IntFilter<"ContactSubmission"> | number
    title?: StringFilter<"ContactSubmission"> | string
    description?: StringNullableFilter<"ContactSubmission"> | string | null
    fullName?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    phone?: StringFilter<"ContactSubmission"> | string
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }

  export type ContactSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    title?: StringFilter<"ContactSubmission"> | string
    description?: StringNullableFilter<"ContactSubmission"> | string | null
    fullName?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    phone?: StringFilter<"ContactSubmission"> | string
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }, "id">

  export type ContactSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactSubmissionCountOrderByAggregateInput
    _avg?: ContactSubmissionAvgOrderByAggregateInput
    _max?: ContactSubmissionMaxOrderByAggregateInput
    _min?: ContactSubmissionMinOrderByAggregateInput
    _sum?: ContactSubmissionSumOrderByAggregateInput
  }

  export type ContactSubmissionScalarWhereWithAggregatesInput = {
    AND?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    OR?: ContactSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactSubmission"> | number
    title?: StringWithAggregatesFilter<"ContactSubmission"> | string
    description?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    fullName?: StringWithAggregatesFilter<"ContactSubmission"> | string
    email?: StringWithAggregatesFilter<"ContactSubmission"> | string
    phone?: StringWithAggregatesFilter<"ContactSubmission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    keyValue?: StringFilter<"ApiKey"> | string
    status?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    rateLimitPerMin?: IntNullableFilter<"ApiKey"> | number | null
    rateLimitCount?: IntFilter<"ApiKey"> | number
    rateLimitReset?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    notes?: StringNullableFilter<"ApiKey"> | string | null
    usageLogs?: ApiKeyUsageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    translationTasks?: TranslationTaskListRelationFilter
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    keyValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    rateLimitPerMin?: SortOrderInput | SortOrder
    rateLimitCount?: SortOrder
    rateLimitReset?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    usageLogs?: ApiKeyUsageOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    translationTasks?: TranslationTaskOrderByRelationAggregateInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    keyValue?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    status?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    rateLimitPerMin?: IntNullableFilter<"ApiKey"> | number | null
    rateLimitCount?: IntFilter<"ApiKey"> | number
    rateLimitReset?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    notes?: StringNullableFilter<"ApiKey"> | string | null
    usageLogs?: ApiKeyUsageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    translationTasks?: TranslationTaskListRelationFilter
  }, "id" | "keyValue">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    keyValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    rateLimitPerMin?: SortOrderInput | SortOrder
    rateLimitCount?: SortOrder
    rateLimitReset?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiKey"> | number
    keyValue?: StringWithAggregatesFilter<"ApiKey"> | string
    status?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    rateLimitPerMin?: IntNullableWithAggregatesFilter<"ApiKey"> | number | null
    rateLimitCount?: IntWithAggregatesFilter<"ApiKey"> | number
    rateLimitReset?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
  }

  export type ApiKeyUsageWhereInput = {
    AND?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    OR?: ApiKeyUsageWhereInput[]
    NOT?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    id?: IntFilter<"ApiKeyUsage"> | number
    apiKeyId?: IntFilter<"ApiKeyUsage"> | number
    requestAt?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    statusCode?: IntFilter<"ApiKeyUsage"> | number
    durationMs?: IntFilter<"ApiKeyUsage"> | number
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    errorMessage?: StringNullableFilter<"ApiKeyUsage"> | string | null
    apiKey?: XOR<ApiKeyScalarRelationFilter, ApiKeyWhereInput>
  }

  export type ApiKeyUsageOrderByWithRelationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    requestAt?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
    endpoint?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    apiKey?: ApiKeyOrderByWithRelationInput
  }

  export type ApiKeyUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    OR?: ApiKeyUsageWhereInput[]
    NOT?: ApiKeyUsageWhereInput | ApiKeyUsageWhereInput[]
    apiKeyId?: IntFilter<"ApiKeyUsage"> | number
    requestAt?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    statusCode?: IntFilter<"ApiKeyUsage"> | number
    durationMs?: IntFilter<"ApiKeyUsage"> | number
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    errorMessage?: StringNullableFilter<"ApiKeyUsage"> | string | null
    apiKey?: XOR<ApiKeyScalarRelationFilter, ApiKeyWhereInput>
  }, "id">

  export type ApiKeyUsageOrderByWithAggregationInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    requestAt?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
    endpoint?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: ApiKeyUsageCountOrderByAggregateInput
    _avg?: ApiKeyUsageAvgOrderByAggregateInput
    _max?: ApiKeyUsageMaxOrderByAggregateInput
    _min?: ApiKeyUsageMinOrderByAggregateInput
    _sum?: ApiKeyUsageSumOrderByAggregateInput
  }

  export type ApiKeyUsageScalarWhereWithAggregatesInput = {
    AND?: ApiKeyUsageScalarWhereWithAggregatesInput | ApiKeyUsageScalarWhereWithAggregatesInput[]
    OR?: ApiKeyUsageScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyUsageScalarWhereWithAggregatesInput | ApiKeyUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiKeyUsage"> | number
    apiKeyId?: IntWithAggregatesFilter<"ApiKeyUsage"> | number
    requestAt?: DateTimeWithAggregatesFilter<"ApiKeyUsage"> | Date | string
    statusCode?: IntWithAggregatesFilter<"ApiKeyUsage"> | number
    durationMs?: IntWithAggregatesFilter<"ApiKeyUsage"> | number
    endpoint?: StringWithAggregatesFilter<"ApiKeyUsage"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ApiKeyUsage"> | string | null
  }

  export type ApiConfigWhereInput = {
    AND?: ApiConfigWhereInput | ApiConfigWhereInput[]
    OR?: ApiConfigWhereInput[]
    NOT?: ApiConfigWhereInput | ApiConfigWhereInput[]
    id?: IntFilter<"ApiConfig"> | number
    name?: StringFilter<"ApiConfig"> | string
    value?: StringFilter<"ApiConfig"> | string
    description?: StringNullableFilter<"ApiConfig"> | string | null
    updatedAt?: DateTimeFilter<"ApiConfig"> | Date | string
    auditLogs?: AuditLogListRelationFilter
  }

  export type ApiConfigOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ApiConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ApiConfigWhereInput | ApiConfigWhereInput[]
    OR?: ApiConfigWhereInput[]
    NOT?: ApiConfigWhereInput | ApiConfigWhereInput[]
    value?: StringFilter<"ApiConfig"> | string
    description?: StringNullableFilter<"ApiConfig"> | string | null
    updatedAt?: DateTimeFilter<"ApiConfig"> | Date | string
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "name">

  export type ApiConfigOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ApiConfigCountOrderByAggregateInput
    _avg?: ApiConfigAvgOrderByAggregateInput
    _max?: ApiConfigMaxOrderByAggregateInput
    _min?: ApiConfigMinOrderByAggregateInput
    _sum?: ApiConfigSumOrderByAggregateInput
  }

  export type ApiConfigScalarWhereWithAggregatesInput = {
    AND?: ApiConfigScalarWhereWithAggregatesInput | ApiConfigScalarWhereWithAggregatesInput[]
    OR?: ApiConfigScalarWhereWithAggregatesInput[]
    NOT?: ApiConfigScalarWhereWithAggregatesInput | ApiConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiConfig"> | number
    name?: StringWithAggregatesFilter<"ApiConfig"> | string
    value?: StringWithAggregatesFilter<"ApiConfig"> | string
    description?: StringNullableWithAggregatesFilter<"ApiConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ApiConfig"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    apiKeyId?: IntNullableFilter<"AuditLog"> | number | null
    apiConfigId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null
    apiConfig?: XOR<ApiConfigNullableScalarRelationFilter, ApiConfigWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    apiConfigId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    apiKey?: ApiKeyOrderByWithRelationInput
    apiConfig?: ApiConfigOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntNullableFilter<"AuditLog"> | number | null
    apiKeyId?: IntNullableFilter<"AuditLog"> | number | null
    apiConfigId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null
    apiConfig?: XOR<ApiConfigNullableScalarRelationFilter, ApiConfigWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    apiConfigId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    apiKeyId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    apiConfigId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name: string
    password: string
    avatar?: string | null
    otpToken?: string | null
    otpExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    refreshToken?: string | null
    isApproved?: boolean
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    password: string
    avatar?: string | null
    otpToken?: string | null
    otpExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    refreshToken?: string | null
    isApproved?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name: string
    password: string
    avatar?: string | null
    otpToken?: string | null
    otpExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    refreshToken?: string | null
    isApproved?: boolean
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryCreateInput = {
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    products?: ProductCreateNestedManyWithoutCategoriesInput
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutCategoriesNestedInput
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryTranslationCreateInput = {
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    category: CategoryCreateNestedOneWithoutTranslationsInput
    products?: ProductTranslationCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    categoryId: number
    products?: ProductTranslationUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
    products?: ProductTranslationUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    products?: ProductTranslationUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    categoryId: number
  }

  export type CategoryTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationCreateInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
  }

  export type ProductTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type modelSpecificationCreateInput = {
    title_en: string
    products?: ProductCreateNestedManyWithoutModelSpecificationInput
    translations?: modelSpecificationTranslationCreateNestedManyWithoutModelSpecInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationUncheckedCreateInput = {
    id?: number
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutModelSpecificationInput
    translations?: modelSpecificationTranslationUncheckedCreateNestedManyWithoutModelSpecInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationUpdateInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutModelSpecificationNestedInput
    translations?: modelSpecificationTranslationUpdateManyWithoutModelSpecNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type modelSpecificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutModelSpecificationNestedInput
    translations?: modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type modelSpecificationCreateManyInput = {
    id?: number
    title_en: string
  }

  export type modelSpecificationUpdateManyMutationInput = {
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationTranslationCreateInput = {
    language: $Enums.LanguageCode
    title: string
    modelSpec: modelSpecificationCreateNestedOneWithoutTranslationsInput
  }

  export type modelSpecificationTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    modelspecId: number
  }

  export type modelSpecificationTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    modelSpec?: modelSpecificationUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type modelSpecificationTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    modelspecId?: IntFieldUpdateOperationsInput | number
  }

  export type modelSpecificationTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    modelspecId: number
  }

  export type modelSpecificationTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    modelspecId?: IntFieldUpdateOperationsInput | number
  }

  export type AdvantageCreateInput = {
    heading_en?: string
    title_en: string
    products?: ProductCreateNestedManyWithoutAdvantagesInput
    translations?: AdvantageTranslationCreateNestedManyWithoutAdvantageInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageUncheckedCreateInput = {
    id?: number
    heading_en?: string
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutAdvantagesInput
    translations?: AdvantageTranslationUncheckedCreateNestedManyWithoutAdvantageInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageUpdateInput = {
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutAdvantagesNestedInput
    translations?: AdvantageTranslationUpdateManyWithoutAdvantageNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutAdvantagesNestedInput
  }

  export type AdvantageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutAdvantagesNestedInput
    translations?: AdvantageTranslationUncheckedUpdateManyWithoutAdvantageNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type AdvantageCreateManyInput = {
    id?: number
    heading_en?: string
    title_en: string
  }

  export type AdvantageUpdateManyMutationInput = {
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageTranslationCreateInput = {
    language: $Enums.LanguageCode
    heading?: string
    title: string
    advantage: AdvantageCreateNestedOneWithoutTranslationsInput
  }

  export type AdvantageTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    heading?: string
    title: string
    advantageId: number
  }

  export type AdvantageTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    advantage?: AdvantageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type AdvantageTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    advantageId?: IntFieldUpdateOperationsInput | number
  }

  export type AdvantageTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    heading?: string
    title: string
    advantageId: number
  }

  export type AdvantageTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    advantageId?: IntFieldUpdateOperationsInput | number
  }

  export type SpecificationCreateInput = {
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    product?: ProductCreateNestedOneWithoutSpecificationsInput
    translations?: SpecificationTranslationCreateNestedManyWithoutSpecificationInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationUncheckedCreateInput = {
    id?: number
    categoryId?: number | null
    productId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    translations?: SpecificationTranslationUncheckedCreateNestedManyWithoutSpecificationInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationUpdateInput = {
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutSpecificationsNestedInput
    translations?: SpecificationTranslationUpdateManyWithoutSpecificationNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutSpecificationsNestedInput
  }

  export type SpecificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: SpecificationTranslationUncheckedUpdateManyWithoutSpecificationNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutSpecificationsNestedInput
  }

  export type SpecificationCreateManyInput = {
    id?: number
    categoryId?: number | null
    productId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
  }

  export type SpecificationUpdateManyMutationInput = {
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificationTranslationCreateInput = {
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
    specification: SpecificationCreateNestedOneWithoutTranslationsInput
  }

  export type SpecificationTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
    specificationId: number
  }

  export type SpecificationTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
    specification?: SpecificationUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type SpecificationTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
    specificationId?: IntFieldUpdateOperationsInput | number
  }

  export type SpecificationTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
    specificationId: number
  }

  export type SpecificationTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificationTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
    specificationId?: IntFieldUpdateOperationsInput | number
  }

  export type ApplicationDataCreateInput = {
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    product: ProductCreateNestedOneWithoutApplicationDataInput
    translations?: ApplicationDataTranslationCreateNestedManyWithoutApplicationDataInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataUncheckedCreateInput = {
    id?: number
    productId: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    translations?: ApplicationDataTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataUpdateInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutApplicationDataNestedInput
    translations?: ApplicationDataTranslationUpdateManyWithoutApplicationDataNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataCreateManyInput = {
    id?: number
    productId: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
  }

  export type ApplicationDataUpdateManyMutationInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataTranslationCreateInput = {
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
    applicationData: ApplicationDataCreateNestedOneWithoutTranslationsInput
  }

  export type ApplicationDataTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
    applicationDataId: number
  }

  export type ApplicationDataTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
    applicationData?: ApplicationDataUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ApplicationDataTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDataId?: IntFieldUpdateOperationsInput | number
  }

  export type ApplicationDataTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
    applicationDataId: number
  }

  export type ApplicationDataTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDataId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnicalSpecificationCreateInput = {
    feature_en: string
    spec_en: string
    product: ProductCreateNestedOneWithoutTechnicalSpecificationsInput
    translations?: TechnicalSpecificationTranslationCreateNestedManyWithoutTechnicalSpecificationInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationUncheckedCreateInput = {
    id?: number
    productId: number
    feature_en: string
    spec_en: string
    translations?: TechnicalSpecificationTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationUpdateInput = {
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTechnicalSpecificationsNestedInput
    translations?: TechnicalSpecificationTranslationUpdateManyWithoutTechnicalSpecificationNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    translations?: TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type TechnicalSpecificationCreateManyInput = {
    id?: number
    productId: number
    feature_en: string
    spec_en: string
  }

  export type TechnicalSpecificationUpdateManyMutationInput = {
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSpecificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSpecificationTranslationCreateInput = {
    language: $Enums.LanguageCode
    feature: string
    spec: string
    technicalSpecification: TechnicalSpecificationCreateNestedOneWithoutTranslationsInput
  }

  export type TechnicalSpecificationTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    feature: string
    spec: string
    technicalSpecificationId: number
  }

  export type TechnicalSpecificationTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    technicalSpecification?: TechnicalSpecificationUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TechnicalSpecificationTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    technicalSpecificationId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnicalSpecificationTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    feature: string
    spec: string
    technicalSpecificationId: number
  }

  export type TechnicalSpecificationTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSpecificationTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    technicalSpecificationId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedProductCreateInput = {
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    product: ProductCreateNestedOneWithoutRelatedProductsInput
    translations?: RelatedProductTranslationCreateNestedManyWithoutRelatedProductInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductUncheckedCreateInput = {
    id?: number
    productId: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedCreateNestedManyWithoutRelatedProductInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductUpdateInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    product?: ProductUpdateOneRequiredWithoutRelatedProductsNestedInput
    translations?: RelatedProductTranslationUpdateManyWithoutRelatedProductNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutRelatedProductsNestedInput
  }

  export type RelatedProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutRelatedProductsNestedInput
  }

  export type RelatedProductCreateManyInput = {
    id?: number
    productId: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
  }

  export type RelatedProductUpdateManyMutationInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type RelatedProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type RelatedProductTranslationCreateInput = {
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
    relatedProduct: RelatedProductCreateNestedOneWithoutTranslationsInput
  }

  export type RelatedProductTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
    relatedProductId: number
  }

  export type RelatedProductTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    relatedProduct?: RelatedProductUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type RelatedProductTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    relatedProductId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedProductTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
    relatedProductId: number
  }

  export type RelatedProductTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type RelatedProductTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    relatedProductId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepCreateInput = {
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    product: ProductCreateNestedOneWithoutProcessStepsInput
    translations?: ProcessStepTranslationCreateNestedManyWithoutProcessStepInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepUncheckedCreateInput = {
    id?: number
    productId: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    translations?: ProcessStepTranslationUncheckedCreateNestedManyWithoutProcessStepInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepUpdateInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutProcessStepsNestedInput
    translations?: ProcessStepTranslationUpdateManyWithoutProcessStepNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutProcessStepsNestedInput
  }

  export type ProcessStepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutProcessStepsNestedInput
  }

  export type ProcessStepCreateManyInput = {
    id?: number
    productId: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
  }

  export type ProcessStepUpdateManyMutationInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessStepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcessStepTranslationCreateInput = {
    language: $Enums.LanguageCode
    title: string
    description: string
    processStep: ProcessStepCreateNestedOneWithoutTranslationsInput
  }

  export type ProcessStepTranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description: string
    processStepId: number
  }

  export type ProcessStepTranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    processStep?: ProcessStepUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ProcessStepTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    processStepId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepTranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description: string
    processStepId: number
  }

  export type ProcessStepTranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessStepTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    processStepId?: IntFieldUpdateOperationsInput | number
  }

  export type CTACreateInput = {
    text_en: string
    description_en?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CTATranslationCreateNestedManyWithoutCtaInput
  }

  export type CTAUncheckedCreateInput = {
    id?: number
    text_en: string
    description_en?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: CTATranslationUncheckedCreateNestedManyWithoutCtaInput
  }

  export type CTAUpdateInput = {
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CTATranslationUpdateManyWithoutCtaNestedInput
  }

  export type CTAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: CTATranslationUncheckedUpdateManyWithoutCtaNestedInput
  }

  export type CTACreateManyInput = {
    id?: number
    text_en: string
    description_en?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CTAUpdateManyMutationInput = {
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CTAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CTATranslationCreateInput = {
    language: $Enums.LanguageCode
    text: string
    description?: string | null
    cta: CTACreateNestedOneWithoutTranslationsInput
  }

  export type CTATranslationUncheckedCreateInput = {
    id?: number
    language: $Enums.LanguageCode
    text: string
    description?: string | null
    ctaId: number
  }

  export type CTATranslationUpdateInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cta?: CTAUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CTATranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaId?: IntFieldUpdateOperationsInput | number
  }

  export type CTATranslationCreateManyInput = {
    id?: number
    language: $Enums.LanguageCode
    text: string
    description?: string | null
    ctaId: number
  }

  export type CTATranslationUpdateManyMutationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CTATranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaId?: IntFieldUpdateOperationsInput | number
  }

  export type TranslationTaskCreateInput = {
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiUrl?: string | null
    apiKey?: ApiKeyCreateNestedOneWithoutTranslationTasksInput
  }

  export type TranslationTaskUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeyId?: number | null
    apiUrl?: string | null
  }

  export type TranslationTaskUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: ApiKeyUpdateOneWithoutTranslationTasksNestedInput
  }

  export type TranslationTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranslationTaskCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeyId?: number | null
    apiUrl?: string | null
  }

  export type TranslationTaskUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranslationTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactSubmissionCreateInput = {
    title: string
    description?: string | null
    fullName: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    fullName: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    fullName: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageCreateNestedManyWithoutApiKeyInput
    auditLogs?: AuditLogCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: number
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUpdateInput = {
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUpdateManyWithoutApiKeyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyCreateManyInput = {
    id?: number
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
  }

  export type ApiKeyUpdateManyMutationInput = {
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageCreateInput = {
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
    apiKey: ApiKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type ApiKeyUsageUncheckedCreateInput = {
    id?: number
    apiKeyId: number
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
  }

  export type ApiKeyUsageUpdateInput = {
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: ApiKeyUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type ApiKeyUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    apiKeyId?: IntFieldUpdateOperationsInput | number
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageCreateManyInput = {
    id?: number
    apiKeyId: number
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
  }

  export type ApiKeyUsageUpdateManyMutationInput = {
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    apiKeyId?: IntFieldUpdateOperationsInput | number
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiConfigCreateInput = {
    name: string
    value: string
    description?: string | null
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutApiConfigInput
  }

  export type ApiConfigUncheckedCreateInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApiConfigInput
  }

  export type ApiConfigUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutApiConfigNestedInput
  }

  export type ApiConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApiConfigNestedInput
  }

  export type ApiConfigCreateManyInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type ApiConfigUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    apiKey?: ApiKeyCreateNestedOneWithoutAuditLogsInput
    apiConfig?: ApiConfigCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    apiKeyId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    apiKey?: ApiKeyUpdateOneWithoutAuditLogsNestedInput
    apiConfig?: ApiConfigUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId?: number | null
    apiKeyId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    otpToken?: SortOrder
    otpExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isApproved?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    otpToken?: SortOrder
    otpExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isApproved?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    otpToken?: SortOrder
    otpExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isApproved?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryTranslationListRelationFilter = {
    every?: CategoryTranslationWhereInput
    some?: CategoryTranslationWhereInput
    none?: CategoryTranslationWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    category_icon?: SortOrder
    category_image?: SortOrder
    category_Alt_en?: SortOrder
    categoryLink_en?: SortOrder
    specification_image?: SortOrder
    specification_image_alt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    category_icon?: SortOrder
    category_image?: SortOrder
    category_Alt_en?: SortOrder
    categoryLink_en?: SortOrder
    specification_image?: SortOrder
    specification_image_alt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    category_icon?: SortOrder
    category_image?: SortOrder
    category_Alt_en?: SortOrder
    categoryLink_en?: SortOrder
    specification_image?: SortOrder
    specification_image_alt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumLanguageCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.LanguageCode | EnumLanguageCodeFieldRefInput<$PrismaModel>
    in?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageCodeFilter<$PrismaModel> | $Enums.LanguageCode
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ProductTranslationListRelationFilter = {
    every?: ProductTranslationWhereInput
    some?: ProductTranslationWhereInput
    none?: ProductTranslationWhereInput
  }

  export type ProductTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryTranslationCategoryIdLanguageCompoundUniqueInput = {
    categoryId: number
    language: $Enums.LanguageCode
  }

  export type CategoryTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    iconAlt?: SortOrder
    categoryLink?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type CategoryTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type CategoryTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    iconAlt?: SortOrder
    categoryLink?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type CategoryTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    iconAlt?: SortOrder
    categoryLink?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type CategoryTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type EnumLanguageCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LanguageCode | EnumLanguageCodeFieldRefInput<$PrismaModel>
    in?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageCodeWithAggregatesFilter<$PrismaModel> | $Enums.LanguageCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageCodeFilter<$PrismaModel>
    _max?: NestedEnumLanguageCodeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ModelSpecificationListRelationFilter = {
    every?: modelSpecificationWhereInput
    some?: modelSpecificationWhereInput
    none?: modelSpecificationWhereInput
  }

  export type AdvantageListRelationFilter = {
    every?: AdvantageWhereInput
    some?: AdvantageWhereInput
    none?: AdvantageWhereInput
  }

  export type SpecificationListRelationFilter = {
    every?: SpecificationWhereInput
    some?: SpecificationWhereInput
    none?: SpecificationWhereInput
  }

  export type ApplicationDataListRelationFilter = {
    every?: ApplicationDataWhereInput
    some?: ApplicationDataWhereInput
    none?: ApplicationDataWhereInput
  }

  export type TechnicalSpecificationListRelationFilter = {
    every?: TechnicalSpecificationWhereInput
    some?: TechnicalSpecificationWhereInput
    none?: TechnicalSpecificationWhereInput
  }

  export type RelatedProductListRelationFilter = {
    every?: RelatedProductWhereInput
    some?: RelatedProductWhereInput
    none?: RelatedProductWhereInput
  }

  export type ProcessStepListRelationFilter = {
    every?: ProcessStepWhereInput
    some?: ProcessStepWhereInput
    none?: ProcessStepWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type modelSpecificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvantageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicalSpecificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelatedProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    model_name_en?: SortOrder
    product_name?: SortOrder
    productImage?: SortOrder
    productImage_Alt?: SortOrder
    status_en?: SortOrder
    stars?: SortOrder
    reviews?: SortOrder
    productDescription_en?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    reviews?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    model_name_en?: SortOrder
    product_name?: SortOrder
    productImage?: SortOrder
    productImage_Alt?: SortOrder
    status_en?: SortOrder
    stars?: SortOrder
    reviews?: SortOrder
    productDescription_en?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    model_name_en?: SortOrder
    product_name?: SortOrder
    productImage?: SortOrder
    productImage_Alt?: SortOrder
    status_en?: SortOrder
    stars?: SortOrder
    reviews?: SortOrder
    productDescription_en?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    stars?: SortOrder
    reviews?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductTranslationProductIdLanguageCompoundUniqueInput = {
    productId: number
    language: $Enums.LanguageCode
  }

  export type ProductTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    imageAlt?: SortOrder
    status?: SortOrder
    productDescription?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    imageAlt?: SortOrder
    status?: SortOrder
    productDescription?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    name?: SortOrder
    imageAlt?: SortOrder
    status?: SortOrder
    productDescription?: SortOrder
    model_description?: SortOrder
    introduction?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ModelSpecificationTranslationListRelationFilter = {
    every?: modelSpecificationTranslationWhereInput
    some?: modelSpecificationTranslationWhereInput
    none?: modelSpecificationTranslationWhereInput
  }

  export type modelSpecificationTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type modelSpecificationCountOrderByAggregateInput = {
    id?: SortOrder
    title_en?: SortOrder
  }

  export type modelSpecificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type modelSpecificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title_en?: SortOrder
  }

  export type modelSpecificationMinOrderByAggregateInput = {
    id?: SortOrder
    title_en?: SortOrder
  }

  export type modelSpecificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModelSpecificationScalarRelationFilter = {
    is?: modelSpecificationWhereInput
    isNot?: modelSpecificationWhereInput
  }

  export type modelSpecificationTranslationModelspecIdLanguageCompoundUniqueInput = {
    modelspecId: number
    language: $Enums.LanguageCode
  }

  export type modelSpecificationTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    modelspecId?: SortOrder
  }

  export type modelSpecificationTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    modelspecId?: SortOrder
  }

  export type modelSpecificationTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    modelspecId?: SortOrder
  }

  export type modelSpecificationTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    modelspecId?: SortOrder
  }

  export type modelSpecificationTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    modelspecId?: SortOrder
  }

  export type AdvantageTranslationListRelationFilter = {
    every?: AdvantageTranslationWhereInput
    some?: AdvantageTranslationWhereInput
    none?: AdvantageTranslationWhereInput
  }

  export type AdvantageTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvantageCountOrderByAggregateInput = {
    id?: SortOrder
    heading_en?: SortOrder
    title_en?: SortOrder
  }

  export type AdvantageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdvantageMaxOrderByAggregateInput = {
    id?: SortOrder
    heading_en?: SortOrder
    title_en?: SortOrder
  }

  export type AdvantageMinOrderByAggregateInput = {
    id?: SortOrder
    heading_en?: SortOrder
    title_en?: SortOrder
  }

  export type AdvantageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdvantageScalarRelationFilter = {
    is?: AdvantageWhereInput
    isNot?: AdvantageWhereInput
  }

  export type AdvantageTranslationAdvantageIdLanguageCompoundUniqueInput = {
    advantageId: number
    language: $Enums.LanguageCode
  }

  export type AdvantageTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    advantageId?: SortOrder
  }

  export type AdvantageTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    advantageId?: SortOrder
  }

  export type AdvantageTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    advantageId?: SortOrder
  }

  export type AdvantageTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    heading?: SortOrder
    title?: SortOrder
    advantageId?: SortOrder
  }

  export type AdvantageTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    advantageId?: SortOrder
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type SpecificationTranslationListRelationFilter = {
    every?: SpecificationTranslationWhereInput
    some?: SpecificationTranslationWhereInput
    none?: SpecificationTranslationWhereInput
  }

  export type SpecificationTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificationCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    productId?: SortOrder
    speed_en?: SortOrder
    paperSpecification_en?: SortOrder
    sizeRange_en?: SortOrder
  }

  export type SpecificationAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    productId?: SortOrder
  }

  export type SpecificationMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    productId?: SortOrder
    speed_en?: SortOrder
    paperSpecification_en?: SortOrder
    sizeRange_en?: SortOrder
  }

  export type SpecificationMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    productId?: SortOrder
    speed_en?: SortOrder
    paperSpecification_en?: SortOrder
    sizeRange_en?: SortOrder
  }

  export type SpecificationSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    productId?: SortOrder
  }

  export type SpecificationScalarRelationFilter = {
    is?: SpecificationWhereInput
    isNot?: SpecificationWhereInput
  }

  export type SpecificationTranslationSpecificationIdLanguageCompoundUniqueInput = {
    specificationId: number
    language: $Enums.LanguageCode
  }

  export type SpecificationTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    speed?: SortOrder
    paperSpecification?: SortOrder
    sizeRange?: SortOrder
    specificationId?: SortOrder
  }

  export type SpecificationTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    specificationId?: SortOrder
  }

  export type SpecificationTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    speed?: SortOrder
    paperSpecification?: SortOrder
    sizeRange?: SortOrder
    specificationId?: SortOrder
  }

  export type SpecificationTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    speed?: SortOrder
    paperSpecification?: SortOrder
    sizeRange?: SortOrder
    specificationId?: SortOrder
  }

  export type SpecificationTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    specificationId?: SortOrder
  }

  export type ApplicationDataTranslationListRelationFilter = {
    every?: ApplicationDataTranslationWhereInput
    some?: ApplicationDataTranslationWhereInput
    none?: ApplicationDataTranslationWhereInput
  }

  export type ApplicationDataTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationDataCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    src?: SortOrder
    src_alt_en?: SortOrder
  }

  export type ApplicationDataAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ApplicationDataMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    src?: SortOrder
    src_alt_en?: SortOrder
  }

  export type ApplicationDataMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    src?: SortOrder
    src_alt_en?: SortOrder
  }

  export type ApplicationDataSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ApplicationDataScalarRelationFilter = {
    is?: ApplicationDataWhereInput
    isNot?: ApplicationDataWhereInput
  }

  export type ApplicationDataTranslationApplicationDataIdLanguageCompoundUniqueInput = {
    applicationDataId: number
    language: $Enums.LanguageCode
  }

  export type ApplicationDataTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    src_alt?: SortOrder
    applicationDataId?: SortOrder
  }

  export type ApplicationDataTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationDataId?: SortOrder
  }

  export type ApplicationDataTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    src_alt?: SortOrder
    applicationDataId?: SortOrder
  }

  export type ApplicationDataTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    src_alt?: SortOrder
    applicationDataId?: SortOrder
  }

  export type ApplicationDataTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    applicationDataId?: SortOrder
  }

  export type TechnicalSpecificationTranslationListRelationFilter = {
    every?: TechnicalSpecificationTranslationWhereInput
    some?: TechnicalSpecificationTranslationWhereInput
    none?: TechnicalSpecificationTranslationWhereInput
  }

  export type TechnicalSpecificationTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicalSpecificationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    feature_en?: SortOrder
    spec_en?: SortOrder
  }

  export type TechnicalSpecificationAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type TechnicalSpecificationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    feature_en?: SortOrder
    spec_en?: SortOrder
  }

  export type TechnicalSpecificationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    feature_en?: SortOrder
    spec_en?: SortOrder
  }

  export type TechnicalSpecificationSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type TechnicalSpecificationScalarRelationFilter = {
    is?: TechnicalSpecificationWhereInput
    isNot?: TechnicalSpecificationWhereInput
  }

  export type TechnicalSpecificationTranslationTechnicalSpecificationIdLanguageCompoundUniqueInput = {
    technicalSpecificationId: number
    language: $Enums.LanguageCode
  }

  export type TechnicalSpecificationTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    feature?: SortOrder
    spec?: SortOrder
    technicalSpecificationId?: SortOrder
  }

  export type TechnicalSpecificationTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    technicalSpecificationId?: SortOrder
  }

  export type TechnicalSpecificationTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    feature?: SortOrder
    spec?: SortOrder
    technicalSpecificationId?: SortOrder
  }

  export type TechnicalSpecificationTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    feature?: SortOrder
    spec?: SortOrder
    technicalSpecificationId?: SortOrder
  }

  export type TechnicalSpecificationTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    technicalSpecificationId?: SortOrder
  }

  export type EnumMachineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MachineType | EnumMachineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMachineTypeFilter<$PrismaModel> | $Enums.MachineType
  }

  export type RelatedProductTranslationListRelationFilter = {
    every?: RelatedProductTranslationWhereInput
    some?: RelatedProductTranslationWhereInput
    none?: RelatedProductTranslationWhereInput
  }

  export type RelatedProductTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelatedProductCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    image?: SortOrder
    imageAlt_en?: SortOrder
    category_icon?: SortOrder
    category_Alt_en?: SortOrder
    machineType?: SortOrder
  }

  export type RelatedProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type RelatedProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    image?: SortOrder
    imageAlt_en?: SortOrder
    category_icon?: SortOrder
    category_Alt_en?: SortOrder
    machineType?: SortOrder
  }

  export type RelatedProductMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    image?: SortOrder
    imageAlt_en?: SortOrder
    category_icon?: SortOrder
    category_Alt_en?: SortOrder
    machineType?: SortOrder
  }

  export type RelatedProductSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type EnumMachineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MachineType | EnumMachineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMachineTypeWithAggregatesFilter<$PrismaModel> | $Enums.MachineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMachineTypeFilter<$PrismaModel>
    _max?: NestedEnumMachineTypeFilter<$PrismaModel>
  }

  export type RelatedProductScalarRelationFilter = {
    is?: RelatedProductWhereInput
    isNot?: RelatedProductWhereInput
  }

  export type RelatedProductTranslationRelatedProductIdLanguageCompoundUniqueInput = {
    relatedProductId: number
    language: $Enums.LanguageCode
  }

  export type RelatedProductTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageAlt?: SortOrder
    category_Alt?: SortOrder
    machineType?: SortOrder
    relatedProductId?: SortOrder
  }

  export type RelatedProductTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    relatedProductId?: SortOrder
  }

  export type RelatedProductTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageAlt?: SortOrder
    category_Alt?: SortOrder
    machineType?: SortOrder
    relatedProductId?: SortOrder
  }

  export type RelatedProductTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageAlt?: SortOrder
    category_Alt?: SortOrder
    machineType?: SortOrder
    relatedProductId?: SortOrder
  }

  export type RelatedProductTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    relatedProductId?: SortOrder
  }

  export type ProcessStepTranslationListRelationFilter = {
    every?: ProcessStepTranslationWhereInput
    some?: ProcessStepTranslationWhereInput
    none?: ProcessStepTranslationWhereInput
  }

  export type ProcessStepTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessStepCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    process_image?: SortOrder
    process_image_alt?: SortOrder
  }

  export type ProcessStepAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProcessStepMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    process_image?: SortOrder
    process_image_alt?: SortOrder
  }

  export type ProcessStepMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    title_en?: SortOrder
    description_en?: SortOrder
    process_image?: SortOrder
    process_image_alt?: SortOrder
  }

  export type ProcessStepSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProcessStepScalarRelationFilter = {
    is?: ProcessStepWhereInput
    isNot?: ProcessStepWhereInput
  }

  export type ProcessStepTranslationProcessStepIdLanguageCompoundUniqueInput = {
    processStepId: number
    language: $Enums.LanguageCode
  }

  export type ProcessStepTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    processStepId?: SortOrder
  }

  export type ProcessStepTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    processStepId?: SortOrder
  }

  export type ProcessStepTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    processStepId?: SortOrder
  }

  export type ProcessStepTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    processStepId?: SortOrder
  }

  export type ProcessStepTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    processStepId?: SortOrder
  }

  export type CTATranslationListRelationFilter = {
    every?: CTATranslationWhereInput
    some?: CTATranslationWhereInput
    none?: CTATranslationWhereInput
  }

  export type CTATranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CTACountOrderByAggregateInput = {
    id?: SortOrder
    text_en?: SortOrder
    description_en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CTAAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CTAMaxOrderByAggregateInput = {
    id?: SortOrder
    text_en?: SortOrder
    description_en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CTAMinOrderByAggregateInput = {
    id?: SortOrder
    text_en?: SortOrder
    description_en?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CTASumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CTAScalarRelationFilter = {
    is?: CTAWhereInput
    isNot?: CTAWhereInput
  }

  export type CTATranslationCtaIdLanguageCompoundUniqueInput = {
    ctaId: number
    language: $Enums.LanguageCode
  }

  export type CTATranslationCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    text?: SortOrder
    description?: SortOrder
    ctaId?: SortOrder
  }

  export type CTATranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    ctaId?: SortOrder
  }

  export type CTATranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    text?: SortOrder
    description?: SortOrder
    ctaId?: SortOrder
  }

  export type CTATranslationMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    text?: SortOrder
    description?: SortOrder
    ctaId?: SortOrder
  }

  export type CTATranslationSumOrderByAggregateInput = {
    id?: SortOrder
    ctaId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApiKeyNullableScalarRelationFilter = {
    is?: ApiKeyWhereInput | null
    isNot?: ApiKeyWhereInput | null
  }

  export type TranslationTaskEntityTypeEntityIdLanguageCompoundUniqueInput = {
    entityType: string
    entityId: number
    language: $Enums.LanguageCode
  }

  export type TranslationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    texts?: SortOrder
    language?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    processingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeyId?: SortOrder
    apiUrl?: SortOrder
  }

  export type TranslationTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    attempts?: SortOrder
    apiKeyId?: SortOrder
  }

  export type TranslationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    language?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    processingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeyId?: SortOrder
    apiUrl?: SortOrder
  }

  export type TranslationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    language?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    processingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeyId?: SortOrder
    apiUrl?: SortOrder
  }

  export type TranslationTaskSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    attempts?: SortOrder
    apiKeyId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ContactSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ApiKeyUsageListRelationFilter = {
    every?: ApiKeyUsageWhereInput
    some?: ApiKeyUsageWhereInput
    none?: ApiKeyUsageWhereInput
  }

  export type TranslationTaskListRelationFilter = {
    every?: TranslationTaskWhereInput
    some?: TranslationTaskWhereInput
    none?: TranslationTaskWhereInput
  }

  export type ApiKeyUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranslationTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    keyValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
    rateLimitPerMin?: SortOrder
    rateLimitCount?: SortOrder
    rateLimitReset?: SortOrder
    notes?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    id?: SortOrder
    rateLimitPerMin?: SortOrder
    rateLimitCount?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    keyValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
    rateLimitPerMin?: SortOrder
    rateLimitCount?: SortOrder
    rateLimitReset?: SortOrder
    notes?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    keyValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
    rateLimitPerMin?: SortOrder
    rateLimitCount?: SortOrder
    rateLimitReset?: SortOrder
    notes?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    id?: SortOrder
    rateLimitPerMin?: SortOrder
    rateLimitCount?: SortOrder
  }

  export type ApiKeyScalarRelationFilter = {
    is?: ApiKeyWhereInput
    isNot?: ApiKeyWhereInput
  }

  export type ApiKeyUsageCountOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    requestAt?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
    endpoint?: SortOrder
    errorMessage?: SortOrder
  }

  export type ApiKeyUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
  }

  export type ApiKeyUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    requestAt?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
    endpoint?: SortOrder
    errorMessage?: SortOrder
  }

  export type ApiKeyUsageMinOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    requestAt?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
    endpoint?: SortOrder
    errorMessage?: SortOrder
  }

  export type ApiKeyUsageSumOrderByAggregateInput = {
    id?: SortOrder
    apiKeyId?: SortOrder
    statusCode?: SortOrder
    durationMs?: SortOrder
  }

  export type ApiConfigCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ApiConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApiConfigNullableScalarRelationFilter = {
    is?: ApiConfigWhereInput | null
    isNot?: ApiConfigWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    apiConfigId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    apiConfigId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    apiConfigId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    apiConfigId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    apiConfigId?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryTranslationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryTranslationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput> | CategoryTranslationCreateWithoutCategoryInput[] | CategoryTranslationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutCategoryInput | CategoryTranslationCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryTranslationCreateManyCategoryInputEnvelope
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput | CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutCategoryInput | CategoryTranslationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductTranslationCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput> | ProductTranslationCreateWithoutCategoriesInput[] | ProductTranslationUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutCategoriesInput | ProductTranslationCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput> | ProductTranslationCreateWithoutCategoriesInput[] | ProductTranslationUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutCategoriesInput | ProductTranslationCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type EnumLanguageCodeFieldUpdateOperationsInput = {
    set?: $Enums.LanguageCode
  }

  export type CategoryUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTranslationsInput
    upsert?: CategoryUpsertWithoutTranslationsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTranslationsInput, CategoryUpdateWithoutTranslationsInput>, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductTranslationUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput> | ProductTranslationCreateWithoutCategoriesInput[] | ProductTranslationUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutCategoriesInput | ProductTranslationCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutCategoriesInput | ProductTranslationUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutCategoriesInput | ProductTranslationUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutCategoriesInput | ProductTranslationUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput> | ProductTranslationCreateWithoutCategoriesInput[] | ProductTranslationUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutCategoriesInput | ProductTranslationCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutCategoriesInput | ProductTranslationUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutCategoriesInput | ProductTranslationUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutCategoriesInput | ProductTranslationUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type modelSpecificationCreateNestedManyWithoutProductsInput = {
    create?: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput> | modelSpecificationCreateWithoutProductsInput[] | modelSpecificationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductsInput | modelSpecificationCreateOrConnectWithoutProductsInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
  }

  export type AdvantageCreateNestedManyWithoutProductsInput = {
    create?: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput> | AdvantageCreateWithoutProductsInput[] | AdvantageUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductsInput | AdvantageCreateOrConnectWithoutProductsInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
  }

  export type SpecificationCreateNestedManyWithoutProductInput = {
    create?: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput> | SpecificationCreateWithoutProductInput[] | SpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductInput | SpecificationCreateOrConnectWithoutProductInput[]
    createMany?: SpecificationCreateManyProductInputEnvelope
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
  }

  export type ApplicationDataCreateNestedManyWithoutProductInput = {
    create?: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput> | ApplicationDataCreateWithoutProductInput[] | ApplicationDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductInput | ApplicationDataCreateOrConnectWithoutProductInput[]
    createMany?: ApplicationDataCreateManyProductInputEnvelope
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
  }

  export type TechnicalSpecificationCreateNestedManyWithoutProductInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput> | TechnicalSpecificationCreateWithoutProductInput[] | TechnicalSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductInput | TechnicalSpecificationCreateOrConnectWithoutProductInput[]
    createMany?: TechnicalSpecificationCreateManyProductInputEnvelope
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
  }

  export type RelatedProductCreateNestedManyWithoutProductInput = {
    create?: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput> | RelatedProductCreateWithoutProductInput[] | RelatedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductInput | RelatedProductCreateOrConnectWithoutProductInput[]
    createMany?: RelatedProductCreateManyProductInputEnvelope
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedManyWithoutProductInput = {
    create?: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput> | ProcessStepCreateWithoutProductInput[] | ProcessStepUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductInput | ProcessStepCreateOrConnectWithoutProductInput[]
    createMany?: ProcessStepCreateManyProductInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type modelSpecificationUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput> | modelSpecificationCreateWithoutProductsInput[] | modelSpecificationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductsInput | modelSpecificationCreateOrConnectWithoutProductsInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
  }

  export type AdvantageUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput> | AdvantageCreateWithoutProductsInput[] | AdvantageUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductsInput | AdvantageCreateOrConnectWithoutProductsInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
  }

  export type SpecificationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput> | SpecificationCreateWithoutProductInput[] | SpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductInput | SpecificationCreateOrConnectWithoutProductInput[]
    createMany?: SpecificationCreateManyProductInputEnvelope
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
  }

  export type ApplicationDataUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput> | ApplicationDataCreateWithoutProductInput[] | ApplicationDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductInput | ApplicationDataCreateOrConnectWithoutProductInput[]
    createMany?: ApplicationDataCreateManyProductInputEnvelope
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
  }

  export type TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput> | TechnicalSpecificationCreateWithoutProductInput[] | TechnicalSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductInput | TechnicalSpecificationCreateOrConnectWithoutProductInput[]
    createMany?: TechnicalSpecificationCreateManyProductInputEnvelope
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
  }

  export type RelatedProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput> | RelatedProductCreateWithoutProductInput[] | RelatedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductInput | RelatedProductCreateOrConnectWithoutProductInput[]
    createMany?: RelatedProductCreateManyProductInputEnvelope
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput> | ProcessStepCreateWithoutProductInput[] | ProcessStepUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductInput | ProcessStepCreateOrConnectWithoutProductInput[]
    createMany?: ProcessStepCreateManyProductInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type modelSpecificationUpdateManyWithoutProductsNestedInput = {
    create?: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput> | modelSpecificationCreateWithoutProductsInput[] | modelSpecificationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductsInput | modelSpecificationCreateOrConnectWithoutProductsInput[]
    upsert?: modelSpecificationUpsertWithWhereUniqueWithoutProductsInput | modelSpecificationUpsertWithWhereUniqueWithoutProductsInput[]
    set?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    disconnect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    delete?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    update?: modelSpecificationUpdateWithWhereUniqueWithoutProductsInput | modelSpecificationUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: modelSpecificationUpdateManyWithWhereWithoutProductsInput | modelSpecificationUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
  }

  export type AdvantageUpdateManyWithoutProductsNestedInput = {
    create?: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput> | AdvantageCreateWithoutProductsInput[] | AdvantageUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductsInput | AdvantageCreateOrConnectWithoutProductsInput[]
    upsert?: AdvantageUpsertWithWhereUniqueWithoutProductsInput | AdvantageUpsertWithWhereUniqueWithoutProductsInput[]
    set?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    disconnect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    delete?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    update?: AdvantageUpdateWithWhereUniqueWithoutProductsInput | AdvantageUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: AdvantageUpdateManyWithWhereWithoutProductsInput | AdvantageUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
  }

  export type SpecificationUpdateManyWithoutProductNestedInput = {
    create?: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput> | SpecificationCreateWithoutProductInput[] | SpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductInput | SpecificationCreateOrConnectWithoutProductInput[]
    upsert?: SpecificationUpsertWithWhereUniqueWithoutProductInput | SpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SpecificationCreateManyProductInputEnvelope
    set?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    disconnect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    delete?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    update?: SpecificationUpdateWithWhereUniqueWithoutProductInput | SpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SpecificationUpdateManyWithWhereWithoutProductInput | SpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
  }

  export type ApplicationDataUpdateManyWithoutProductNestedInput = {
    create?: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput> | ApplicationDataCreateWithoutProductInput[] | ApplicationDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductInput | ApplicationDataCreateOrConnectWithoutProductInput[]
    upsert?: ApplicationDataUpsertWithWhereUniqueWithoutProductInput | ApplicationDataUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ApplicationDataCreateManyProductInputEnvelope
    set?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    disconnect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    delete?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    update?: ApplicationDataUpdateWithWhereUniqueWithoutProductInput | ApplicationDataUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ApplicationDataUpdateManyWithWhereWithoutProductInput | ApplicationDataUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
  }

  export type TechnicalSpecificationUpdateManyWithoutProductNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput> | TechnicalSpecificationCreateWithoutProductInput[] | TechnicalSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductInput | TechnicalSpecificationCreateOrConnectWithoutProductInput[]
    upsert?: TechnicalSpecificationUpsertWithWhereUniqueWithoutProductInput | TechnicalSpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TechnicalSpecificationCreateManyProductInputEnvelope
    set?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    delete?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    update?: TechnicalSpecificationUpdateWithWhereUniqueWithoutProductInput | TechnicalSpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TechnicalSpecificationUpdateManyWithWhereWithoutProductInput | TechnicalSpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
  }

  export type RelatedProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput> | RelatedProductCreateWithoutProductInput[] | RelatedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductInput | RelatedProductCreateOrConnectWithoutProductInput[]
    upsert?: RelatedProductUpsertWithWhereUniqueWithoutProductInput | RelatedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RelatedProductCreateManyProductInputEnvelope
    set?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    disconnect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    delete?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    update?: RelatedProductUpdateWithWhereUniqueWithoutProductInput | RelatedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RelatedProductUpdateManyWithWhereWithoutProductInput | RelatedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
  }

  export type ProcessStepUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput> | ProcessStepCreateWithoutProductInput[] | ProcessStepUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductInput | ProcessStepCreateOrConnectWithoutProductInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProductInput | ProcessStepUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProcessStepCreateManyProductInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProductInput | ProcessStepUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProductInput | ProcessStepUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProductInput | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProductInput | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProductInput | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput> | modelSpecificationCreateWithoutProductsInput[] | modelSpecificationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductsInput | modelSpecificationCreateOrConnectWithoutProductsInput[]
    upsert?: modelSpecificationUpsertWithWhereUniqueWithoutProductsInput | modelSpecificationUpsertWithWhereUniqueWithoutProductsInput[]
    set?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    disconnect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    delete?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    update?: modelSpecificationUpdateWithWhereUniqueWithoutProductsInput | modelSpecificationUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: modelSpecificationUpdateManyWithWhereWithoutProductsInput | modelSpecificationUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
  }

  export type AdvantageUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput> | AdvantageCreateWithoutProductsInput[] | AdvantageUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductsInput | AdvantageCreateOrConnectWithoutProductsInput[]
    upsert?: AdvantageUpsertWithWhereUniqueWithoutProductsInput | AdvantageUpsertWithWhereUniqueWithoutProductsInput[]
    set?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    disconnect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    delete?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    update?: AdvantageUpdateWithWhereUniqueWithoutProductsInput | AdvantageUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: AdvantageUpdateManyWithWhereWithoutProductsInput | AdvantageUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
  }

  export type SpecificationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput> | SpecificationCreateWithoutProductInput[] | SpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductInput | SpecificationCreateOrConnectWithoutProductInput[]
    upsert?: SpecificationUpsertWithWhereUniqueWithoutProductInput | SpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SpecificationCreateManyProductInputEnvelope
    set?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    disconnect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    delete?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    update?: SpecificationUpdateWithWhereUniqueWithoutProductInput | SpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SpecificationUpdateManyWithWhereWithoutProductInput | SpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
  }

  export type ApplicationDataUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput> | ApplicationDataCreateWithoutProductInput[] | ApplicationDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductInput | ApplicationDataCreateOrConnectWithoutProductInput[]
    upsert?: ApplicationDataUpsertWithWhereUniqueWithoutProductInput | ApplicationDataUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ApplicationDataCreateManyProductInputEnvelope
    set?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    disconnect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    delete?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    update?: ApplicationDataUpdateWithWhereUniqueWithoutProductInput | ApplicationDataUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ApplicationDataUpdateManyWithWhereWithoutProductInput | ApplicationDataUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
  }

  export type TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput> | TechnicalSpecificationCreateWithoutProductInput[] | TechnicalSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductInput | TechnicalSpecificationCreateOrConnectWithoutProductInput[]
    upsert?: TechnicalSpecificationUpsertWithWhereUniqueWithoutProductInput | TechnicalSpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TechnicalSpecificationCreateManyProductInputEnvelope
    set?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    delete?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    update?: TechnicalSpecificationUpdateWithWhereUniqueWithoutProductInput | TechnicalSpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TechnicalSpecificationUpdateManyWithWhereWithoutProductInput | TechnicalSpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
  }

  export type RelatedProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput> | RelatedProductCreateWithoutProductInput[] | RelatedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductInput | RelatedProductCreateOrConnectWithoutProductInput[]
    upsert?: RelatedProductUpsertWithWhereUniqueWithoutProductInput | RelatedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RelatedProductCreateManyProductInputEnvelope
    set?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    disconnect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    delete?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    update?: RelatedProductUpdateWithWhereUniqueWithoutProductInput | RelatedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RelatedProductUpdateManyWithWhereWithoutProductInput | RelatedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput> | ProcessStepCreateWithoutProductInput[] | ProcessStepUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductInput | ProcessStepCreateOrConnectWithoutProductInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProductInput | ProcessStepUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProcessStepCreateManyProductInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProductInput | ProcessStepUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProductInput | ProcessStepUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProductInput | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProductInput | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProductInput | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryTranslationCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput> | CategoryTranslationCreateWithoutProductsInput[] | CategoryTranslationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutProductsInput | CategoryTranslationCreateOrConnectWithoutProductsInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type AdvantageCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput> | AdvantageCreateWithoutProductTranslationsInput[] | AdvantageUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductTranslationsInput | AdvantageCreateOrConnectWithoutProductTranslationsInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
  }

  export type SpecificationCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput> | SpecificationCreateWithoutProductTranslationsInput[] | SpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductTranslationsInput | SpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
  }

  export type ApplicationDataCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput> | ApplicationDataCreateWithoutProductTranslationsInput[] | ApplicationDataUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductTranslationsInput | ApplicationDataCreateOrConnectWithoutProductTranslationsInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
  }

  export type TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput> | TechnicalSpecificationCreateWithoutProductTranslationsInput[] | TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput | TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
  }

  export type RelatedProductCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput> | RelatedProductCreateWithoutProductTranslationsInput[] | RelatedProductUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductTranslationsInput | RelatedProductCreateOrConnectWithoutProductTranslationsInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput> | ProcessStepCreateWithoutProductTranslationsInput[] | ProcessStepUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductTranslationsInput | ProcessStepCreateOrConnectWithoutProductTranslationsInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type modelSpecificationCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput> | modelSpecificationCreateWithoutProductTranslationsInput[] | modelSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductTranslationsInput | modelSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
  }

  export type CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput> | CategoryTranslationCreateWithoutProductsInput[] | CategoryTranslationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutProductsInput | CategoryTranslationCreateOrConnectWithoutProductsInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
  }

  export type AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput> | AdvantageCreateWithoutProductTranslationsInput[] | AdvantageUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductTranslationsInput | AdvantageCreateOrConnectWithoutProductTranslationsInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
  }

  export type SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput> | SpecificationCreateWithoutProductTranslationsInput[] | SpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductTranslationsInput | SpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
  }

  export type ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput> | ApplicationDataCreateWithoutProductTranslationsInput[] | ApplicationDataUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductTranslationsInput | ApplicationDataCreateOrConnectWithoutProductTranslationsInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
  }

  export type TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput> | TechnicalSpecificationCreateWithoutProductTranslationsInput[] | TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput | TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
  }

  export type RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput> | RelatedProductCreateWithoutProductTranslationsInput[] | RelatedProductUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductTranslationsInput | RelatedProductCreateOrConnectWithoutProductTranslationsInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput> | ProcessStepCreateWithoutProductTranslationsInput[] | ProcessStepUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductTranslationsInput | ProcessStepCreateOrConnectWithoutProductTranslationsInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput = {
    create?: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput> | modelSpecificationCreateWithoutProductTranslationsInput[] | modelSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductTranslationsInput | modelSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    upsert?: ProductUpsertWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTranslationsInput, ProductUpdateWithoutTranslationsInput>, ProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryTranslationUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput> | CategoryTranslationCreateWithoutProductsInput[] | CategoryTranslationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutProductsInput | CategoryTranslationCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutProductsInput | CategoryTranslationUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutProductsInput | CategoryTranslationUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutProductsInput | CategoryTranslationUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type AdvantageUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput> | AdvantageCreateWithoutProductTranslationsInput[] | AdvantageUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductTranslationsInput | AdvantageCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: AdvantageUpsertWithWhereUniqueWithoutProductTranslationsInput | AdvantageUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    disconnect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    delete?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    update?: AdvantageUpdateWithWhereUniqueWithoutProductTranslationsInput | AdvantageUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: AdvantageUpdateManyWithWhereWithoutProductTranslationsInput | AdvantageUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
  }

  export type SpecificationUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput> | SpecificationCreateWithoutProductTranslationsInput[] | SpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductTranslationsInput | SpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: SpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | SpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    disconnect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    delete?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    update?: SpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | SpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: SpecificationUpdateManyWithWhereWithoutProductTranslationsInput | SpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
  }

  export type ApplicationDataUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput> | ApplicationDataCreateWithoutProductTranslationsInput[] | ApplicationDataUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductTranslationsInput | ApplicationDataCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: ApplicationDataUpsertWithWhereUniqueWithoutProductTranslationsInput | ApplicationDataUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    disconnect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    delete?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    update?: ApplicationDataUpdateWithWhereUniqueWithoutProductTranslationsInput | ApplicationDataUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: ApplicationDataUpdateManyWithWhereWithoutProductTranslationsInput | ApplicationDataUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
  }

  export type TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput> | TechnicalSpecificationCreateWithoutProductTranslationsInput[] | TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput | TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: TechnicalSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | TechnicalSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    delete?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    update?: TechnicalSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | TechnicalSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: TechnicalSpecificationUpdateManyWithWhereWithoutProductTranslationsInput | TechnicalSpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
  }

  export type RelatedProductUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput> | RelatedProductCreateWithoutProductTranslationsInput[] | RelatedProductUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductTranslationsInput | RelatedProductCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: RelatedProductUpsertWithWhereUniqueWithoutProductTranslationsInput | RelatedProductUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    disconnect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    delete?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    update?: RelatedProductUpdateWithWhereUniqueWithoutProductTranslationsInput | RelatedProductUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: RelatedProductUpdateManyWithWhereWithoutProductTranslationsInput | RelatedProductUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
  }

  export type ProcessStepUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput> | ProcessStepCreateWithoutProductTranslationsInput[] | ProcessStepUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductTranslationsInput | ProcessStepCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProductTranslationsInput | ProcessStepUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProductTranslationsInput | ProcessStepUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProductTranslationsInput | ProcessStepUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type modelSpecificationUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput> | modelSpecificationCreateWithoutProductTranslationsInput[] | modelSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductTranslationsInput | modelSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: modelSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | modelSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    disconnect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    delete?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    update?: modelSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | modelSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: modelSpecificationUpdateManyWithWhereWithoutProductTranslationsInput | modelSpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput> | CategoryTranslationCreateWithoutProductsInput[] | CategoryTranslationUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryTranslationCreateOrConnectWithoutProductsInput | CategoryTranslationCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryTranslationUpsertWithWhereUniqueWithoutProductsInput | CategoryTranslationUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    disconnect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    delete?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    connect?: CategoryTranslationWhereUniqueInput | CategoryTranslationWhereUniqueInput[]
    update?: CategoryTranslationUpdateWithWhereUniqueWithoutProductsInput | CategoryTranslationUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryTranslationUpdateManyWithWhereWithoutProductsInput | CategoryTranslationUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
  }

  export type AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput> | AdvantageCreateWithoutProductTranslationsInput[] | AdvantageUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: AdvantageCreateOrConnectWithoutProductTranslationsInput | AdvantageCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: AdvantageUpsertWithWhereUniqueWithoutProductTranslationsInput | AdvantageUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    disconnect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    delete?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    connect?: AdvantageWhereUniqueInput | AdvantageWhereUniqueInput[]
    update?: AdvantageUpdateWithWhereUniqueWithoutProductTranslationsInput | AdvantageUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: AdvantageUpdateManyWithWhereWithoutProductTranslationsInput | AdvantageUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
  }

  export type SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput> | SpecificationCreateWithoutProductTranslationsInput[] | SpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: SpecificationCreateOrConnectWithoutProductTranslationsInput | SpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: SpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | SpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    disconnect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    delete?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    connect?: SpecificationWhereUniqueInput | SpecificationWhereUniqueInput[]
    update?: SpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | SpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: SpecificationUpdateManyWithWhereWithoutProductTranslationsInput | SpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
  }

  export type ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput> | ApplicationDataCreateWithoutProductTranslationsInput[] | ApplicationDataUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutProductTranslationsInput | ApplicationDataCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: ApplicationDataUpsertWithWhereUniqueWithoutProductTranslationsInput | ApplicationDataUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    disconnect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    delete?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    connect?: ApplicationDataWhereUniqueInput | ApplicationDataWhereUniqueInput[]
    update?: ApplicationDataUpdateWithWhereUniqueWithoutProductTranslationsInput | ApplicationDataUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: ApplicationDataUpdateManyWithWhereWithoutProductTranslationsInput | ApplicationDataUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
  }

  export type TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput> | TechnicalSpecificationCreateWithoutProductTranslationsInput[] | TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput | TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: TechnicalSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | TechnicalSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    delete?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    connect?: TechnicalSpecificationWhereUniqueInput | TechnicalSpecificationWhereUniqueInput[]
    update?: TechnicalSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | TechnicalSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: TechnicalSpecificationUpdateManyWithWhereWithoutProductTranslationsInput | TechnicalSpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
  }

  export type RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput> | RelatedProductCreateWithoutProductTranslationsInput[] | RelatedProductUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: RelatedProductCreateOrConnectWithoutProductTranslationsInput | RelatedProductCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: RelatedProductUpsertWithWhereUniqueWithoutProductTranslationsInput | RelatedProductUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    disconnect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    delete?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    connect?: RelatedProductWhereUniqueInput | RelatedProductWhereUniqueInput[]
    update?: RelatedProductUpdateWithWhereUniqueWithoutProductTranslationsInput | RelatedProductUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: RelatedProductUpdateManyWithWhereWithoutProductTranslationsInput | RelatedProductUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput> | ProcessStepCreateWithoutProductTranslationsInput[] | ProcessStepUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProductTranslationsInput | ProcessStepCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProductTranslationsInput | ProcessStepUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProductTranslationsInput | ProcessStepUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProductTranslationsInput | ProcessStepUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput = {
    create?: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput> | modelSpecificationCreateWithoutProductTranslationsInput[] | modelSpecificationUncheckedCreateWithoutProductTranslationsInput[]
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutProductTranslationsInput | modelSpecificationCreateOrConnectWithoutProductTranslationsInput[]
    upsert?: modelSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput | modelSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput[]
    set?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    disconnect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    delete?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    connect?: modelSpecificationWhereUniqueInput | modelSpecificationWhereUniqueInput[]
    update?: modelSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput | modelSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput[]
    updateMany?: modelSpecificationUpdateManyWithWhereWithoutProductTranslationsInput | modelSpecificationUpdateManyWithWhereWithoutProductTranslationsInput[]
    deleteMany?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutModelSpecificationInput = {
    create?: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput> | ProductCreateWithoutModelSpecificationInput[] | ProductUncheckedCreateWithoutModelSpecificationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutModelSpecificationInput | ProductCreateOrConnectWithoutModelSpecificationInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type modelSpecificationTranslationCreateNestedManyWithoutModelSpecInput = {
    create?: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput> | modelSpecificationTranslationCreateWithoutModelSpecInput[] | modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput[]
    connectOrCreate?: modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput | modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput[]
    createMany?: modelSpecificationTranslationCreateManyModelSpecInputEnvelope
    connect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutModelSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput> | ProductTranslationCreateWithoutModelSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutModelSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutModelSpecificationsInput | ProductTranslationCreateOrConnectWithoutModelSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutModelSpecificationInput = {
    create?: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput> | ProductCreateWithoutModelSpecificationInput[] | ProductUncheckedCreateWithoutModelSpecificationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutModelSpecificationInput | ProductCreateOrConnectWithoutModelSpecificationInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type modelSpecificationTranslationUncheckedCreateNestedManyWithoutModelSpecInput = {
    create?: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput> | modelSpecificationTranslationCreateWithoutModelSpecInput[] | modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput[]
    connectOrCreate?: modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput | modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput[]
    createMany?: modelSpecificationTranslationCreateManyModelSpecInputEnvelope
    connect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutModelSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput> | ProductTranslationCreateWithoutModelSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutModelSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutModelSpecificationsInput | ProductTranslationCreateOrConnectWithoutModelSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutModelSpecificationNestedInput = {
    create?: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput> | ProductCreateWithoutModelSpecificationInput[] | ProductUncheckedCreateWithoutModelSpecificationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutModelSpecificationInput | ProductCreateOrConnectWithoutModelSpecificationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutModelSpecificationInput | ProductUpsertWithWhereUniqueWithoutModelSpecificationInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutModelSpecificationInput | ProductUpdateWithWhereUniqueWithoutModelSpecificationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutModelSpecificationInput | ProductUpdateManyWithWhereWithoutModelSpecificationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type modelSpecificationTranslationUpdateManyWithoutModelSpecNestedInput = {
    create?: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput> | modelSpecificationTranslationCreateWithoutModelSpecInput[] | modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput[]
    connectOrCreate?: modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput | modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput[]
    upsert?: modelSpecificationTranslationUpsertWithWhereUniqueWithoutModelSpecInput | modelSpecificationTranslationUpsertWithWhereUniqueWithoutModelSpecInput[]
    createMany?: modelSpecificationTranslationCreateManyModelSpecInputEnvelope
    set?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    disconnect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    delete?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    connect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    update?: modelSpecificationTranslationUpdateWithWhereUniqueWithoutModelSpecInput | modelSpecificationTranslationUpdateWithWhereUniqueWithoutModelSpecInput[]
    updateMany?: modelSpecificationTranslationUpdateManyWithWhereWithoutModelSpecInput | modelSpecificationTranslationUpdateManyWithWhereWithoutModelSpecInput[]
    deleteMany?: modelSpecificationTranslationScalarWhereInput | modelSpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutModelSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput> | ProductTranslationCreateWithoutModelSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutModelSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutModelSpecificationsInput | ProductTranslationCreateOrConnectWithoutModelSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutModelSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutModelSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutModelSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutModelSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutModelSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutModelSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutModelSpecificationNestedInput = {
    create?: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput> | ProductCreateWithoutModelSpecificationInput[] | ProductUncheckedCreateWithoutModelSpecificationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutModelSpecificationInput | ProductCreateOrConnectWithoutModelSpecificationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutModelSpecificationInput | ProductUpsertWithWhereUniqueWithoutModelSpecificationInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutModelSpecificationInput | ProductUpdateWithWhereUniqueWithoutModelSpecificationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutModelSpecificationInput | ProductUpdateManyWithWhereWithoutModelSpecificationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecNestedInput = {
    create?: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput> | modelSpecificationTranslationCreateWithoutModelSpecInput[] | modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput[]
    connectOrCreate?: modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput | modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput[]
    upsert?: modelSpecificationTranslationUpsertWithWhereUniqueWithoutModelSpecInput | modelSpecificationTranslationUpsertWithWhereUniqueWithoutModelSpecInput[]
    createMany?: modelSpecificationTranslationCreateManyModelSpecInputEnvelope
    set?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    disconnect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    delete?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    connect?: modelSpecificationTranslationWhereUniqueInput | modelSpecificationTranslationWhereUniqueInput[]
    update?: modelSpecificationTranslationUpdateWithWhereUniqueWithoutModelSpecInput | modelSpecificationTranslationUpdateWithWhereUniqueWithoutModelSpecInput[]
    updateMany?: modelSpecificationTranslationUpdateManyWithWhereWithoutModelSpecInput | modelSpecificationTranslationUpdateManyWithWhereWithoutModelSpecInput[]
    deleteMany?: modelSpecificationTranslationScalarWhereInput | modelSpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput> | ProductTranslationCreateWithoutModelSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutModelSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutModelSpecificationsInput | ProductTranslationCreateOrConnectWithoutModelSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutModelSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutModelSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutModelSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutModelSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutModelSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutModelSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type modelSpecificationCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<modelSpecificationCreateWithoutTranslationsInput, modelSpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutTranslationsInput
    connect?: modelSpecificationWhereUniqueInput
  }

  export type modelSpecificationUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<modelSpecificationCreateWithoutTranslationsInput, modelSpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: modelSpecificationCreateOrConnectWithoutTranslationsInput
    upsert?: modelSpecificationUpsertWithoutTranslationsInput
    connect?: modelSpecificationWhereUniqueInput
    update?: XOR<XOR<modelSpecificationUpdateToOneWithWhereWithoutTranslationsInput, modelSpecificationUpdateWithoutTranslationsInput>, modelSpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput> | ProductCreateWithoutAdvantagesInput[] | ProductUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdvantagesInput | ProductCreateOrConnectWithoutAdvantagesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AdvantageTranslationCreateNestedManyWithoutAdvantageInput = {
    create?: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput> | AdvantageTranslationCreateWithoutAdvantageInput[] | AdvantageTranslationUncheckedCreateWithoutAdvantageInput[]
    connectOrCreate?: AdvantageTranslationCreateOrConnectWithoutAdvantageInput | AdvantageTranslationCreateOrConnectWithoutAdvantageInput[]
    createMany?: AdvantageTranslationCreateManyAdvantageInputEnvelope
    connect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput> | ProductTranslationCreateWithoutAdvantagesInput[] | ProductTranslationUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutAdvantagesInput | ProductTranslationCreateOrConnectWithoutAdvantagesInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput> | ProductCreateWithoutAdvantagesInput[] | ProductUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdvantagesInput | ProductCreateOrConnectWithoutAdvantagesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AdvantageTranslationUncheckedCreateNestedManyWithoutAdvantageInput = {
    create?: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput> | AdvantageTranslationCreateWithoutAdvantageInput[] | AdvantageTranslationUncheckedCreateWithoutAdvantageInput[]
    connectOrCreate?: AdvantageTranslationCreateOrConnectWithoutAdvantageInput | AdvantageTranslationCreateOrConnectWithoutAdvantageInput[]
    createMany?: AdvantageTranslationCreateManyAdvantageInputEnvelope
    connect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput> | ProductTranslationCreateWithoutAdvantagesInput[] | ProductTranslationUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutAdvantagesInput | ProductTranslationCreateOrConnectWithoutAdvantagesInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput> | ProductCreateWithoutAdvantagesInput[] | ProductUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdvantagesInput | ProductCreateOrConnectWithoutAdvantagesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutAdvantagesInput | ProductUpsertWithWhereUniqueWithoutAdvantagesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutAdvantagesInput | ProductUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutAdvantagesInput | ProductUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AdvantageTranslationUpdateManyWithoutAdvantageNestedInput = {
    create?: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput> | AdvantageTranslationCreateWithoutAdvantageInput[] | AdvantageTranslationUncheckedCreateWithoutAdvantageInput[]
    connectOrCreate?: AdvantageTranslationCreateOrConnectWithoutAdvantageInput | AdvantageTranslationCreateOrConnectWithoutAdvantageInput[]
    upsert?: AdvantageTranslationUpsertWithWhereUniqueWithoutAdvantageInput | AdvantageTranslationUpsertWithWhereUniqueWithoutAdvantageInput[]
    createMany?: AdvantageTranslationCreateManyAdvantageInputEnvelope
    set?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    disconnect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    delete?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    connect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    update?: AdvantageTranslationUpdateWithWhereUniqueWithoutAdvantageInput | AdvantageTranslationUpdateWithWhereUniqueWithoutAdvantageInput[]
    updateMany?: AdvantageTranslationUpdateManyWithWhereWithoutAdvantageInput | AdvantageTranslationUpdateManyWithWhereWithoutAdvantageInput[]
    deleteMany?: AdvantageTranslationScalarWhereInput | AdvantageTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput> | ProductTranslationCreateWithoutAdvantagesInput[] | ProductTranslationUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutAdvantagesInput | ProductTranslationCreateOrConnectWithoutAdvantagesInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutAdvantagesInput | ProductTranslationUpsertWithWhereUniqueWithoutAdvantagesInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutAdvantagesInput | ProductTranslationUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutAdvantagesInput | ProductTranslationUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput> | ProductCreateWithoutAdvantagesInput[] | ProductUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdvantagesInput | ProductCreateOrConnectWithoutAdvantagesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutAdvantagesInput | ProductUpsertWithWhereUniqueWithoutAdvantagesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutAdvantagesInput | ProductUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutAdvantagesInput | ProductUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AdvantageTranslationUncheckedUpdateManyWithoutAdvantageNestedInput = {
    create?: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput> | AdvantageTranslationCreateWithoutAdvantageInput[] | AdvantageTranslationUncheckedCreateWithoutAdvantageInput[]
    connectOrCreate?: AdvantageTranslationCreateOrConnectWithoutAdvantageInput | AdvantageTranslationCreateOrConnectWithoutAdvantageInput[]
    upsert?: AdvantageTranslationUpsertWithWhereUniqueWithoutAdvantageInput | AdvantageTranslationUpsertWithWhereUniqueWithoutAdvantageInput[]
    createMany?: AdvantageTranslationCreateManyAdvantageInputEnvelope
    set?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    disconnect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    delete?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    connect?: AdvantageTranslationWhereUniqueInput | AdvantageTranslationWhereUniqueInput[]
    update?: AdvantageTranslationUpdateWithWhereUniqueWithoutAdvantageInput | AdvantageTranslationUpdateWithWhereUniqueWithoutAdvantageInput[]
    updateMany?: AdvantageTranslationUpdateManyWithWhereWithoutAdvantageInput | AdvantageTranslationUpdateManyWithWhereWithoutAdvantageInput[]
    deleteMany?: AdvantageTranslationScalarWhereInput | AdvantageTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput> | ProductTranslationCreateWithoutAdvantagesInput[] | ProductTranslationUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutAdvantagesInput | ProductTranslationCreateOrConnectWithoutAdvantagesInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutAdvantagesInput | ProductTranslationUpsertWithWhereUniqueWithoutAdvantagesInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutAdvantagesInput | ProductTranslationUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutAdvantagesInput | ProductTranslationUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type AdvantageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<AdvantageCreateWithoutTranslationsInput, AdvantageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: AdvantageCreateOrConnectWithoutTranslationsInput
    connect?: AdvantageWhereUniqueInput
  }

  export type AdvantageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<AdvantageCreateWithoutTranslationsInput, AdvantageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: AdvantageCreateOrConnectWithoutTranslationsInput
    upsert?: AdvantageUpsertWithoutTranslationsInput
    connect?: AdvantageWhereUniqueInput
    update?: XOR<XOR<AdvantageUpdateToOneWithWhereWithoutTranslationsInput, AdvantageUpdateWithoutTranslationsInput>, AdvantageUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutSpecificationsInput = {
    create?: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecificationsInput
    connect?: ProductWhereUniqueInput
  }

  export type SpecificationTranslationCreateNestedManyWithoutSpecificationInput = {
    create?: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput> | SpecificationTranslationCreateWithoutSpecificationInput[] | SpecificationTranslationUncheckedCreateWithoutSpecificationInput[]
    connectOrCreate?: SpecificationTranslationCreateOrConnectWithoutSpecificationInput | SpecificationTranslationCreateOrConnectWithoutSpecificationInput[]
    createMany?: SpecificationTranslationCreateManySpecificationInputEnvelope
    connect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput> | ProductTranslationCreateWithoutSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutSpecificationsInput | ProductTranslationCreateOrConnectWithoutSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type SpecificationTranslationUncheckedCreateNestedManyWithoutSpecificationInput = {
    create?: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput> | SpecificationTranslationCreateWithoutSpecificationInput[] | SpecificationTranslationUncheckedCreateWithoutSpecificationInput[]
    connectOrCreate?: SpecificationTranslationCreateOrConnectWithoutSpecificationInput | SpecificationTranslationCreateOrConnectWithoutSpecificationInput[]
    createMany?: SpecificationTranslationCreateManySpecificationInputEnvelope
    connect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput> | ProductTranslationCreateWithoutSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutSpecificationsInput | ProductTranslationCreateOrConnectWithoutSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutSpecificationsNestedInput = {
    create?: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecificationsInput
    upsert?: ProductUpsertWithoutSpecificationsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSpecificationsInput, ProductUpdateWithoutSpecificationsInput>, ProductUncheckedUpdateWithoutSpecificationsInput>
  }

  export type SpecificationTranslationUpdateManyWithoutSpecificationNestedInput = {
    create?: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput> | SpecificationTranslationCreateWithoutSpecificationInput[] | SpecificationTranslationUncheckedCreateWithoutSpecificationInput[]
    connectOrCreate?: SpecificationTranslationCreateOrConnectWithoutSpecificationInput | SpecificationTranslationCreateOrConnectWithoutSpecificationInput[]
    upsert?: SpecificationTranslationUpsertWithWhereUniqueWithoutSpecificationInput | SpecificationTranslationUpsertWithWhereUniqueWithoutSpecificationInput[]
    createMany?: SpecificationTranslationCreateManySpecificationInputEnvelope
    set?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    disconnect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    delete?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    connect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    update?: SpecificationTranslationUpdateWithWhereUniqueWithoutSpecificationInput | SpecificationTranslationUpdateWithWhereUniqueWithoutSpecificationInput[]
    updateMany?: SpecificationTranslationUpdateManyWithWhereWithoutSpecificationInput | SpecificationTranslationUpdateManyWithWhereWithoutSpecificationInput[]
    deleteMany?: SpecificationTranslationScalarWhereInput | SpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput> | ProductTranslationCreateWithoutSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutSpecificationsInput | ProductTranslationCreateOrConnectWithoutSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type SpecificationTranslationUncheckedUpdateManyWithoutSpecificationNestedInput = {
    create?: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput> | SpecificationTranslationCreateWithoutSpecificationInput[] | SpecificationTranslationUncheckedCreateWithoutSpecificationInput[]
    connectOrCreate?: SpecificationTranslationCreateOrConnectWithoutSpecificationInput | SpecificationTranslationCreateOrConnectWithoutSpecificationInput[]
    upsert?: SpecificationTranslationUpsertWithWhereUniqueWithoutSpecificationInput | SpecificationTranslationUpsertWithWhereUniqueWithoutSpecificationInput[]
    createMany?: SpecificationTranslationCreateManySpecificationInputEnvelope
    set?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    disconnect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    delete?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    connect?: SpecificationTranslationWhereUniqueInput | SpecificationTranslationWhereUniqueInput[]
    update?: SpecificationTranslationUpdateWithWhereUniqueWithoutSpecificationInput | SpecificationTranslationUpdateWithWhereUniqueWithoutSpecificationInput[]
    updateMany?: SpecificationTranslationUpdateManyWithWhereWithoutSpecificationInput | SpecificationTranslationUpdateManyWithWhereWithoutSpecificationInput[]
    deleteMany?: SpecificationTranslationScalarWhereInput | SpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput> | ProductTranslationCreateWithoutSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutSpecificationsInput | ProductTranslationCreateOrConnectWithoutSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type SpecificationCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<SpecificationCreateWithoutTranslationsInput, SpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: SpecificationCreateOrConnectWithoutTranslationsInput
    connect?: SpecificationWhereUniqueInput
  }

  export type SpecificationUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<SpecificationCreateWithoutTranslationsInput, SpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: SpecificationCreateOrConnectWithoutTranslationsInput
    upsert?: SpecificationUpsertWithoutTranslationsInput
    connect?: SpecificationWhereUniqueInput
    update?: XOR<XOR<SpecificationUpdateToOneWithWhereWithoutTranslationsInput, SpecificationUpdateWithoutTranslationsInput>, SpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutApplicationDataInput = {
    create?: XOR<ProductCreateWithoutApplicationDataInput, ProductUncheckedCreateWithoutApplicationDataInput>
    connectOrCreate?: ProductCreateOrConnectWithoutApplicationDataInput
    connect?: ProductWhereUniqueInput
  }

  export type ApplicationDataTranslationCreateNestedManyWithoutApplicationDataInput = {
    create?: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput> | ApplicationDataTranslationCreateWithoutApplicationDataInput[] | ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput | ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput[]
    createMany?: ApplicationDataTranslationCreateManyApplicationDataInputEnvelope
    connect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutApplicationDataInput = {
    create?: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput> | ProductTranslationCreateWithoutApplicationDataInput[] | ProductTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutApplicationDataInput | ProductTranslationCreateOrConnectWithoutApplicationDataInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ApplicationDataTranslationUncheckedCreateNestedManyWithoutApplicationDataInput = {
    create?: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput> | ApplicationDataTranslationCreateWithoutApplicationDataInput[] | ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput | ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput[]
    createMany?: ApplicationDataTranslationCreateManyApplicationDataInputEnvelope
    connect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutApplicationDataInput = {
    create?: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput> | ProductTranslationCreateWithoutApplicationDataInput[] | ProductTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutApplicationDataInput | ProductTranslationCreateOrConnectWithoutApplicationDataInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutApplicationDataNestedInput = {
    create?: XOR<ProductCreateWithoutApplicationDataInput, ProductUncheckedCreateWithoutApplicationDataInput>
    connectOrCreate?: ProductCreateOrConnectWithoutApplicationDataInput
    upsert?: ProductUpsertWithoutApplicationDataInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutApplicationDataInput, ProductUpdateWithoutApplicationDataInput>, ProductUncheckedUpdateWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationUpdateManyWithoutApplicationDataNestedInput = {
    create?: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput> | ApplicationDataTranslationCreateWithoutApplicationDataInput[] | ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput | ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput[]
    upsert?: ApplicationDataTranslationUpsertWithWhereUniqueWithoutApplicationDataInput | ApplicationDataTranslationUpsertWithWhereUniqueWithoutApplicationDataInput[]
    createMany?: ApplicationDataTranslationCreateManyApplicationDataInputEnvelope
    set?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    disconnect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    delete?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    connect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    update?: ApplicationDataTranslationUpdateWithWhereUniqueWithoutApplicationDataInput | ApplicationDataTranslationUpdateWithWhereUniqueWithoutApplicationDataInput[]
    updateMany?: ApplicationDataTranslationUpdateManyWithWhereWithoutApplicationDataInput | ApplicationDataTranslationUpdateManyWithWhereWithoutApplicationDataInput[]
    deleteMany?: ApplicationDataTranslationScalarWhereInput | ApplicationDataTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutApplicationDataNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput> | ProductTranslationCreateWithoutApplicationDataInput[] | ProductTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutApplicationDataInput | ProductTranslationCreateOrConnectWithoutApplicationDataInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutApplicationDataInput | ProductTranslationUpsertWithWhereUniqueWithoutApplicationDataInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutApplicationDataInput | ProductTranslationUpdateWithWhereUniqueWithoutApplicationDataInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutApplicationDataInput | ProductTranslationUpdateManyWithWhereWithoutApplicationDataInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput = {
    create?: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput> | ApplicationDataTranslationCreateWithoutApplicationDataInput[] | ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput | ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput[]
    upsert?: ApplicationDataTranslationUpsertWithWhereUniqueWithoutApplicationDataInput | ApplicationDataTranslationUpsertWithWhereUniqueWithoutApplicationDataInput[]
    createMany?: ApplicationDataTranslationCreateManyApplicationDataInputEnvelope
    set?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    disconnect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    delete?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    connect?: ApplicationDataTranslationWhereUniqueInput | ApplicationDataTranslationWhereUniqueInput[]
    update?: ApplicationDataTranslationUpdateWithWhereUniqueWithoutApplicationDataInput | ApplicationDataTranslationUpdateWithWhereUniqueWithoutApplicationDataInput[]
    updateMany?: ApplicationDataTranslationUpdateManyWithWhereWithoutApplicationDataInput | ApplicationDataTranslationUpdateManyWithWhereWithoutApplicationDataInput[]
    deleteMany?: ApplicationDataTranslationScalarWhereInput | ApplicationDataTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput> | ProductTranslationCreateWithoutApplicationDataInput[] | ProductTranslationUncheckedCreateWithoutApplicationDataInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutApplicationDataInput | ProductTranslationCreateOrConnectWithoutApplicationDataInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutApplicationDataInput | ProductTranslationUpsertWithWhereUniqueWithoutApplicationDataInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutApplicationDataInput | ProductTranslationUpdateWithWhereUniqueWithoutApplicationDataInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutApplicationDataInput | ProductTranslationUpdateManyWithWhereWithoutApplicationDataInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ApplicationDataCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ApplicationDataCreateWithoutTranslationsInput, ApplicationDataUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutTranslationsInput
    connect?: ApplicationDataWhereUniqueInput
  }

  export type ApplicationDataUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ApplicationDataCreateWithoutTranslationsInput, ApplicationDataUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ApplicationDataCreateOrConnectWithoutTranslationsInput
    upsert?: ApplicationDataUpsertWithoutTranslationsInput
    connect?: ApplicationDataWhereUniqueInput
    update?: XOR<XOR<ApplicationDataUpdateToOneWithWhereWithoutTranslationsInput, ApplicationDataUpdateWithoutTranslationsInput>, ApplicationDataUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutTechnicalSpecificationsInput = {
    create?: XOR<ProductCreateWithoutTechnicalSpecificationsInput, ProductUncheckedCreateWithoutTechnicalSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTechnicalSpecificationsInput
    connect?: ProductWhereUniqueInput
  }

  export type TechnicalSpecificationTranslationCreateNestedManyWithoutTechnicalSpecificationInput = {
    create?: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput> | TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput[] | TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput[]
    connectOrCreate?: TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput[]
    createMany?: TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInputEnvelope
    connect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutTechnicalSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput> | ProductTranslationCreateWithoutTechnicalSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput | ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type TechnicalSpecificationTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationInput = {
    create?: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput> | TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput[] | TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput[]
    connectOrCreate?: TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput[]
    createMany?: TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInputEnvelope
    connect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationsInput = {
    create?: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput> | ProductTranslationCreateWithoutTechnicalSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput | ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutTechnicalSpecificationsNestedInput = {
    create?: XOR<ProductCreateWithoutTechnicalSpecificationsInput, ProductUncheckedCreateWithoutTechnicalSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTechnicalSpecificationsInput
    upsert?: ProductUpsertWithoutTechnicalSpecificationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTechnicalSpecificationsInput, ProductUpdateWithoutTechnicalSpecificationsInput>, ProductUncheckedUpdateWithoutTechnicalSpecificationsInput>
  }

  export type TechnicalSpecificationTranslationUpdateManyWithoutTechnicalSpecificationNestedInput = {
    create?: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput> | TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput[] | TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput[]
    connectOrCreate?: TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput[]
    upsert?: TechnicalSpecificationTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationInput[]
    createMany?: TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInputEnvelope
    set?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    delete?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    connect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    update?: TechnicalSpecificationTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationInput[]
    updateMany?: TechnicalSpecificationTranslationUpdateManyWithWhereWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpdateManyWithWhereWithoutTechnicalSpecificationInput[]
    deleteMany?: TechnicalSpecificationTranslationScalarWhereInput | TechnicalSpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutTechnicalSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput> | ProductTranslationCreateWithoutTechnicalSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput | ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutTechnicalSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutTechnicalSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationNestedInput = {
    create?: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput> | TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput[] | TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput[]
    connectOrCreate?: TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput[]
    upsert?: TechnicalSpecificationTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationInput[]
    createMany?: TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInputEnvelope
    set?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    disconnect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    delete?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    connect?: TechnicalSpecificationTranslationWhereUniqueInput | TechnicalSpecificationTranslationWhereUniqueInput[]
    update?: TechnicalSpecificationTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationInput[]
    updateMany?: TechnicalSpecificationTranslationUpdateManyWithWhereWithoutTechnicalSpecificationInput | TechnicalSpecificationTranslationUpdateManyWithWhereWithoutTechnicalSpecificationInput[]
    deleteMany?: TechnicalSpecificationTranslationScalarWhereInput | TechnicalSpecificationTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput> | ProductTranslationCreateWithoutTechnicalSpecificationsInput[] | ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput | ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationsInput | ProductTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationsInput | ProductTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutTechnicalSpecificationsInput | ProductTranslationUpdateManyWithWhereWithoutTechnicalSpecificationsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type TechnicalSpecificationCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutTranslationsInput
    connect?: TechnicalSpecificationWhereUniqueInput
  }

  export type TechnicalSpecificationUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<TechnicalSpecificationCreateWithoutTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: TechnicalSpecificationCreateOrConnectWithoutTranslationsInput
    upsert?: TechnicalSpecificationUpsertWithoutTranslationsInput
    connect?: TechnicalSpecificationWhereUniqueInput
    update?: XOR<XOR<TechnicalSpecificationUpdateToOneWithWhereWithoutTranslationsInput, TechnicalSpecificationUpdateWithoutTranslationsInput>, TechnicalSpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutRelatedProductsInput = {
    create?: XOR<ProductCreateWithoutRelatedProductsInput, ProductUncheckedCreateWithoutRelatedProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRelatedProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type RelatedProductTranslationCreateNestedManyWithoutRelatedProductInput = {
    create?: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput> | RelatedProductTranslationCreateWithoutRelatedProductInput[] | RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput | RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput[]
    createMany?: RelatedProductTranslationCreateManyRelatedProductInputEnvelope
    connect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutRelatedProductsInput = {
    create?: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput> | ProductTranslationCreateWithoutRelatedProductsInput[] | ProductTranslationUncheckedCreateWithoutRelatedProductsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutRelatedProductsInput | ProductTranslationCreateOrConnectWithoutRelatedProductsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type RelatedProductTranslationUncheckedCreateNestedManyWithoutRelatedProductInput = {
    create?: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput> | RelatedProductTranslationCreateWithoutRelatedProductInput[] | RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput | RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput[]
    createMany?: RelatedProductTranslationCreateManyRelatedProductInputEnvelope
    connect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutRelatedProductsInput = {
    create?: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput> | ProductTranslationCreateWithoutRelatedProductsInput[] | ProductTranslationUncheckedCreateWithoutRelatedProductsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutRelatedProductsInput | ProductTranslationCreateOrConnectWithoutRelatedProductsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type EnumMachineTypeFieldUpdateOperationsInput = {
    set?: $Enums.MachineType
  }

  export type ProductUpdateOneRequiredWithoutRelatedProductsNestedInput = {
    create?: XOR<ProductCreateWithoutRelatedProductsInput, ProductUncheckedCreateWithoutRelatedProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRelatedProductsInput
    upsert?: ProductUpsertWithoutRelatedProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRelatedProductsInput, ProductUpdateWithoutRelatedProductsInput>, ProductUncheckedUpdateWithoutRelatedProductsInput>
  }

  export type RelatedProductTranslationUpdateManyWithoutRelatedProductNestedInput = {
    create?: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput> | RelatedProductTranslationCreateWithoutRelatedProductInput[] | RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput | RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput[]
    upsert?: RelatedProductTranslationUpsertWithWhereUniqueWithoutRelatedProductInput | RelatedProductTranslationUpsertWithWhereUniqueWithoutRelatedProductInput[]
    createMany?: RelatedProductTranslationCreateManyRelatedProductInputEnvelope
    set?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    disconnect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    delete?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    connect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    update?: RelatedProductTranslationUpdateWithWhereUniqueWithoutRelatedProductInput | RelatedProductTranslationUpdateWithWhereUniqueWithoutRelatedProductInput[]
    updateMany?: RelatedProductTranslationUpdateManyWithWhereWithoutRelatedProductInput | RelatedProductTranslationUpdateManyWithWhereWithoutRelatedProductInput[]
    deleteMany?: RelatedProductTranslationScalarWhereInput | RelatedProductTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutRelatedProductsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput> | ProductTranslationCreateWithoutRelatedProductsInput[] | ProductTranslationUncheckedCreateWithoutRelatedProductsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutRelatedProductsInput | ProductTranslationCreateOrConnectWithoutRelatedProductsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutRelatedProductsInput | ProductTranslationUpsertWithWhereUniqueWithoutRelatedProductsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutRelatedProductsInput | ProductTranslationUpdateWithWhereUniqueWithoutRelatedProductsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutRelatedProductsInput | ProductTranslationUpdateManyWithWhereWithoutRelatedProductsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductNestedInput = {
    create?: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput> | RelatedProductTranslationCreateWithoutRelatedProductInput[] | RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput | RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput[]
    upsert?: RelatedProductTranslationUpsertWithWhereUniqueWithoutRelatedProductInput | RelatedProductTranslationUpsertWithWhereUniqueWithoutRelatedProductInput[]
    createMany?: RelatedProductTranslationCreateManyRelatedProductInputEnvelope
    set?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    disconnect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    delete?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    connect?: RelatedProductTranslationWhereUniqueInput | RelatedProductTranslationWhereUniqueInput[]
    update?: RelatedProductTranslationUpdateWithWhereUniqueWithoutRelatedProductInput | RelatedProductTranslationUpdateWithWhereUniqueWithoutRelatedProductInput[]
    updateMany?: RelatedProductTranslationUpdateManyWithWhereWithoutRelatedProductInput | RelatedProductTranslationUpdateManyWithWhereWithoutRelatedProductInput[]
    deleteMany?: RelatedProductTranslationScalarWhereInput | RelatedProductTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutRelatedProductsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput> | ProductTranslationCreateWithoutRelatedProductsInput[] | ProductTranslationUncheckedCreateWithoutRelatedProductsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutRelatedProductsInput | ProductTranslationCreateOrConnectWithoutRelatedProductsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutRelatedProductsInput | ProductTranslationUpsertWithWhereUniqueWithoutRelatedProductsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutRelatedProductsInput | ProductTranslationUpdateWithWhereUniqueWithoutRelatedProductsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutRelatedProductsInput | ProductTranslationUpdateManyWithWhereWithoutRelatedProductsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type RelatedProductCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<RelatedProductCreateWithoutTranslationsInput, RelatedProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RelatedProductCreateOrConnectWithoutTranslationsInput
    connect?: RelatedProductWhereUniqueInput
  }

  export type RelatedProductUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<RelatedProductCreateWithoutTranslationsInput, RelatedProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: RelatedProductCreateOrConnectWithoutTranslationsInput
    upsert?: RelatedProductUpsertWithoutTranslationsInput
    connect?: RelatedProductWhereUniqueInput
    update?: XOR<XOR<RelatedProductUpdateToOneWithWhereWithoutTranslationsInput, RelatedProductUpdateWithoutTranslationsInput>, RelatedProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutProcessStepsInput = {
    create?: XOR<ProductCreateWithoutProcessStepsInput, ProductUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProcessStepsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProcessStepTranslationCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput> | ProcessStepTranslationCreateWithoutProcessStepInput[] | ProcessStepTranslationUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ProcessStepTranslationCreateOrConnectWithoutProcessStepInput | ProcessStepTranslationCreateOrConnectWithoutProcessStepInput[]
    createMany?: ProcessStepTranslationCreateManyProcessStepInputEnvelope
    connect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutProcessStepsInput = {
    create?: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput> | ProductTranslationCreateWithoutProcessStepsInput[] | ProductTranslationUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProcessStepsInput | ProductTranslationCreateOrConnectWithoutProcessStepsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProcessStepTranslationUncheckedCreateNestedManyWithoutProcessStepInput = {
    create?: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput> | ProcessStepTranslationCreateWithoutProcessStepInput[] | ProcessStepTranslationUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ProcessStepTranslationCreateOrConnectWithoutProcessStepInput | ProcessStepTranslationCreateOrConnectWithoutProcessStepInput[]
    createMany?: ProcessStepTranslationCreateManyProcessStepInputEnvelope
    connect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutProcessStepsInput = {
    create?: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput> | ProductTranslationCreateWithoutProcessStepsInput[] | ProductTranslationUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProcessStepsInput | ProductTranslationCreateOrConnectWithoutProcessStepsInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProcessStepsNestedInput = {
    create?: XOR<ProductCreateWithoutProcessStepsInput, ProductUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProcessStepsInput
    upsert?: ProductUpsertWithoutProcessStepsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProcessStepsInput, ProductUpdateWithoutProcessStepsInput>, ProductUncheckedUpdateWithoutProcessStepsInput>
  }

  export type ProcessStepTranslationUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput> | ProcessStepTranslationCreateWithoutProcessStepInput[] | ProcessStepTranslationUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ProcessStepTranslationCreateOrConnectWithoutProcessStepInput | ProcessStepTranslationCreateOrConnectWithoutProcessStepInput[]
    upsert?: ProcessStepTranslationUpsertWithWhereUniqueWithoutProcessStepInput | ProcessStepTranslationUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: ProcessStepTranslationCreateManyProcessStepInputEnvelope
    set?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    disconnect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    delete?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    connect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    update?: ProcessStepTranslationUpdateWithWhereUniqueWithoutProcessStepInput | ProcessStepTranslationUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: ProcessStepTranslationUpdateManyWithWhereWithoutProcessStepInput | ProcessStepTranslationUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: ProcessStepTranslationScalarWhereInput | ProcessStepTranslationScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutProcessStepsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput> | ProductTranslationCreateWithoutProcessStepsInput[] | ProductTranslationUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProcessStepsInput | ProductTranslationCreateOrConnectWithoutProcessStepsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProcessStepsInput | ProductTranslationUpsertWithWhereUniqueWithoutProcessStepsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProcessStepsInput | ProductTranslationUpdateWithWhereUniqueWithoutProcessStepsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProcessStepsInput | ProductTranslationUpdateManyWithWhereWithoutProcessStepsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepNestedInput = {
    create?: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput> | ProcessStepTranslationCreateWithoutProcessStepInput[] | ProcessStepTranslationUncheckedCreateWithoutProcessStepInput[]
    connectOrCreate?: ProcessStepTranslationCreateOrConnectWithoutProcessStepInput | ProcessStepTranslationCreateOrConnectWithoutProcessStepInput[]
    upsert?: ProcessStepTranslationUpsertWithWhereUniqueWithoutProcessStepInput | ProcessStepTranslationUpsertWithWhereUniqueWithoutProcessStepInput[]
    createMany?: ProcessStepTranslationCreateManyProcessStepInputEnvelope
    set?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    disconnect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    delete?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    connect?: ProcessStepTranslationWhereUniqueInput | ProcessStepTranslationWhereUniqueInput[]
    update?: ProcessStepTranslationUpdateWithWhereUniqueWithoutProcessStepInput | ProcessStepTranslationUpdateWithWhereUniqueWithoutProcessStepInput[]
    updateMany?: ProcessStepTranslationUpdateManyWithWhereWithoutProcessStepInput | ProcessStepTranslationUpdateManyWithWhereWithoutProcessStepInput[]
    deleteMany?: ProcessStepTranslationScalarWhereInput | ProcessStepTranslationScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProcessStepsNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput> | ProductTranslationCreateWithoutProcessStepsInput[] | ProductTranslationUncheckedCreateWithoutProcessStepsInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProcessStepsInput | ProductTranslationCreateOrConnectWithoutProcessStepsInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProcessStepsInput | ProductTranslationUpsertWithWhereUniqueWithoutProcessStepsInput[]
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProcessStepsInput | ProductTranslationUpdateWithWhereUniqueWithoutProcessStepsInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProcessStepsInput | ProductTranslationUpdateManyWithWhereWithoutProcessStepsInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProcessStepCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ProcessStepCreateWithoutTranslationsInput, ProcessStepUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutTranslationsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type ProcessStepUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutTranslationsInput, ProcessStepUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutTranslationsInput
    upsert?: ProcessStepUpsertWithoutTranslationsInput
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutTranslationsInput, ProcessStepUpdateWithoutTranslationsInput>, ProcessStepUncheckedUpdateWithoutTranslationsInput>
  }

  export type CTATranslationCreateNestedManyWithoutCtaInput = {
    create?: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput> | CTATranslationCreateWithoutCtaInput[] | CTATranslationUncheckedCreateWithoutCtaInput[]
    connectOrCreate?: CTATranslationCreateOrConnectWithoutCtaInput | CTATranslationCreateOrConnectWithoutCtaInput[]
    createMany?: CTATranslationCreateManyCtaInputEnvelope
    connect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
  }

  export type CTATranslationUncheckedCreateNestedManyWithoutCtaInput = {
    create?: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput> | CTATranslationCreateWithoutCtaInput[] | CTATranslationUncheckedCreateWithoutCtaInput[]
    connectOrCreate?: CTATranslationCreateOrConnectWithoutCtaInput | CTATranslationCreateOrConnectWithoutCtaInput[]
    createMany?: CTATranslationCreateManyCtaInputEnvelope
    connect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
  }

  export type CTATranslationUpdateManyWithoutCtaNestedInput = {
    create?: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput> | CTATranslationCreateWithoutCtaInput[] | CTATranslationUncheckedCreateWithoutCtaInput[]
    connectOrCreate?: CTATranslationCreateOrConnectWithoutCtaInput | CTATranslationCreateOrConnectWithoutCtaInput[]
    upsert?: CTATranslationUpsertWithWhereUniqueWithoutCtaInput | CTATranslationUpsertWithWhereUniqueWithoutCtaInput[]
    createMany?: CTATranslationCreateManyCtaInputEnvelope
    set?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    disconnect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    delete?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    connect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    update?: CTATranslationUpdateWithWhereUniqueWithoutCtaInput | CTATranslationUpdateWithWhereUniqueWithoutCtaInput[]
    updateMany?: CTATranslationUpdateManyWithWhereWithoutCtaInput | CTATranslationUpdateManyWithWhereWithoutCtaInput[]
    deleteMany?: CTATranslationScalarWhereInput | CTATranslationScalarWhereInput[]
  }

  export type CTATranslationUncheckedUpdateManyWithoutCtaNestedInput = {
    create?: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput> | CTATranslationCreateWithoutCtaInput[] | CTATranslationUncheckedCreateWithoutCtaInput[]
    connectOrCreate?: CTATranslationCreateOrConnectWithoutCtaInput | CTATranslationCreateOrConnectWithoutCtaInput[]
    upsert?: CTATranslationUpsertWithWhereUniqueWithoutCtaInput | CTATranslationUpsertWithWhereUniqueWithoutCtaInput[]
    createMany?: CTATranslationCreateManyCtaInputEnvelope
    set?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    disconnect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    delete?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    connect?: CTATranslationWhereUniqueInput | CTATranslationWhereUniqueInput[]
    update?: CTATranslationUpdateWithWhereUniqueWithoutCtaInput | CTATranslationUpdateWithWhereUniqueWithoutCtaInput[]
    updateMany?: CTATranslationUpdateManyWithWhereWithoutCtaInput | CTATranslationUpdateManyWithWhereWithoutCtaInput[]
    deleteMany?: CTATranslationScalarWhereInput | CTATranslationScalarWhereInput[]
  }

  export type CTACreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CTACreateWithoutTranslationsInput, CTAUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CTACreateOrConnectWithoutTranslationsInput
    connect?: CTAWhereUniqueInput
  }

  export type CTAUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CTACreateWithoutTranslationsInput, CTAUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CTACreateOrConnectWithoutTranslationsInput
    upsert?: CTAUpsertWithoutTranslationsInput
    connect?: CTAWhereUniqueInput
    update?: XOR<XOR<CTAUpdateToOneWithWhereWithoutTranslationsInput, CTAUpdateWithoutTranslationsInput>, CTAUncheckedUpdateWithoutTranslationsInput>
  }

  export type ApiKeyCreateNestedOneWithoutTranslationTasksInput = {
    create?: XOR<ApiKeyCreateWithoutTranslationTasksInput, ApiKeyUncheckedCreateWithoutTranslationTasksInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTranslationTasksInput
    connect?: ApiKeyWhereUniqueInput
  }

  export type ApiKeyUpdateOneWithoutTranslationTasksNestedInput = {
    create?: XOR<ApiKeyCreateWithoutTranslationTasksInput, ApiKeyUncheckedCreateWithoutTranslationTasksInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTranslationTasksInput
    upsert?: ApiKeyUpsertWithoutTranslationTasksInput
    disconnect?: ApiKeyWhereInput | boolean
    delete?: ApiKeyWhereInput | boolean
    connect?: ApiKeyWhereUniqueInput
    update?: XOR<XOR<ApiKeyUpdateToOneWithWhereWithoutTranslationTasksInput, ApiKeyUpdateWithoutTranslationTasksInput>, ApiKeyUncheckedUpdateWithoutTranslationTasksInput>
  }

  export type ApiKeyUsageCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput> | AuditLogCreateWithoutApiKeyInput[] | AuditLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiKeyInput | AuditLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: AuditLogCreateManyApiKeyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TranslationTaskCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput> | TranslationTaskCreateWithoutApiKeyInput[] | TranslationTaskUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: TranslationTaskCreateOrConnectWithoutApiKeyInput | TranslationTaskCreateOrConnectWithoutApiKeyInput[]
    createMany?: TranslationTaskCreateManyApiKeyInputEnvelope
    connect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
  }

  export type ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput> | AuditLogCreateWithoutApiKeyInput[] | AuditLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiKeyInput | AuditLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: AuditLogCreateManyApiKeyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TranslationTaskUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput> | TranslationTaskCreateWithoutApiKeyInput[] | TranslationTaskUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: TranslationTaskCreateOrConnectWithoutApiKeyInput | TranslationTaskCreateOrConnectWithoutApiKeyInput[]
    createMany?: TranslationTaskCreateManyApiKeyInputEnvelope
    connect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
  }

  export type ApiKeyUsageUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    disconnect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    delete?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    update?: ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput> | AuditLogCreateWithoutApiKeyInput[] | AuditLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiKeyInput | AuditLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApiKeyInput | AuditLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: AuditLogCreateManyApiKeyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApiKeyInput | AuditLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApiKeyInput | AuditLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TranslationTaskUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput> | TranslationTaskCreateWithoutApiKeyInput[] | TranslationTaskUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: TranslationTaskCreateOrConnectWithoutApiKeyInput | TranslationTaskCreateOrConnectWithoutApiKeyInput[]
    upsert?: TranslationTaskUpsertWithWhereUniqueWithoutApiKeyInput | TranslationTaskUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: TranslationTaskCreateManyApiKeyInputEnvelope
    set?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    disconnect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    delete?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    connect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    update?: TranslationTaskUpdateWithWhereUniqueWithoutApiKeyInput | TranslationTaskUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: TranslationTaskUpdateManyWithWhereWithoutApiKeyInput | TranslationTaskUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: TranslationTaskScalarWhereInput | TranslationTaskScalarWhereInput[]
  }

  export type ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput> | ApiKeyUsageCreateWithoutApiKeyInput[] | ApiKeyUsageUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: ApiKeyUsageCreateOrConnectWithoutApiKeyInput | ApiKeyUsageCreateOrConnectWithoutApiKeyInput[]
    upsert?: ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: ApiKeyUsageCreateManyApiKeyInputEnvelope
    set?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    disconnect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    delete?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    connect?: ApiKeyUsageWhereUniqueInput | ApiKeyUsageWhereUniqueInput[]
    update?: ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput | ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput | ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput> | AuditLogCreateWithoutApiKeyInput[] | AuditLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiKeyInput | AuditLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApiKeyInput | AuditLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: AuditLogCreateManyApiKeyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApiKeyInput | AuditLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApiKeyInput | AuditLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TranslationTaskUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput> | TranslationTaskCreateWithoutApiKeyInput[] | TranslationTaskUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: TranslationTaskCreateOrConnectWithoutApiKeyInput | TranslationTaskCreateOrConnectWithoutApiKeyInput[]
    upsert?: TranslationTaskUpsertWithWhereUniqueWithoutApiKeyInput | TranslationTaskUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: TranslationTaskCreateManyApiKeyInputEnvelope
    set?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    disconnect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    delete?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    connect?: TranslationTaskWhereUniqueInput | TranslationTaskWhereUniqueInput[]
    update?: TranslationTaskUpdateWithWhereUniqueWithoutApiKeyInput | TranslationTaskUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: TranslationTaskUpdateManyWithWhereWithoutApiKeyInput | TranslationTaskUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: TranslationTaskScalarWhereInput | TranslationTaskScalarWhereInput[]
  }

  export type ApiKeyCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageLogsInput
    connect?: ApiKeyWhereUniqueInput
  }

  export type ApiKeyUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageLogsInput
    upsert?: ApiKeyUpsertWithoutUsageLogsInput
    connect?: ApiKeyWhereUniqueInput
    update?: XOR<XOR<ApiKeyUpdateToOneWithWhereWithoutUsageLogsInput, ApiKeyUpdateWithoutUsageLogsInput>, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type AuditLogCreateNestedManyWithoutApiConfigInput = {
    create?: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput> | AuditLogCreateWithoutApiConfigInput[] | AuditLogUncheckedCreateWithoutApiConfigInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiConfigInput | AuditLogCreateOrConnectWithoutApiConfigInput[]
    createMany?: AuditLogCreateManyApiConfigInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutApiConfigInput = {
    create?: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput> | AuditLogCreateWithoutApiConfigInput[] | AuditLogUncheckedCreateWithoutApiConfigInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiConfigInput | AuditLogCreateOrConnectWithoutApiConfigInput[]
    createMany?: AuditLogCreateManyApiConfigInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUpdateManyWithoutApiConfigNestedInput = {
    create?: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput> | AuditLogCreateWithoutApiConfigInput[] | AuditLogUncheckedCreateWithoutApiConfigInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiConfigInput | AuditLogCreateOrConnectWithoutApiConfigInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApiConfigInput | AuditLogUpsertWithWhereUniqueWithoutApiConfigInput[]
    createMany?: AuditLogCreateManyApiConfigInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApiConfigInput | AuditLogUpdateWithWhereUniqueWithoutApiConfigInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApiConfigInput | AuditLogUpdateManyWithWhereWithoutApiConfigInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutApiConfigNestedInput = {
    create?: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput> | AuditLogCreateWithoutApiConfigInput[] | AuditLogUncheckedCreateWithoutApiConfigInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApiConfigInput | AuditLogCreateOrConnectWithoutApiConfigInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApiConfigInput | AuditLogUpsertWithWhereUniqueWithoutApiConfigInput[]
    createMany?: AuditLogCreateManyApiConfigInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApiConfigInput | AuditLogUpdateWithWhereUniqueWithoutApiConfigInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApiConfigInput | AuditLogUpdateManyWithWhereWithoutApiConfigInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ApiKeyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ApiKeyCreateWithoutAuditLogsInput, ApiKeyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutAuditLogsInput
    connect?: ApiKeyWhereUniqueInput
  }

  export type ApiConfigCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ApiConfigCreateWithoutAuditLogsInput, ApiConfigUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ApiConfigCreateOrConnectWithoutAuditLogsInput
    connect?: ApiConfigWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ApiKeyUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ApiKeyCreateWithoutAuditLogsInput, ApiKeyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutAuditLogsInput
    upsert?: ApiKeyUpsertWithoutAuditLogsInput
    disconnect?: ApiKeyWhereInput | boolean
    delete?: ApiKeyWhereInput | boolean
    connect?: ApiKeyWhereUniqueInput
    update?: XOR<XOR<ApiKeyUpdateToOneWithWhereWithoutAuditLogsInput, ApiKeyUpdateWithoutAuditLogsInput>, ApiKeyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ApiConfigUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ApiConfigCreateWithoutAuditLogsInput, ApiConfigUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ApiConfigCreateOrConnectWithoutAuditLogsInput
    upsert?: ApiConfigUpsertWithoutAuditLogsInput
    disconnect?: ApiConfigWhereInput | boolean
    delete?: ApiConfigWhereInput | boolean
    connect?: ApiConfigWhereUniqueInput
    update?: XOR<XOR<ApiConfigUpdateToOneWithWhereWithoutAuditLogsInput, ApiConfigUpdateWithoutAuditLogsInput>, ApiConfigUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLanguageCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.LanguageCode | EnumLanguageCodeFieldRefInput<$PrismaModel>
    in?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageCodeFilter<$PrismaModel> | $Enums.LanguageCode
  }

  export type NestedEnumLanguageCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LanguageCode | EnumLanguageCodeFieldRefInput<$PrismaModel>
    in?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LanguageCode[] | ListEnumLanguageCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageCodeWithAggregatesFilter<$PrismaModel> | $Enums.LanguageCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageCodeFilter<$PrismaModel>
    _max?: NestedEnumLanguageCodeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMachineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MachineType | EnumMachineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMachineTypeFilter<$PrismaModel> | $Enums.MachineType
  }

  export type NestedEnumMachineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MachineType | EnumMachineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MachineType[] | ListEnumMachineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMachineTypeWithAggregatesFilter<$PrismaModel> | $Enums.MachineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMachineTypeFilter<$PrismaModel>
    _max?: NestedEnumMachineTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
    apiKey?: ApiKeyCreateNestedOneWithoutAuditLogsInput
    apiConfig?: ApiConfigCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    apiKeyId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    apiKeyId?: IntNullableFilter<"AuditLog"> | number | null
    apiConfigId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ProductCreateWithoutCategoriesInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryTranslationCreateWithoutCategoryInput = {
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    products?: ProductTranslationCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryTranslationUncheckedCreateWithoutCategoryInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    products?: ProductTranslationUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryTranslationCreateOrConnectWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationCreateManyCategoryInputEnvelope = {
    data: CategoryTranslationCreateManyCategoryInput | CategoryTranslationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    model_name_en?: StringFilter<"Product"> | string
    product_name?: StringNullableFilter<"Product"> | string | null
    productImage?: StringNullableFilter<"Product"> | string | null
    productImage_Alt?: StringNullableFilter<"Product"> | string | null
    status_en?: StringNullableFilter<"Product"> | string | null
    stars?: IntNullableFilter<"Product"> | number | null
    reviews?: IntNullableFilter<"Product"> | number | null
    productDescription_en?: StringNullableFilter<"Product"> | string | null
    model_description?: StringNullableFilter<"Product"> | string | null
    introduction?: StringNullableFilter<"Product"> | string | null
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryTranslationCreateWithoutCategoryInput, CategoryTranslationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutCategoryInput, CategoryTranslationUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryTranslationScalarWhereInput = {
    AND?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    OR?: CategoryTranslationScalarWhereInput[]
    NOT?: CategoryTranslationScalarWhereInput | CategoryTranslationScalarWhereInput[]
    id?: IntFilter<"CategoryTranslation"> | number
    language?: EnumLanguageCodeFilter<"CategoryTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"CategoryTranslation"> | string
    iconAlt?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryLink?: StringNullableFilter<"CategoryTranslation"> | string | null
    description?: StringNullableFilter<"CategoryTranslation"> | string | null
    categoryId?: IntFilter<"CategoryTranslation"> | number
  }

  export type CategoryCreateWithoutTranslationsInput = {
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutTranslationsInput = {
    id?: number
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutTranslationsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
  }

  export type ProductTranslationCreateWithoutCategoriesInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutCategoriesInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutCategoriesInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryUpsertWithoutTranslationsInput = {
    update: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CategoryCreateWithoutTranslationsInput, CategoryUncheckedCreateWithoutTranslationsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTranslationsInput, CategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryUpdateWithoutTranslationsInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutCategoriesInput, ProductTranslationUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductTranslationCreateWithoutCategoriesInput, ProductTranslationUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutCategoriesInput, ProductTranslationUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProductTranslationScalarWhereInput = {
    AND?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    OR?: ProductTranslationScalarWhereInput[]
    NOT?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    id?: IntFilter<"ProductTranslation"> | number
    language?: EnumLanguageCodeFilter<"ProductTranslation"> | $Enums.LanguageCode
    name?: StringFilter<"ProductTranslation"> | string
    imageAlt?: StringNullableFilter<"ProductTranslation"> | string | null
    status?: StringNullableFilter<"ProductTranslation"> | string | null
    productDescription?: StringNullableFilter<"ProductTranslation"> | string | null
    model_description?: StringNullableFilter<"ProductTranslation"> | string | null
    introduction?: StringNullableFilter<"ProductTranslation"> | string | null
    productId?: IntFilter<"ProductTranslation"> | number
  }

  export type CategoryCreateWithoutProductsInput = {
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    translations?: CategoryTranslationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name_en: string
    category_icon?: string | null
    category_image?: string | null
    category_Alt_en?: string | null
    categoryLink_en?: string | null
    specification_image?: string | null
    specification_image_alt?: string | null
    translations?: CategoryTranslationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type modelSpecificationCreateWithoutProductsInput = {
    title_en: string
    translations?: modelSpecificationTranslationCreateNestedManyWithoutModelSpecInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationUncheckedCreateWithoutProductsInput = {
    id?: number
    title_en: string
    translations?: modelSpecificationTranslationUncheckedCreateNestedManyWithoutModelSpecInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationCreateOrConnectWithoutProductsInput = {
    where: modelSpecificationWhereUniqueInput
    create: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput>
  }

  export type AdvantageCreateWithoutProductsInput = {
    heading_en?: string
    title_en: string
    translations?: AdvantageTranslationCreateNestedManyWithoutAdvantageInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageUncheckedCreateWithoutProductsInput = {
    id?: number
    heading_en?: string
    title_en: string
    translations?: AdvantageTranslationUncheckedCreateNestedManyWithoutAdvantageInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageCreateOrConnectWithoutProductsInput = {
    where: AdvantageWhereUniqueInput
    create: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput>
  }

  export type SpecificationCreateWithoutProductInput = {
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    translations?: SpecificationTranslationCreateNestedManyWithoutSpecificationInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationUncheckedCreateWithoutProductInput = {
    id?: number
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    translations?: SpecificationTranslationUncheckedCreateNestedManyWithoutSpecificationInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationCreateOrConnectWithoutProductInput = {
    where: SpecificationWhereUniqueInput
    create: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput>
  }

  export type SpecificationCreateManyProductInputEnvelope = {
    data: SpecificationCreateManyProductInput | SpecificationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationDataCreateWithoutProductInput = {
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    translations?: ApplicationDataTranslationCreateNestedManyWithoutApplicationDataInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataUncheckedCreateWithoutProductInput = {
    id?: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    translations?: ApplicationDataTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataCreateOrConnectWithoutProductInput = {
    where: ApplicationDataWhereUniqueInput
    create: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput>
  }

  export type ApplicationDataCreateManyProductInputEnvelope = {
    data: ApplicationDataCreateManyProductInput | ApplicationDataCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TechnicalSpecificationCreateWithoutProductInput = {
    feature_en: string
    spec_en: string
    translations?: TechnicalSpecificationTranslationCreateNestedManyWithoutTechnicalSpecificationInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationUncheckedCreateWithoutProductInput = {
    id?: number
    feature_en: string
    spec_en: string
    translations?: TechnicalSpecificationTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationCreateOrConnectWithoutProductInput = {
    where: TechnicalSpecificationWhereUniqueInput
    create: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput>
  }

  export type TechnicalSpecificationCreateManyProductInputEnvelope = {
    data: TechnicalSpecificationCreateManyProductInput | TechnicalSpecificationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RelatedProductCreateWithoutProductInput = {
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    translations?: RelatedProductTranslationCreateNestedManyWithoutRelatedProductInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductUncheckedCreateWithoutProductInput = {
    id?: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedCreateNestedManyWithoutRelatedProductInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductCreateOrConnectWithoutProductInput = {
    where: RelatedProductWhereUniqueInput
    create: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput>
  }

  export type RelatedProductCreateManyProductInputEnvelope = {
    data: RelatedProductCreateManyProductInput | RelatedProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProcessStepCreateWithoutProductInput = {
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    translations?: ProcessStepTranslationCreateNestedManyWithoutProcessStepInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepUncheckedCreateWithoutProductInput = {
    id?: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    translations?: ProcessStepTranslationUncheckedCreateNestedManyWithoutProcessStepInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepCreateOrConnectWithoutProductInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput>
  }

  export type ProcessStepCreateManyProductInputEnvelope = {
    data: ProcessStepCreateManyProductInput | ProcessStepCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutProductInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutProductInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput>
  }

  export type ProductTranslationCreateManyProductInputEnvelope = {
    data: ProductTranslationCreateManyProductInput | ProductTranslationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name_en?: StringFilter<"Category"> | string
    category_icon?: StringNullableFilter<"Category"> | string | null
    category_image?: StringNullableFilter<"Category"> | string | null
    category_Alt_en?: StringNullableFilter<"Category"> | string | null
    categoryLink_en?: StringNullableFilter<"Category"> | string | null
    specification_image?: StringNullableFilter<"Category"> | string | null
    specification_image_alt?: StringNullableFilter<"Category"> | string | null
  }

  export type modelSpecificationUpsertWithWhereUniqueWithoutProductsInput = {
    where: modelSpecificationWhereUniqueInput
    update: XOR<modelSpecificationUpdateWithoutProductsInput, modelSpecificationUncheckedUpdateWithoutProductsInput>
    create: XOR<modelSpecificationCreateWithoutProductsInput, modelSpecificationUncheckedCreateWithoutProductsInput>
  }

  export type modelSpecificationUpdateWithWhereUniqueWithoutProductsInput = {
    where: modelSpecificationWhereUniqueInput
    data: XOR<modelSpecificationUpdateWithoutProductsInput, modelSpecificationUncheckedUpdateWithoutProductsInput>
  }

  export type modelSpecificationUpdateManyWithWhereWithoutProductsInput = {
    where: modelSpecificationScalarWhereInput
    data: XOR<modelSpecificationUpdateManyMutationInput, modelSpecificationUncheckedUpdateManyWithoutProductsInput>
  }

  export type modelSpecificationScalarWhereInput = {
    AND?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
    OR?: modelSpecificationScalarWhereInput[]
    NOT?: modelSpecificationScalarWhereInput | modelSpecificationScalarWhereInput[]
    id?: IntFilter<"modelSpecification"> | number
    title_en?: StringFilter<"modelSpecification"> | string
  }

  export type AdvantageUpsertWithWhereUniqueWithoutProductsInput = {
    where: AdvantageWhereUniqueInput
    update: XOR<AdvantageUpdateWithoutProductsInput, AdvantageUncheckedUpdateWithoutProductsInput>
    create: XOR<AdvantageCreateWithoutProductsInput, AdvantageUncheckedCreateWithoutProductsInput>
  }

  export type AdvantageUpdateWithWhereUniqueWithoutProductsInput = {
    where: AdvantageWhereUniqueInput
    data: XOR<AdvantageUpdateWithoutProductsInput, AdvantageUncheckedUpdateWithoutProductsInput>
  }

  export type AdvantageUpdateManyWithWhereWithoutProductsInput = {
    where: AdvantageScalarWhereInput
    data: XOR<AdvantageUpdateManyMutationInput, AdvantageUncheckedUpdateManyWithoutProductsInput>
  }

  export type AdvantageScalarWhereInput = {
    AND?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
    OR?: AdvantageScalarWhereInput[]
    NOT?: AdvantageScalarWhereInput | AdvantageScalarWhereInput[]
    id?: IntFilter<"Advantage"> | number
    heading_en?: StringFilter<"Advantage"> | string
    title_en?: StringFilter<"Advantage"> | string
  }

  export type SpecificationUpsertWithWhereUniqueWithoutProductInput = {
    where: SpecificationWhereUniqueInput
    update: XOR<SpecificationUpdateWithoutProductInput, SpecificationUncheckedUpdateWithoutProductInput>
    create: XOR<SpecificationCreateWithoutProductInput, SpecificationUncheckedCreateWithoutProductInput>
  }

  export type SpecificationUpdateWithWhereUniqueWithoutProductInput = {
    where: SpecificationWhereUniqueInput
    data: XOR<SpecificationUpdateWithoutProductInput, SpecificationUncheckedUpdateWithoutProductInput>
  }

  export type SpecificationUpdateManyWithWhereWithoutProductInput = {
    where: SpecificationScalarWhereInput
    data: XOR<SpecificationUpdateManyMutationInput, SpecificationUncheckedUpdateManyWithoutProductInput>
  }

  export type SpecificationScalarWhereInput = {
    AND?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
    OR?: SpecificationScalarWhereInput[]
    NOT?: SpecificationScalarWhereInput | SpecificationScalarWhereInput[]
    id?: IntFilter<"Specification"> | number
    categoryId?: IntNullableFilter<"Specification"> | number | null
    productId?: IntNullableFilter<"Specification"> | number | null
    speed_en?: StringNullableFilter<"Specification"> | string | null
    paperSpecification_en?: StringNullableFilter<"Specification"> | string | null
    sizeRange_en?: StringNullableFilter<"Specification"> | string | null
  }

  export type ApplicationDataUpsertWithWhereUniqueWithoutProductInput = {
    where: ApplicationDataWhereUniqueInput
    update: XOR<ApplicationDataUpdateWithoutProductInput, ApplicationDataUncheckedUpdateWithoutProductInput>
    create: XOR<ApplicationDataCreateWithoutProductInput, ApplicationDataUncheckedCreateWithoutProductInput>
  }

  export type ApplicationDataUpdateWithWhereUniqueWithoutProductInput = {
    where: ApplicationDataWhereUniqueInput
    data: XOR<ApplicationDataUpdateWithoutProductInput, ApplicationDataUncheckedUpdateWithoutProductInput>
  }

  export type ApplicationDataUpdateManyWithWhereWithoutProductInput = {
    where: ApplicationDataScalarWhereInput
    data: XOR<ApplicationDataUpdateManyMutationInput, ApplicationDataUncheckedUpdateManyWithoutProductInput>
  }

  export type ApplicationDataScalarWhereInput = {
    AND?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
    OR?: ApplicationDataScalarWhereInput[]
    NOT?: ApplicationDataScalarWhereInput | ApplicationDataScalarWhereInput[]
    id?: IntFilter<"ApplicationData"> | number
    productId?: IntFilter<"ApplicationData"> | number
    title_en?: StringFilter<"ApplicationData"> | string
    src?: StringNullableFilter<"ApplicationData"> | string | null
    src_alt_en?: StringNullableFilter<"ApplicationData"> | string | null
  }

  export type TechnicalSpecificationUpsertWithWhereUniqueWithoutProductInput = {
    where: TechnicalSpecificationWhereUniqueInput
    update: XOR<TechnicalSpecificationUpdateWithoutProductInput, TechnicalSpecificationUncheckedUpdateWithoutProductInput>
    create: XOR<TechnicalSpecificationCreateWithoutProductInput, TechnicalSpecificationUncheckedCreateWithoutProductInput>
  }

  export type TechnicalSpecificationUpdateWithWhereUniqueWithoutProductInput = {
    where: TechnicalSpecificationWhereUniqueInput
    data: XOR<TechnicalSpecificationUpdateWithoutProductInput, TechnicalSpecificationUncheckedUpdateWithoutProductInput>
  }

  export type TechnicalSpecificationUpdateManyWithWhereWithoutProductInput = {
    where: TechnicalSpecificationScalarWhereInput
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyWithoutProductInput>
  }

  export type TechnicalSpecificationScalarWhereInput = {
    AND?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
    OR?: TechnicalSpecificationScalarWhereInput[]
    NOT?: TechnicalSpecificationScalarWhereInput | TechnicalSpecificationScalarWhereInput[]
    id?: IntFilter<"TechnicalSpecification"> | number
    productId?: IntFilter<"TechnicalSpecification"> | number
    feature_en?: StringFilter<"TechnicalSpecification"> | string
    spec_en?: StringFilter<"TechnicalSpecification"> | string
  }

  export type RelatedProductUpsertWithWhereUniqueWithoutProductInput = {
    where: RelatedProductWhereUniqueInput
    update: XOR<RelatedProductUpdateWithoutProductInput, RelatedProductUncheckedUpdateWithoutProductInput>
    create: XOR<RelatedProductCreateWithoutProductInput, RelatedProductUncheckedCreateWithoutProductInput>
  }

  export type RelatedProductUpdateWithWhereUniqueWithoutProductInput = {
    where: RelatedProductWhereUniqueInput
    data: XOR<RelatedProductUpdateWithoutProductInput, RelatedProductUncheckedUpdateWithoutProductInput>
  }

  export type RelatedProductUpdateManyWithWhereWithoutProductInput = {
    where: RelatedProductScalarWhereInput
    data: XOR<RelatedProductUpdateManyMutationInput, RelatedProductUncheckedUpdateManyWithoutProductInput>
  }

  export type RelatedProductScalarWhereInput = {
    AND?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
    OR?: RelatedProductScalarWhereInput[]
    NOT?: RelatedProductScalarWhereInput | RelatedProductScalarWhereInput[]
    id?: IntFilter<"RelatedProduct"> | number
    productId?: IntFilter<"RelatedProduct"> | number
    title_en?: StringFilter<"RelatedProduct"> | string
    description_en?: StringNullableFilter<"RelatedProduct"> | string | null
    image?: StringNullableFilter<"RelatedProduct"> | string | null
    imageAlt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    category_icon?: StringNullableFilter<"RelatedProduct"> | string | null
    category_Alt_en?: StringNullableFilter<"RelatedProduct"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProduct"> | $Enums.MachineType
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutProductInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutProductInput, ProcessStepUncheckedUpdateWithoutProductInput>
    create: XOR<ProcessStepCreateWithoutProductInput, ProcessStepUncheckedCreateWithoutProductInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutProductInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutProductInput, ProcessStepUncheckedUpdateWithoutProductInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutProductInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutProductInput>
  }

  export type ProcessStepScalarWhereInput = {
    AND?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    OR?: ProcessStepScalarWhereInput[]
    NOT?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    id?: IntFilter<"ProcessStep"> | number
    productId?: IntFilter<"ProcessStep"> | number
    title_en?: StringFilter<"ProcessStep"> | string
    description_en?: StringFilter<"ProcessStep"> | string
    process_image?: StringNullableFilter<"ProcessStep"> | string | null
    process_image_alt?: StringNullableFilter<"ProcessStep"> | string | null
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutProductInput, ProductTranslationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutProductInput, ProductTranslationUncheckedUpdateWithoutProductInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutProductInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutTranslationsInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTranslationsInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTranslationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
  }

  export type CategoryTranslationCreateWithoutProductsInput = {
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    category: CategoryCreateNestedOneWithoutTranslationsInput
  }

  export type CategoryTranslationUncheckedCreateWithoutProductsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
    categoryId: number
  }

  export type CategoryTranslationCreateOrConnectWithoutProductsInput = {
    where: CategoryTranslationWhereUniqueInput
    create: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput>
  }

  export type AdvantageCreateWithoutProductTranslationsInput = {
    heading_en?: string
    title_en: string
    products?: ProductCreateNestedManyWithoutAdvantagesInput
    translations?: AdvantageTranslationCreateNestedManyWithoutAdvantageInput
  }

  export type AdvantageUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    heading_en?: string
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutAdvantagesInput
    translations?: AdvantageTranslationUncheckedCreateNestedManyWithoutAdvantageInput
  }

  export type AdvantageCreateOrConnectWithoutProductTranslationsInput = {
    where: AdvantageWhereUniqueInput
    create: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput>
  }

  export type SpecificationCreateWithoutProductTranslationsInput = {
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    product?: ProductCreateNestedOneWithoutSpecificationsInput
    translations?: SpecificationTranslationCreateNestedManyWithoutSpecificationInput
  }

  export type SpecificationUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    categoryId?: number | null
    productId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    translations?: SpecificationTranslationUncheckedCreateNestedManyWithoutSpecificationInput
  }

  export type SpecificationCreateOrConnectWithoutProductTranslationsInput = {
    where: SpecificationWhereUniqueInput
    create: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type ApplicationDataCreateWithoutProductTranslationsInput = {
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    product: ProductCreateNestedOneWithoutApplicationDataInput
    translations?: ApplicationDataTranslationCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    translations?: ApplicationDataTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataCreateOrConnectWithoutProductTranslationsInput = {
    where: ApplicationDataWhereUniqueInput
    create: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput>
  }

  export type TechnicalSpecificationCreateWithoutProductTranslationsInput = {
    feature_en: string
    spec_en: string
    product: ProductCreateNestedOneWithoutTechnicalSpecificationsInput
    translations?: TechnicalSpecificationTranslationCreateNestedManyWithoutTechnicalSpecificationInput
  }

  export type TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    productId: number
    feature_en: string
    spec_en: string
    translations?: TechnicalSpecificationTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationInput
  }

  export type TechnicalSpecificationCreateOrConnectWithoutProductTranslationsInput = {
    where: TechnicalSpecificationWhereUniqueInput
    create: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type RelatedProductCreateWithoutProductTranslationsInput = {
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    product: ProductCreateNestedOneWithoutRelatedProductsInput
    translations?: RelatedProductTranslationCreateNestedManyWithoutRelatedProductInput
  }

  export type RelatedProductUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedCreateNestedManyWithoutRelatedProductInput
  }

  export type RelatedProductCreateOrConnectWithoutProductTranslationsInput = {
    where: RelatedProductWhereUniqueInput
    create: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput>
  }

  export type ProcessStepCreateWithoutProductTranslationsInput = {
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    product: ProductCreateNestedOneWithoutProcessStepsInput
    translations?: ProcessStepTranslationCreateNestedManyWithoutProcessStepInput
  }

  export type ProcessStepUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    translations?: ProcessStepTranslationUncheckedCreateNestedManyWithoutProcessStepInput
  }

  export type ProcessStepCreateOrConnectWithoutProductTranslationsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput>
  }

  export type modelSpecificationCreateWithoutProductTranslationsInput = {
    title_en: string
    products?: ProductCreateNestedManyWithoutModelSpecificationInput
    translations?: modelSpecificationTranslationCreateNestedManyWithoutModelSpecInput
  }

  export type modelSpecificationUncheckedCreateWithoutProductTranslationsInput = {
    id?: number
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutModelSpecificationInput
    translations?: modelSpecificationTranslationUncheckedCreateNestedManyWithoutModelSpecInput
  }

  export type modelSpecificationCreateOrConnectWithoutProductTranslationsInput = {
    where: modelSpecificationWhereUniqueInput
    create: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type ProductUpsertWithoutTranslationsInput = {
    update: XOR<ProductUpdateWithoutTranslationsInput, ProductUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTranslationsInput, ProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductUpdateWithoutTranslationsInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryTranslationUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryTranslationWhereUniqueInput
    update: XOR<CategoryTranslationUpdateWithoutProductsInput, CategoryTranslationUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryTranslationCreateWithoutProductsInput, CategoryTranslationUncheckedCreateWithoutProductsInput>
  }

  export type CategoryTranslationUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryTranslationWhereUniqueInput
    data: XOR<CategoryTranslationUpdateWithoutProductsInput, CategoryTranslationUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryTranslationUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryTranslationScalarWhereInput
    data: XOR<CategoryTranslationUpdateManyMutationInput, CategoryTranslationUncheckedUpdateManyWithoutProductsInput>
  }

  export type AdvantageUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: AdvantageWhereUniqueInput
    update: XOR<AdvantageUpdateWithoutProductTranslationsInput, AdvantageUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<AdvantageCreateWithoutProductTranslationsInput, AdvantageUncheckedCreateWithoutProductTranslationsInput>
  }

  export type AdvantageUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: AdvantageWhereUniqueInput
    data: XOR<AdvantageUpdateWithoutProductTranslationsInput, AdvantageUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type AdvantageUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: AdvantageScalarWhereInput
    data: XOR<AdvantageUpdateManyMutationInput, AdvantageUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type SpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: SpecificationWhereUniqueInput
    update: XOR<SpecificationUpdateWithoutProductTranslationsInput, SpecificationUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<SpecificationCreateWithoutProductTranslationsInput, SpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type SpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: SpecificationWhereUniqueInput
    data: XOR<SpecificationUpdateWithoutProductTranslationsInput, SpecificationUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type SpecificationUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: SpecificationScalarWhereInput
    data: XOR<SpecificationUpdateManyMutationInput, SpecificationUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type ApplicationDataUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: ApplicationDataWhereUniqueInput
    update: XOR<ApplicationDataUpdateWithoutProductTranslationsInput, ApplicationDataUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<ApplicationDataCreateWithoutProductTranslationsInput, ApplicationDataUncheckedCreateWithoutProductTranslationsInput>
  }

  export type ApplicationDataUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: ApplicationDataWhereUniqueInput
    data: XOR<ApplicationDataUpdateWithoutProductTranslationsInput, ApplicationDataUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type ApplicationDataUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: ApplicationDataScalarWhereInput
    data: XOR<ApplicationDataUpdateManyMutationInput, ApplicationDataUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type TechnicalSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: TechnicalSpecificationWhereUniqueInput
    update: XOR<TechnicalSpecificationUpdateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<TechnicalSpecificationCreateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type TechnicalSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: TechnicalSpecificationWhereUniqueInput
    data: XOR<TechnicalSpecificationUpdateWithoutProductTranslationsInput, TechnicalSpecificationUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type TechnicalSpecificationUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: TechnicalSpecificationScalarWhereInput
    data: XOR<TechnicalSpecificationUpdateManyMutationInput, TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type RelatedProductUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: RelatedProductWhereUniqueInput
    update: XOR<RelatedProductUpdateWithoutProductTranslationsInput, RelatedProductUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<RelatedProductCreateWithoutProductTranslationsInput, RelatedProductUncheckedCreateWithoutProductTranslationsInput>
  }

  export type RelatedProductUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: RelatedProductWhereUniqueInput
    data: XOR<RelatedProductUpdateWithoutProductTranslationsInput, RelatedProductUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type RelatedProductUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: RelatedProductScalarWhereInput
    data: XOR<RelatedProductUpdateManyMutationInput, RelatedProductUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutProductTranslationsInput, ProcessStepUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<ProcessStepCreateWithoutProductTranslationsInput, ProcessStepUncheckedCreateWithoutProductTranslationsInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutProductTranslationsInput, ProcessStepUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type modelSpecificationUpsertWithWhereUniqueWithoutProductTranslationsInput = {
    where: modelSpecificationWhereUniqueInput
    update: XOR<modelSpecificationUpdateWithoutProductTranslationsInput, modelSpecificationUncheckedUpdateWithoutProductTranslationsInput>
    create: XOR<modelSpecificationCreateWithoutProductTranslationsInput, modelSpecificationUncheckedCreateWithoutProductTranslationsInput>
  }

  export type modelSpecificationUpdateWithWhereUniqueWithoutProductTranslationsInput = {
    where: modelSpecificationWhereUniqueInput
    data: XOR<modelSpecificationUpdateWithoutProductTranslationsInput, modelSpecificationUncheckedUpdateWithoutProductTranslationsInput>
  }

  export type modelSpecificationUpdateManyWithWhereWithoutProductTranslationsInput = {
    where: modelSpecificationScalarWhereInput
    data: XOR<modelSpecificationUpdateManyMutationInput, modelSpecificationUncheckedUpdateManyWithoutProductTranslationsInput>
  }

  export type ProductCreateWithoutModelSpecificationInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutModelSpecificationInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutModelSpecificationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput>
  }

  export type modelSpecificationTranslationCreateWithoutModelSpecInput = {
    language: $Enums.LanguageCode
    title: string
  }

  export type modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
  }

  export type modelSpecificationTranslationCreateOrConnectWithoutModelSpecInput = {
    where: modelSpecificationTranslationWhereUniqueInput
    create: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput>
  }

  export type modelSpecificationTranslationCreateManyModelSpecInputEnvelope = {
    data: modelSpecificationTranslationCreateManyModelSpecInput | modelSpecificationTranslationCreateManyModelSpecInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutModelSpecificationsInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutModelSpecificationsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutModelSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutModelSpecificationInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutModelSpecificationInput, ProductUncheckedUpdateWithoutModelSpecificationInput>
    create: XOR<ProductCreateWithoutModelSpecificationInput, ProductUncheckedCreateWithoutModelSpecificationInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutModelSpecificationInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutModelSpecificationInput, ProductUncheckedUpdateWithoutModelSpecificationInput>
  }

  export type ProductUpdateManyWithWhereWithoutModelSpecificationInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutModelSpecificationInput>
  }

  export type modelSpecificationTranslationUpsertWithWhereUniqueWithoutModelSpecInput = {
    where: modelSpecificationTranslationWhereUniqueInput
    update: XOR<modelSpecificationTranslationUpdateWithoutModelSpecInput, modelSpecificationTranslationUncheckedUpdateWithoutModelSpecInput>
    create: XOR<modelSpecificationTranslationCreateWithoutModelSpecInput, modelSpecificationTranslationUncheckedCreateWithoutModelSpecInput>
  }

  export type modelSpecificationTranslationUpdateWithWhereUniqueWithoutModelSpecInput = {
    where: modelSpecificationTranslationWhereUniqueInput
    data: XOR<modelSpecificationTranslationUpdateWithoutModelSpecInput, modelSpecificationTranslationUncheckedUpdateWithoutModelSpecInput>
  }

  export type modelSpecificationTranslationUpdateManyWithWhereWithoutModelSpecInput = {
    where: modelSpecificationTranslationScalarWhereInput
    data: XOR<modelSpecificationTranslationUpdateManyMutationInput, modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecInput>
  }

  export type modelSpecificationTranslationScalarWhereInput = {
    AND?: modelSpecificationTranslationScalarWhereInput | modelSpecificationTranslationScalarWhereInput[]
    OR?: modelSpecificationTranslationScalarWhereInput[]
    NOT?: modelSpecificationTranslationScalarWhereInput | modelSpecificationTranslationScalarWhereInput[]
    id?: IntFilter<"modelSpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"modelSpecificationTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"modelSpecificationTranslation"> | string
    modelspecId?: IntFilter<"modelSpecificationTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutModelSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutModelSpecificationsInput, ProductTranslationUncheckedUpdateWithoutModelSpecificationsInput>
    create: XOR<ProductTranslationCreateWithoutModelSpecificationsInput, ProductTranslationUncheckedCreateWithoutModelSpecificationsInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutModelSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutModelSpecificationsInput, ProductTranslationUncheckedUpdateWithoutModelSpecificationsInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutModelSpecificationsInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsInput>
  }

  export type modelSpecificationCreateWithoutTranslationsInput = {
    title_en: string
    products?: ProductCreateNestedManyWithoutModelSpecificationInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationUncheckedCreateWithoutTranslationsInput = {
    id?: number
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutModelSpecificationInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutModelSpecificationsInput
  }

  export type modelSpecificationCreateOrConnectWithoutTranslationsInput = {
    where: modelSpecificationWhereUniqueInput
    create: XOR<modelSpecificationCreateWithoutTranslationsInput, modelSpecificationUncheckedCreateWithoutTranslationsInput>
  }

  export type modelSpecificationUpsertWithoutTranslationsInput = {
    update: XOR<modelSpecificationUpdateWithoutTranslationsInput, modelSpecificationUncheckedUpdateWithoutTranslationsInput>
    create: XOR<modelSpecificationCreateWithoutTranslationsInput, modelSpecificationUncheckedCreateWithoutTranslationsInput>
    where?: modelSpecificationWhereInput
  }

  export type modelSpecificationUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: modelSpecificationWhereInput
    data: XOR<modelSpecificationUpdateWithoutTranslationsInput, modelSpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type modelSpecificationUpdateWithoutTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutModelSpecificationNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type modelSpecificationUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutModelSpecificationNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type ProductCreateWithoutAdvantagesInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdvantagesInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdvantagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput>
  }

  export type AdvantageTranslationCreateWithoutAdvantageInput = {
    language: $Enums.LanguageCode
    heading?: string
    title: string
  }

  export type AdvantageTranslationUncheckedCreateWithoutAdvantageInput = {
    id?: number
    language: $Enums.LanguageCode
    heading?: string
    title: string
  }

  export type AdvantageTranslationCreateOrConnectWithoutAdvantageInput = {
    where: AdvantageTranslationWhereUniqueInput
    create: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput>
  }

  export type AdvantageTranslationCreateManyAdvantageInputEnvelope = {
    data: AdvantageTranslationCreateManyAdvantageInput | AdvantageTranslationCreateManyAdvantageInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutAdvantagesInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutAdvantagesInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutAdvantagesInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutAdvantagesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutAdvantagesInput, ProductUncheckedUpdateWithoutAdvantagesInput>
    create: XOR<ProductCreateWithoutAdvantagesInput, ProductUncheckedCreateWithoutAdvantagesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutAdvantagesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutAdvantagesInput, ProductUncheckedUpdateWithoutAdvantagesInput>
  }

  export type ProductUpdateManyWithWhereWithoutAdvantagesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutAdvantagesInput>
  }

  export type AdvantageTranslationUpsertWithWhereUniqueWithoutAdvantageInput = {
    where: AdvantageTranslationWhereUniqueInput
    update: XOR<AdvantageTranslationUpdateWithoutAdvantageInput, AdvantageTranslationUncheckedUpdateWithoutAdvantageInput>
    create: XOR<AdvantageTranslationCreateWithoutAdvantageInput, AdvantageTranslationUncheckedCreateWithoutAdvantageInput>
  }

  export type AdvantageTranslationUpdateWithWhereUniqueWithoutAdvantageInput = {
    where: AdvantageTranslationWhereUniqueInput
    data: XOR<AdvantageTranslationUpdateWithoutAdvantageInput, AdvantageTranslationUncheckedUpdateWithoutAdvantageInput>
  }

  export type AdvantageTranslationUpdateManyWithWhereWithoutAdvantageInput = {
    where: AdvantageTranslationScalarWhereInput
    data: XOR<AdvantageTranslationUpdateManyMutationInput, AdvantageTranslationUncheckedUpdateManyWithoutAdvantageInput>
  }

  export type AdvantageTranslationScalarWhereInput = {
    AND?: AdvantageTranslationScalarWhereInput | AdvantageTranslationScalarWhereInput[]
    OR?: AdvantageTranslationScalarWhereInput[]
    NOT?: AdvantageTranslationScalarWhereInput | AdvantageTranslationScalarWhereInput[]
    id?: IntFilter<"AdvantageTranslation"> | number
    language?: EnumLanguageCodeFilter<"AdvantageTranslation"> | $Enums.LanguageCode
    heading?: StringFilter<"AdvantageTranslation"> | string
    title?: StringFilter<"AdvantageTranslation"> | string
    advantageId?: IntFilter<"AdvantageTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutAdvantagesInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutAdvantagesInput, ProductTranslationUncheckedUpdateWithoutAdvantagesInput>
    create: XOR<ProductTranslationCreateWithoutAdvantagesInput, ProductTranslationUncheckedCreateWithoutAdvantagesInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutAdvantagesInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutAdvantagesInput, ProductTranslationUncheckedUpdateWithoutAdvantagesInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutAdvantagesInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutAdvantagesInput>
  }

  export type AdvantageCreateWithoutTranslationsInput = {
    heading_en?: string
    title_en: string
    products?: ProductCreateNestedManyWithoutAdvantagesInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageUncheckedCreateWithoutTranslationsInput = {
    id?: number
    heading_en?: string
    title_en: string
    products?: ProductUncheckedCreateNestedManyWithoutAdvantagesInput
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type AdvantageCreateOrConnectWithoutTranslationsInput = {
    where: AdvantageWhereUniqueInput
    create: XOR<AdvantageCreateWithoutTranslationsInput, AdvantageUncheckedCreateWithoutTranslationsInput>
  }

  export type AdvantageUpsertWithoutTranslationsInput = {
    update: XOR<AdvantageUpdateWithoutTranslationsInput, AdvantageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<AdvantageCreateWithoutTranslationsInput, AdvantageUncheckedCreateWithoutTranslationsInput>
    where?: AdvantageWhereInput
  }

  export type AdvantageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: AdvantageWhereInput
    data: XOR<AdvantageUpdateWithoutTranslationsInput, AdvantageUncheckedUpdateWithoutTranslationsInput>
  }

  export type AdvantageUpdateWithoutTranslationsInput = {
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutAdvantagesNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutAdvantagesNestedInput
  }

  export type AdvantageUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutAdvantagesNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type ProductCreateWithoutSpecificationsInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSpecificationsInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSpecificationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
  }

  export type SpecificationTranslationCreateWithoutSpecificationInput = {
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
  }

  export type SpecificationTranslationUncheckedCreateWithoutSpecificationInput = {
    id?: number
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
  }

  export type SpecificationTranslationCreateOrConnectWithoutSpecificationInput = {
    where: SpecificationTranslationWhereUniqueInput
    create: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput>
  }

  export type SpecificationTranslationCreateManySpecificationInputEnvelope = {
    data: SpecificationTranslationCreateManySpecificationInput | SpecificationTranslationCreateManySpecificationInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutSpecificationsInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutSpecificationsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput>
  }

  export type ProductUpsertWithoutSpecificationsInput = {
    update: XOR<ProductUpdateWithoutSpecificationsInput, ProductUncheckedUpdateWithoutSpecificationsInput>
    create: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSpecificationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSpecificationsInput, ProductUncheckedUpdateWithoutSpecificationsInput>
  }

  export type ProductUpdateWithoutSpecificationsInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SpecificationTranslationUpsertWithWhereUniqueWithoutSpecificationInput = {
    where: SpecificationTranslationWhereUniqueInput
    update: XOR<SpecificationTranslationUpdateWithoutSpecificationInput, SpecificationTranslationUncheckedUpdateWithoutSpecificationInput>
    create: XOR<SpecificationTranslationCreateWithoutSpecificationInput, SpecificationTranslationUncheckedCreateWithoutSpecificationInput>
  }

  export type SpecificationTranslationUpdateWithWhereUniqueWithoutSpecificationInput = {
    where: SpecificationTranslationWhereUniqueInput
    data: XOR<SpecificationTranslationUpdateWithoutSpecificationInput, SpecificationTranslationUncheckedUpdateWithoutSpecificationInput>
  }

  export type SpecificationTranslationUpdateManyWithWhereWithoutSpecificationInput = {
    where: SpecificationTranslationScalarWhereInput
    data: XOR<SpecificationTranslationUpdateManyMutationInput, SpecificationTranslationUncheckedUpdateManyWithoutSpecificationInput>
  }

  export type SpecificationTranslationScalarWhereInput = {
    AND?: SpecificationTranslationScalarWhereInput | SpecificationTranslationScalarWhereInput[]
    OR?: SpecificationTranslationScalarWhereInput[]
    NOT?: SpecificationTranslationScalarWhereInput | SpecificationTranslationScalarWhereInput[]
    id?: IntFilter<"SpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"SpecificationTranslation"> | $Enums.LanguageCode
    speed?: StringNullableFilter<"SpecificationTranslation"> | string | null
    paperSpecification?: StringNullableFilter<"SpecificationTranslation"> | string | null
    sizeRange?: StringNullableFilter<"SpecificationTranslation"> | string | null
    specificationId?: IntFilter<"SpecificationTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutSpecificationsInput, ProductTranslationUncheckedUpdateWithoutSpecificationsInput>
    create: XOR<ProductTranslationCreateWithoutSpecificationsInput, ProductTranslationUncheckedCreateWithoutSpecificationsInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutSpecificationsInput, ProductTranslationUncheckedUpdateWithoutSpecificationsInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutSpecificationsInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutSpecificationsInput>
  }

  export type SpecificationCreateWithoutTranslationsInput = {
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    product?: ProductCreateNestedOneWithoutSpecificationsInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationUncheckedCreateWithoutTranslationsInput = {
    id?: number
    categoryId?: number | null
    productId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutSpecificationsInput
  }

  export type SpecificationCreateOrConnectWithoutTranslationsInput = {
    where: SpecificationWhereUniqueInput
    create: XOR<SpecificationCreateWithoutTranslationsInput, SpecificationUncheckedCreateWithoutTranslationsInput>
  }

  export type SpecificationUpsertWithoutTranslationsInput = {
    update: XOR<SpecificationUpdateWithoutTranslationsInput, SpecificationUncheckedUpdateWithoutTranslationsInput>
    create: XOR<SpecificationCreateWithoutTranslationsInput, SpecificationUncheckedCreateWithoutTranslationsInput>
    where?: SpecificationWhereInput
  }

  export type SpecificationUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: SpecificationWhereInput
    data: XOR<SpecificationUpdateWithoutTranslationsInput, SpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type SpecificationUpdateWithoutTranslationsInput = {
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutSpecificationsNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutSpecificationsNestedInput
  }

  export type SpecificationUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutSpecificationsNestedInput
  }

  export type ProductCreateWithoutApplicationDataInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutApplicationDataInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutApplicationDataInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutApplicationDataInput, ProductUncheckedCreateWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationCreateWithoutApplicationDataInput = {
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
  }

  export type ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
  }

  export type ApplicationDataTranslationCreateOrConnectWithoutApplicationDataInput = {
    where: ApplicationDataTranslationWhereUniqueInput
    create: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationCreateManyApplicationDataInputEnvelope = {
    data: ApplicationDataTranslationCreateManyApplicationDataInput | ApplicationDataTranslationCreateManyApplicationDataInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutApplicationDataInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutApplicationDataInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutApplicationDataInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput>
  }

  export type ProductUpsertWithoutApplicationDataInput = {
    update: XOR<ProductUpdateWithoutApplicationDataInput, ProductUncheckedUpdateWithoutApplicationDataInput>
    create: XOR<ProductCreateWithoutApplicationDataInput, ProductUncheckedCreateWithoutApplicationDataInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutApplicationDataInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutApplicationDataInput, ProductUncheckedUpdateWithoutApplicationDataInput>
  }

  export type ProductUpdateWithoutApplicationDataInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutApplicationDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ApplicationDataTranslationUpsertWithWhereUniqueWithoutApplicationDataInput = {
    where: ApplicationDataTranslationWhereUniqueInput
    update: XOR<ApplicationDataTranslationUpdateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedUpdateWithoutApplicationDataInput>
    create: XOR<ApplicationDataTranslationCreateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedCreateWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationUpdateWithWhereUniqueWithoutApplicationDataInput = {
    where: ApplicationDataTranslationWhereUniqueInput
    data: XOR<ApplicationDataTranslationUpdateWithoutApplicationDataInput, ApplicationDataTranslationUncheckedUpdateWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationUpdateManyWithWhereWithoutApplicationDataInput = {
    where: ApplicationDataTranslationScalarWhereInput
    data: XOR<ApplicationDataTranslationUpdateManyMutationInput, ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataInput>
  }

  export type ApplicationDataTranslationScalarWhereInput = {
    AND?: ApplicationDataTranslationScalarWhereInput | ApplicationDataTranslationScalarWhereInput[]
    OR?: ApplicationDataTranslationScalarWhereInput[]
    NOT?: ApplicationDataTranslationScalarWhereInput | ApplicationDataTranslationScalarWhereInput[]
    id?: IntFilter<"ApplicationDataTranslation"> | number
    language?: EnumLanguageCodeFilter<"ApplicationDataTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ApplicationDataTranslation"> | string
    src_alt?: StringNullableFilter<"ApplicationDataTranslation"> | string | null
    applicationDataId?: IntFilter<"ApplicationDataTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutApplicationDataInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutApplicationDataInput, ProductTranslationUncheckedUpdateWithoutApplicationDataInput>
    create: XOR<ProductTranslationCreateWithoutApplicationDataInput, ProductTranslationUncheckedCreateWithoutApplicationDataInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutApplicationDataInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutApplicationDataInput, ProductTranslationUncheckedUpdateWithoutApplicationDataInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutApplicationDataInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutApplicationDataInput>
  }

  export type ApplicationDataCreateWithoutTranslationsInput = {
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    product: ProductCreateNestedOneWithoutApplicationDataInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataUncheckedCreateWithoutTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutApplicationDataInput
  }

  export type ApplicationDataCreateOrConnectWithoutTranslationsInput = {
    where: ApplicationDataWhereUniqueInput
    create: XOR<ApplicationDataCreateWithoutTranslationsInput, ApplicationDataUncheckedCreateWithoutTranslationsInput>
  }

  export type ApplicationDataUpsertWithoutTranslationsInput = {
    update: XOR<ApplicationDataUpdateWithoutTranslationsInput, ApplicationDataUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ApplicationDataCreateWithoutTranslationsInput, ApplicationDataUncheckedCreateWithoutTranslationsInput>
    where?: ApplicationDataWhereInput
  }

  export type ApplicationDataUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ApplicationDataWhereInput
    data: XOR<ApplicationDataUpdateWithoutTranslationsInput, ApplicationDataUncheckedUpdateWithoutTranslationsInput>
  }

  export type ApplicationDataUpdateWithoutTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutApplicationDataNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
  }

  export type ProductCreateWithoutTechnicalSpecificationsInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTechnicalSpecificationsInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTechnicalSpecificationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTechnicalSpecificationsInput, ProductUncheckedCreateWithoutTechnicalSpecificationsInput>
  }

  export type TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput = {
    language: $Enums.LanguageCode
    feature: string
    spec: string
  }

  export type TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput = {
    id?: number
    language: $Enums.LanguageCode
    feature: string
    spec: string
  }

  export type TechnicalSpecificationTranslationCreateOrConnectWithoutTechnicalSpecificationInput = {
    where: TechnicalSpecificationTranslationWhereUniqueInput
    create: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput>
  }

  export type TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInputEnvelope = {
    data: TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInput | TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutTechnicalSpecificationsInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutTechnicalSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput>
  }

  export type ProductUpsertWithoutTechnicalSpecificationsInput = {
    update: XOR<ProductUpdateWithoutTechnicalSpecificationsInput, ProductUncheckedUpdateWithoutTechnicalSpecificationsInput>
    create: XOR<ProductCreateWithoutTechnicalSpecificationsInput, ProductUncheckedCreateWithoutTechnicalSpecificationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTechnicalSpecificationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTechnicalSpecificationsInput, ProductUncheckedUpdateWithoutTechnicalSpecificationsInput>
  }

  export type ProductUpdateWithoutTechnicalSpecificationsInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTechnicalSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TechnicalSpecificationTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationInput = {
    where: TechnicalSpecificationTranslationWhereUniqueInput
    update: XOR<TechnicalSpecificationTranslationUpdateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedUpdateWithoutTechnicalSpecificationInput>
    create: XOR<TechnicalSpecificationTranslationCreateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedCreateWithoutTechnicalSpecificationInput>
  }

  export type TechnicalSpecificationTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationInput = {
    where: TechnicalSpecificationTranslationWhereUniqueInput
    data: XOR<TechnicalSpecificationTranslationUpdateWithoutTechnicalSpecificationInput, TechnicalSpecificationTranslationUncheckedUpdateWithoutTechnicalSpecificationInput>
  }

  export type TechnicalSpecificationTranslationUpdateManyWithWhereWithoutTechnicalSpecificationInput = {
    where: TechnicalSpecificationTranslationScalarWhereInput
    data: XOR<TechnicalSpecificationTranslationUpdateManyMutationInput, TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationInput>
  }

  export type TechnicalSpecificationTranslationScalarWhereInput = {
    AND?: TechnicalSpecificationTranslationScalarWhereInput | TechnicalSpecificationTranslationScalarWhereInput[]
    OR?: TechnicalSpecificationTranslationScalarWhereInput[]
    NOT?: TechnicalSpecificationTranslationScalarWhereInput | TechnicalSpecificationTranslationScalarWhereInput[]
    id?: IntFilter<"TechnicalSpecificationTranslation"> | number
    language?: EnumLanguageCodeFilter<"TechnicalSpecificationTranslation"> | $Enums.LanguageCode
    feature?: StringFilter<"TechnicalSpecificationTranslation"> | string
    spec?: StringFilter<"TechnicalSpecificationTranslation"> | string
    technicalSpecificationId?: IntFilter<"TechnicalSpecificationTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutTechnicalSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedUpdateWithoutTechnicalSpecificationsInput>
    create: XOR<ProductTranslationCreateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedCreateWithoutTechnicalSpecificationsInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutTechnicalSpecificationsInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutTechnicalSpecificationsInput, ProductTranslationUncheckedUpdateWithoutTechnicalSpecificationsInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutTechnicalSpecificationsInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsInput>
  }

  export type TechnicalSpecificationCreateWithoutTranslationsInput = {
    feature_en: string
    spec_en: string
    product: ProductCreateNestedOneWithoutTechnicalSpecificationsInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationUncheckedCreateWithoutTranslationsInput = {
    id?: number
    productId: number
    feature_en: string
    spec_en: string
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutTechnicalSpecificationsInput
  }

  export type TechnicalSpecificationCreateOrConnectWithoutTranslationsInput = {
    where: TechnicalSpecificationWhereUniqueInput
    create: XOR<TechnicalSpecificationCreateWithoutTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutTranslationsInput>
  }

  export type TechnicalSpecificationUpsertWithoutTranslationsInput = {
    update: XOR<TechnicalSpecificationUpdateWithoutTranslationsInput, TechnicalSpecificationUncheckedUpdateWithoutTranslationsInput>
    create: XOR<TechnicalSpecificationCreateWithoutTranslationsInput, TechnicalSpecificationUncheckedCreateWithoutTranslationsInput>
    where?: TechnicalSpecificationWhereInput
  }

  export type TechnicalSpecificationUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: TechnicalSpecificationWhereInput
    data: XOR<TechnicalSpecificationUpdateWithoutTranslationsInput, TechnicalSpecificationUncheckedUpdateWithoutTranslationsInput>
  }

  export type TechnicalSpecificationUpdateWithoutTranslationsInput = {
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTechnicalSpecificationsNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type ProductCreateWithoutRelatedProductsInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRelatedProductsInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRelatedProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRelatedProductsInput, ProductUncheckedCreateWithoutRelatedProductsInput>
  }

  export type RelatedProductTranslationCreateWithoutRelatedProductInput = {
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
  }

  export type RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
  }

  export type RelatedProductTranslationCreateOrConnectWithoutRelatedProductInput = {
    where: RelatedProductTranslationWhereUniqueInput
    create: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput>
  }

  export type RelatedProductTranslationCreateManyRelatedProductInputEnvelope = {
    data: RelatedProductTranslationCreateManyRelatedProductInput | RelatedProductTranslationCreateManyRelatedProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutRelatedProductsInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutRelatedProductsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutRelatedProductsInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput>
  }

  export type ProductUpsertWithoutRelatedProductsInput = {
    update: XOR<ProductUpdateWithoutRelatedProductsInput, ProductUncheckedUpdateWithoutRelatedProductsInput>
    create: XOR<ProductCreateWithoutRelatedProductsInput, ProductUncheckedCreateWithoutRelatedProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRelatedProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRelatedProductsInput, ProductUncheckedUpdateWithoutRelatedProductsInput>
  }

  export type ProductUpdateWithoutRelatedProductsInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRelatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type RelatedProductTranslationUpsertWithWhereUniqueWithoutRelatedProductInput = {
    where: RelatedProductTranslationWhereUniqueInput
    update: XOR<RelatedProductTranslationUpdateWithoutRelatedProductInput, RelatedProductTranslationUncheckedUpdateWithoutRelatedProductInput>
    create: XOR<RelatedProductTranslationCreateWithoutRelatedProductInput, RelatedProductTranslationUncheckedCreateWithoutRelatedProductInput>
  }

  export type RelatedProductTranslationUpdateWithWhereUniqueWithoutRelatedProductInput = {
    where: RelatedProductTranslationWhereUniqueInput
    data: XOR<RelatedProductTranslationUpdateWithoutRelatedProductInput, RelatedProductTranslationUncheckedUpdateWithoutRelatedProductInput>
  }

  export type RelatedProductTranslationUpdateManyWithWhereWithoutRelatedProductInput = {
    where: RelatedProductTranslationScalarWhereInput
    data: XOR<RelatedProductTranslationUpdateManyMutationInput, RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductInput>
  }

  export type RelatedProductTranslationScalarWhereInput = {
    AND?: RelatedProductTranslationScalarWhereInput | RelatedProductTranslationScalarWhereInput[]
    OR?: RelatedProductTranslationScalarWhereInput[]
    NOT?: RelatedProductTranslationScalarWhereInput | RelatedProductTranslationScalarWhereInput[]
    id?: IntFilter<"RelatedProductTranslation"> | number
    language?: EnumLanguageCodeFilter<"RelatedProductTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"RelatedProductTranslation"> | string
    description?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    imageAlt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    category_Alt?: StringNullableFilter<"RelatedProductTranslation"> | string | null
    machineType?: EnumMachineTypeFilter<"RelatedProductTranslation"> | $Enums.MachineType
    relatedProductId?: IntFilter<"RelatedProductTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutRelatedProductsInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutRelatedProductsInput, ProductTranslationUncheckedUpdateWithoutRelatedProductsInput>
    create: XOR<ProductTranslationCreateWithoutRelatedProductsInput, ProductTranslationUncheckedCreateWithoutRelatedProductsInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutRelatedProductsInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutRelatedProductsInput, ProductTranslationUncheckedUpdateWithoutRelatedProductsInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutRelatedProductsInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutRelatedProductsInput>
  }

  export type RelatedProductCreateWithoutTranslationsInput = {
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    product: ProductCreateNestedOneWithoutRelatedProductsInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductUncheckedCreateWithoutTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutRelatedProductsInput
  }

  export type RelatedProductCreateOrConnectWithoutTranslationsInput = {
    where: RelatedProductWhereUniqueInput
    create: XOR<RelatedProductCreateWithoutTranslationsInput, RelatedProductUncheckedCreateWithoutTranslationsInput>
  }

  export type RelatedProductUpsertWithoutTranslationsInput = {
    update: XOR<RelatedProductUpdateWithoutTranslationsInput, RelatedProductUncheckedUpdateWithoutTranslationsInput>
    create: XOR<RelatedProductCreateWithoutTranslationsInput, RelatedProductUncheckedCreateWithoutTranslationsInput>
    where?: RelatedProductWhereInput
  }

  export type RelatedProductUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: RelatedProductWhereInput
    data: XOR<RelatedProductUpdateWithoutTranslationsInput, RelatedProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type RelatedProductUpdateWithoutTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    product?: ProductUpdateOneRequiredWithoutRelatedProductsNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutRelatedProductsNestedInput
  }

  export type RelatedProductUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutRelatedProductsNestedInput
  }

  export type ProductCreateWithoutProcessStepsInput = {
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductsInput
    specifications?: SpecificationCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProcessStepsInput = {
    id?: number
    model_name_en: string
    product_name?: string | null
    productImage?: string | null
    productImage_Alt?: string | null
    status_en?: string | null
    stars?: number | null
    reviews?: number | null
    productDescription_en?: string | null
    model_description?: string | null
    introduction?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    modelSpecification?: modelSpecificationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProcessStepsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProcessStepsInput, ProductUncheckedCreateWithoutProcessStepsInput>
  }

  export type ProcessStepTranslationCreateWithoutProcessStepInput = {
    language: $Enums.LanguageCode
    title: string
    description: string
  }

  export type ProcessStepTranslationUncheckedCreateWithoutProcessStepInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description: string
  }

  export type ProcessStepTranslationCreateOrConnectWithoutProcessStepInput = {
    where: ProcessStepTranslationWhereUniqueInput
    create: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput>
  }

  export type ProcessStepTranslationCreateManyProcessStepInputEnvelope = {
    data: ProcessStepTranslationCreateManyProcessStepInput | ProcessStepTranslationCreateManyProcessStepInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutProcessStepsInput = {
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    product: ProductCreateNestedOneWithoutTranslationsInput
    categories?: CategoryTranslationCreateNestedManyWithoutProductsInput
    advantages?: AdvantageCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationUncheckedCreateWithoutProcessStepsInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
    productId: number
    categories?: CategoryTranslationUncheckedCreateNestedManyWithoutProductsInput
    advantages?: AdvantageUncheckedCreateNestedManyWithoutProductTranslationsInput
    specifications?: SpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    applicationData?: ApplicationDataUncheckedCreateNestedManyWithoutProductTranslationsInput
    technicalSpecifications?: TechnicalSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
    relatedProducts?: RelatedProductUncheckedCreateNestedManyWithoutProductTranslationsInput
    modelSpecifications?: modelSpecificationUncheckedCreateNestedManyWithoutProductTranslationsInput
  }

  export type ProductTranslationCreateOrConnectWithoutProcessStepsInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput>
  }

  export type ProductUpsertWithoutProcessStepsInput = {
    update: XOR<ProductUpdateWithoutProcessStepsInput, ProductUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<ProductCreateWithoutProcessStepsInput, ProductUncheckedCreateWithoutProcessStepsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProcessStepsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProcessStepsInput, ProductUncheckedUpdateWithoutProcessStepsInput>
  }

  export type ProductUpdateWithoutProcessStepsInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProcessStepTranslationUpsertWithWhereUniqueWithoutProcessStepInput = {
    where: ProcessStepTranslationWhereUniqueInput
    update: XOR<ProcessStepTranslationUpdateWithoutProcessStepInput, ProcessStepTranslationUncheckedUpdateWithoutProcessStepInput>
    create: XOR<ProcessStepTranslationCreateWithoutProcessStepInput, ProcessStepTranslationUncheckedCreateWithoutProcessStepInput>
  }

  export type ProcessStepTranslationUpdateWithWhereUniqueWithoutProcessStepInput = {
    where: ProcessStepTranslationWhereUniqueInput
    data: XOR<ProcessStepTranslationUpdateWithoutProcessStepInput, ProcessStepTranslationUncheckedUpdateWithoutProcessStepInput>
  }

  export type ProcessStepTranslationUpdateManyWithWhereWithoutProcessStepInput = {
    where: ProcessStepTranslationScalarWhereInput
    data: XOR<ProcessStepTranslationUpdateManyMutationInput, ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepInput>
  }

  export type ProcessStepTranslationScalarWhereInput = {
    AND?: ProcessStepTranslationScalarWhereInput | ProcessStepTranslationScalarWhereInput[]
    OR?: ProcessStepTranslationScalarWhereInput[]
    NOT?: ProcessStepTranslationScalarWhereInput | ProcessStepTranslationScalarWhereInput[]
    id?: IntFilter<"ProcessStepTranslation"> | number
    language?: EnumLanguageCodeFilter<"ProcessStepTranslation"> | $Enums.LanguageCode
    title?: StringFilter<"ProcessStepTranslation"> | string
    description?: StringFilter<"ProcessStepTranslation"> | string
    processStepId?: IntFilter<"ProcessStepTranslation"> | number
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutProcessStepsInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutProcessStepsInput, ProductTranslationUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<ProductTranslationCreateWithoutProcessStepsInput, ProductTranslationUncheckedCreateWithoutProcessStepsInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutProcessStepsInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutProcessStepsInput, ProductTranslationUncheckedUpdateWithoutProcessStepsInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutProcessStepsInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutProcessStepsInput>
  }

  export type ProcessStepCreateWithoutTranslationsInput = {
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    product: ProductCreateNestedOneWithoutProcessStepsInput
    productTranslations?: ProductTranslationCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepUncheckedCreateWithoutTranslationsInput = {
    id?: number
    productId: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
    productTranslations?: ProductTranslationUncheckedCreateNestedManyWithoutProcessStepsInput
  }

  export type ProcessStepCreateOrConnectWithoutTranslationsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutTranslationsInput, ProcessStepUncheckedCreateWithoutTranslationsInput>
  }

  export type ProcessStepUpsertWithoutTranslationsInput = {
    update: XOR<ProcessStepUpdateWithoutTranslationsInput, ProcessStepUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ProcessStepCreateWithoutTranslationsInput, ProcessStepUncheckedCreateWithoutTranslationsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutTranslationsInput, ProcessStepUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProcessStepUpdateWithoutTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutProcessStepsNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutProcessStepsNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutProcessStepsNestedInput
  }

  export type CTATranslationCreateWithoutCtaInput = {
    language: $Enums.LanguageCode
    text: string
    description?: string | null
  }

  export type CTATranslationUncheckedCreateWithoutCtaInput = {
    id?: number
    language: $Enums.LanguageCode
    text: string
    description?: string | null
  }

  export type CTATranslationCreateOrConnectWithoutCtaInput = {
    where: CTATranslationWhereUniqueInput
    create: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput>
  }

  export type CTATranslationCreateManyCtaInputEnvelope = {
    data: CTATranslationCreateManyCtaInput | CTATranslationCreateManyCtaInput[]
    skipDuplicates?: boolean
  }

  export type CTATranslationUpsertWithWhereUniqueWithoutCtaInput = {
    where: CTATranslationWhereUniqueInput
    update: XOR<CTATranslationUpdateWithoutCtaInput, CTATranslationUncheckedUpdateWithoutCtaInput>
    create: XOR<CTATranslationCreateWithoutCtaInput, CTATranslationUncheckedCreateWithoutCtaInput>
  }

  export type CTATranslationUpdateWithWhereUniqueWithoutCtaInput = {
    where: CTATranslationWhereUniqueInput
    data: XOR<CTATranslationUpdateWithoutCtaInput, CTATranslationUncheckedUpdateWithoutCtaInput>
  }

  export type CTATranslationUpdateManyWithWhereWithoutCtaInput = {
    where: CTATranslationScalarWhereInput
    data: XOR<CTATranslationUpdateManyMutationInput, CTATranslationUncheckedUpdateManyWithoutCtaInput>
  }

  export type CTATranslationScalarWhereInput = {
    AND?: CTATranslationScalarWhereInput | CTATranslationScalarWhereInput[]
    OR?: CTATranslationScalarWhereInput[]
    NOT?: CTATranslationScalarWhereInput | CTATranslationScalarWhereInput[]
    id?: IntFilter<"CTATranslation"> | number
    language?: EnumLanguageCodeFilter<"CTATranslation"> | $Enums.LanguageCode
    text?: StringFilter<"CTATranslation"> | string
    description?: StringNullableFilter<"CTATranslation"> | string | null
    ctaId?: IntFilter<"CTATranslation"> | number
  }

  export type CTACreateWithoutTranslationsInput = {
    text_en: string
    description_en?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CTAUncheckedCreateWithoutTranslationsInput = {
    id?: number
    text_en: string
    description_en?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CTACreateOrConnectWithoutTranslationsInput = {
    where: CTAWhereUniqueInput
    create: XOR<CTACreateWithoutTranslationsInput, CTAUncheckedCreateWithoutTranslationsInput>
  }

  export type CTAUpsertWithoutTranslationsInput = {
    update: XOR<CTAUpdateWithoutTranslationsInput, CTAUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CTACreateWithoutTranslationsInput, CTAUncheckedCreateWithoutTranslationsInput>
    where?: CTAWhereInput
  }

  export type CTAUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CTAWhereInput
    data: XOR<CTAUpdateWithoutTranslationsInput, CTAUncheckedUpdateWithoutTranslationsInput>
  }

  export type CTAUpdateWithoutTranslationsInput = {
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CTAUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateWithoutTranslationTasksInput = {
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageCreateNestedManyWithoutApiKeyInput
    auditLogs?: AuditLogCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateWithoutTranslationTasksInput = {
    id?: number
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyCreateOrConnectWithoutTranslationTasksInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutTranslationTasksInput, ApiKeyUncheckedCreateWithoutTranslationTasksInput>
  }

  export type ApiKeyUpsertWithoutTranslationTasksInput = {
    update: XOR<ApiKeyUpdateWithoutTranslationTasksInput, ApiKeyUncheckedUpdateWithoutTranslationTasksInput>
    create: XOR<ApiKeyCreateWithoutTranslationTasksInput, ApiKeyUncheckedCreateWithoutTranslationTasksInput>
    where?: ApiKeyWhereInput
  }

  export type ApiKeyUpdateToOneWithWhereWithoutTranslationTasksInput = {
    where?: ApiKeyWhereInput
    data: XOR<ApiKeyUpdateWithoutTranslationTasksInput, ApiKeyUncheckedUpdateWithoutTranslationTasksInput>
  }

  export type ApiKeyUpdateWithoutTranslationTasksInput = {
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUpdateManyWithoutApiKeyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutTranslationTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUsageCreateWithoutApiKeyInput = {
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
  }

  export type ApiKeyUsageUncheckedCreateWithoutApiKeyInput = {
    id?: number
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
  }

  export type ApiKeyUsageCreateOrConnectWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    create: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageCreateManyApiKeyInputEnvelope = {
    data: ApiKeyUsageCreateManyApiKeyInput | ApiKeyUsageCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutApiKeyInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    apiConfig?: ApiConfigCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutApiKeyInput = {
    id?: number
    userId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutApiKeyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput>
  }

  export type AuditLogCreateManyApiKeyInputEnvelope = {
    data: AuditLogCreateManyApiKeyInput | AuditLogCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type TranslationTaskCreateWithoutApiKeyInput = {
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiUrl?: string | null
  }

  export type TranslationTaskUncheckedCreateWithoutApiKeyInput = {
    id?: number
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiUrl?: string | null
  }

  export type TranslationTaskCreateOrConnectWithoutApiKeyInput = {
    where: TranslationTaskWhereUniqueInput
    create: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput>
  }

  export type TranslationTaskCreateManyApiKeyInputEnvelope = {
    data: TranslationTaskCreateManyApiKeyInput | TranslationTaskCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyUsageUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    update: XOR<ApiKeyUsageUpdateWithoutApiKeyInput, ApiKeyUsageUncheckedUpdateWithoutApiKeyInput>
    create: XOR<ApiKeyUsageCreateWithoutApiKeyInput, ApiKeyUsageUncheckedCreateWithoutApiKeyInput>
  }

  export type ApiKeyUsageUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: ApiKeyUsageWhereUniqueInput
    data: XOR<ApiKeyUsageUpdateWithoutApiKeyInput, ApiKeyUsageUncheckedUpdateWithoutApiKeyInput>
  }

  export type ApiKeyUsageUpdateManyWithWhereWithoutApiKeyInput = {
    where: ApiKeyUsageScalarWhereInput
    data: XOR<ApiKeyUsageUpdateManyMutationInput, ApiKeyUsageUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type ApiKeyUsageScalarWhereInput = {
    AND?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
    OR?: ApiKeyUsageScalarWhereInput[]
    NOT?: ApiKeyUsageScalarWhereInput | ApiKeyUsageScalarWhereInput[]
    id?: IntFilter<"ApiKeyUsage"> | number
    apiKeyId?: IntFilter<"ApiKeyUsage"> | number
    requestAt?: DateTimeFilter<"ApiKeyUsage"> | Date | string
    statusCode?: IntFilter<"ApiKeyUsage"> | number
    durationMs?: IntFilter<"ApiKeyUsage"> | number
    endpoint?: StringFilter<"ApiKeyUsage"> | string
    errorMessage?: StringNullableFilter<"ApiKeyUsage"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutApiKeyInput, AuditLogUncheckedUpdateWithoutApiKeyInput>
    create: XOR<AuditLogCreateWithoutApiKeyInput, AuditLogUncheckedCreateWithoutApiKeyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutApiKeyInput, AuditLogUncheckedUpdateWithoutApiKeyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutApiKeyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type TranslationTaskUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: TranslationTaskWhereUniqueInput
    update: XOR<TranslationTaskUpdateWithoutApiKeyInput, TranslationTaskUncheckedUpdateWithoutApiKeyInput>
    create: XOR<TranslationTaskCreateWithoutApiKeyInput, TranslationTaskUncheckedCreateWithoutApiKeyInput>
  }

  export type TranslationTaskUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: TranslationTaskWhereUniqueInput
    data: XOR<TranslationTaskUpdateWithoutApiKeyInput, TranslationTaskUncheckedUpdateWithoutApiKeyInput>
  }

  export type TranslationTaskUpdateManyWithWhereWithoutApiKeyInput = {
    where: TranslationTaskScalarWhereInput
    data: XOR<TranslationTaskUpdateManyMutationInput, TranslationTaskUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type TranslationTaskScalarWhereInput = {
    AND?: TranslationTaskScalarWhereInput | TranslationTaskScalarWhereInput[]
    OR?: TranslationTaskScalarWhereInput[]
    NOT?: TranslationTaskScalarWhereInput | TranslationTaskScalarWhereInput[]
    id?: IntFilter<"TranslationTask"> | number
    entityType?: StringFilter<"TranslationTask"> | string
    entityId?: IntFilter<"TranslationTask"> | number
    texts?: JsonFilter<"TranslationTask">
    language?: EnumLanguageCodeFilter<"TranslationTask"> | $Enums.LanguageCode
    status?: StringFilter<"TranslationTask"> | string
    attempts?: IntFilter<"TranslationTask"> | number
    lastError?: StringNullableFilter<"TranslationTask"> | string | null
    processingStartedAt?: DateTimeNullableFilter<"TranslationTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TranslationTask"> | Date | string
    updatedAt?: DateTimeFilter<"TranslationTask"> | Date | string
    apiKeyId?: IntNullableFilter<"TranslationTask"> | number | null
    apiUrl?: StringNullableFilter<"TranslationTask"> | string | null
  }

  export type ApiKeyCreateWithoutUsageLogsInput = {
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateWithoutUsageLogsInput = {
    id?: number
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyCreateOrConnectWithoutUsageLogsInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
  }

  export type ApiKeyUpsertWithoutUsageLogsInput = {
    update: XOR<ApiKeyUpdateWithoutUsageLogsInput, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    where?: ApiKeyWhereInput
  }

  export type ApiKeyUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ApiKeyWhereInput
    data: XOR<ApiKeyUpdateWithoutUsageLogsInput, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ApiKeyUpdateWithoutUsageLogsInput = {
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutUsageLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type AuditLogCreateWithoutApiConfigInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    apiKey?: ApiKeyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutApiConfigInput = {
    id?: number
    userId?: number | null
    apiKeyId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutApiConfigInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput>
  }

  export type AuditLogCreateManyApiConfigInputEnvelope = {
    data: AuditLogCreateManyApiConfigInput | AuditLogCreateManyApiConfigInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutApiConfigInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutApiConfigInput, AuditLogUncheckedUpdateWithoutApiConfigInput>
    create: XOR<AuditLogCreateWithoutApiConfigInput, AuditLogUncheckedCreateWithoutApiConfigInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutApiConfigInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutApiConfigInput, AuditLogUncheckedUpdateWithoutApiConfigInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutApiConfigInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutApiConfigInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    name: string
    password: string
    avatar?: string | null
    otpToken?: string | null
    otpExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    refreshToken?: string | null
    isApproved?: boolean
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    name: string
    password: string
    avatar?: string | null
    otpToken?: string | null
    otpExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    refreshToken?: string | null
    isApproved?: boolean
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type ApiKeyCreateWithoutAuditLogsInput = {
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    keyValue: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    rateLimitPerMin?: number | null
    rateLimitCount?: number
    rateLimitReset?: Date | string | null
    notes?: string | null
    usageLogs?: ApiKeyUsageUncheckedCreateNestedManyWithoutApiKeyInput
    translationTasks?: TranslationTaskUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyCreateOrConnectWithoutAuditLogsInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutAuditLogsInput, ApiKeyUncheckedCreateWithoutAuditLogsInput>
  }

  export type ApiConfigCreateWithoutAuditLogsInput = {
    name: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type ApiConfigUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type ApiConfigCreateOrConnectWithoutAuditLogsInput = {
    where: ApiConfigWhereUniqueInput
    create: XOR<ApiConfigCreateWithoutAuditLogsInput, ApiConfigUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    otpToken?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApiKeyUpsertWithoutAuditLogsInput = {
    update: XOR<ApiKeyUpdateWithoutAuditLogsInput, ApiKeyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ApiKeyCreateWithoutAuditLogsInput, ApiKeyUncheckedCreateWithoutAuditLogsInput>
    where?: ApiKeyWhereInput
  }

  export type ApiKeyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ApiKeyWhereInput
    data: XOR<ApiKeyUpdateWithoutAuditLogsInput, ApiKeyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ApiKeyUpdateWithoutAuditLogsInput = {
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyValue?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rateLimitPerMin?: NullableIntFieldUpdateOperationsInput | number | null
    rateLimitCount?: IntFieldUpdateOperationsInput | number
    rateLimitReset?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    usageLogs?: ApiKeyUsageUncheckedUpdateManyWithoutApiKeyNestedInput
    translationTasks?: TranslationTaskUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiConfigUpsertWithoutAuditLogsInput = {
    update: XOR<ApiConfigUpdateWithoutAuditLogsInput, ApiConfigUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ApiConfigCreateWithoutAuditLogsInput, ApiConfigUncheckedCreateWithoutAuditLogsInput>
    where?: ApiConfigWhereInput
  }

  export type ApiConfigUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ApiConfigWhereInput
    data: XOR<ApiConfigUpdateWithoutAuditLogsInput, ApiConfigUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ApiConfigUpdateWithoutAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    apiKeyId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: ApiKeyUpdateOneWithoutAuditLogsNestedInput
    apiConfig?: ApiConfigUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryTranslationCreateManyCategoryInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    iconAlt?: string | null
    categoryLink?: string | null
    description?: string | null
  }

  export type ProductUpdateWithoutCategoriesInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryTranslationUpdateWithoutCategoryInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductTranslationUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryTranslationUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductTranslationUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationUpdateWithoutCategoriesInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SpecificationCreateManyProductInput = {
    id?: number
    categoryId?: number | null
    speed_en?: string | null
    paperSpecification_en?: string | null
    sizeRange_en?: string | null
  }

  export type ApplicationDataCreateManyProductInput = {
    id?: number
    title_en: string
    src?: string | null
    src_alt_en?: string | null
  }

  export type TechnicalSpecificationCreateManyProductInput = {
    id?: number
    feature_en: string
    spec_en: string
  }

  export type RelatedProductCreateManyProductInput = {
    id?: number
    title_en: string
    description_en?: string | null
    image?: string | null
    imageAlt_en?: string | null
    category_icon?: string | null
    category_Alt_en?: string | null
    machineType?: $Enums.MachineType
  }

  export type ProcessStepCreateManyProductInput = {
    id?: number
    title_en: string
    description_en: string
    process_image?: string | null
    process_image_alt?: string | null
  }

  export type ProductTranslationCreateManyProductInput = {
    id?: number
    language: $Enums.LanguageCode
    name: string
    imageAlt?: string | null
    status?: string | null
    productDescription?: string | null
    model_description?: string | null
    introduction?: string | null
  }

  export type CategoryUpdateWithoutProductsInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: CategoryTranslationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: CategoryTranslationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_image?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink_en?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image?: NullableStringFieldUpdateOperationsInput | string | null
    specification_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type modelSpecificationUpdateWithoutProductsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    translations?: modelSpecificationTranslationUpdateManyWithoutModelSpecNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type modelSpecificationUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    translations?: modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsNestedInput
  }

  export type modelSpecificationUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageUpdateWithoutProductsInput = {
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    translations?: AdvantageTranslationUpdateManyWithoutAdvantageNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutAdvantagesNestedInput
  }

  export type AdvantageUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    translations?: AdvantageTranslationUncheckedUpdateManyWithoutAdvantageNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type AdvantageUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificationUpdateWithoutProductInput = {
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: SpecificationTranslationUpdateManyWithoutSpecificationNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutSpecificationsNestedInput
  }

  export type SpecificationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: SpecificationTranslationUncheckedUpdateManyWithoutSpecificationNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutSpecificationsNestedInput
  }

  export type SpecificationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataUpdateWithoutProductInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ApplicationDataTranslationUpdateManyWithoutApplicationDataNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TechnicalSpecificationUpdateWithoutProductInput = {
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    translations?: TechnicalSpecificationTranslationUpdateManyWithoutTechnicalSpecificationNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    translations?: TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedProductUpdateWithoutProductInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    translations?: RelatedProductTranslationUpdateManyWithoutRelatedProductNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutRelatedProductsNestedInput
  }

  export type RelatedProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutRelatedProductsNestedInput
  }

  export type RelatedProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type ProcessStepUpdateWithoutProductInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ProcessStepTranslationUpdateManyWithoutProcessStepNestedInput
    productTranslations?: ProductTranslationUpdateManyWithoutProcessStepsNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepNestedInput
    productTranslations?: ProductTranslationUncheckedUpdateManyWithoutProcessStepsNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationUpdateWithoutProductInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryTranslationUpdateWithoutProductsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CategoryTranslationUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryTranslationUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    iconAlt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type AdvantageUpdateWithoutProductTranslationsInput = {
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutAdvantagesNestedInput
    translations?: AdvantageTranslationUpdateManyWithoutAdvantageNestedInput
  }

  export type AdvantageUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutAdvantagesNestedInput
    translations?: AdvantageTranslationUncheckedUpdateManyWithoutAdvantageNestedInput
  }

  export type AdvantageUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    heading_en?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificationUpdateWithoutProductTranslationsInput = {
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutSpecificationsNestedInput
    translations?: SpecificationTranslationUpdateManyWithoutSpecificationNestedInput
  }

  export type SpecificationUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: SpecificationTranslationUncheckedUpdateManyWithoutSpecificationNestedInput
  }

  export type SpecificationUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    speed_en?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification_en?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataUpdateWithoutProductTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutApplicationDataNestedInput
    translations?: ApplicationDataTranslationUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataNestedInput
  }

  export type ApplicationDataUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    src_alt_en?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TechnicalSpecificationUpdateWithoutProductTranslationsInput = {
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTechnicalSpecificationsNestedInput
    translations?: TechnicalSpecificationTranslationUpdateManyWithoutTechnicalSpecificationNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
    translations?: TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationNestedInput
  }

  export type TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    feature_en?: StringFieldUpdateOperationsInput | string
    spec_en?: StringFieldUpdateOperationsInput | string
  }

  export type RelatedProductUpdateWithoutProductTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    product?: ProductUpdateOneRequiredWithoutRelatedProductsNestedInput
    translations?: RelatedProductTranslationUpdateManyWithoutRelatedProductNestedInput
  }

  export type RelatedProductUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
    translations?: RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductNestedInput
  }

  export type RelatedProductUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt_en?: NullableStringFieldUpdateOperationsInput | string | null
    category_icon?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt_en?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type ProcessStepUpdateWithoutProductTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutProcessStepsNestedInput
    translations?: ProcessStepTranslationUpdateManyWithoutProcessStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    process_image?: NullableStringFieldUpdateOperationsInput | string | null
    process_image_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type modelSpecificationUpdateWithoutProductTranslationsInput = {
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutModelSpecificationNestedInput
    translations?: modelSpecificationTranslationUpdateManyWithoutModelSpecNestedInput
  }

  export type modelSpecificationUncheckedUpdateWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutModelSpecificationNestedInput
    translations?: modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecNestedInput
  }

  export type modelSpecificationUncheckedUpdateManyWithoutProductTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_en?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationTranslationCreateManyModelSpecInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
  }

  export type ProductUpdateWithoutModelSpecificationInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutModelSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutModelSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type modelSpecificationTranslationUpdateWithoutModelSpecInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationTranslationUncheckedUpdateWithoutModelSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
  }

  export type modelSpecificationTranslationUncheckedUpdateManyWithoutModelSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUpdateWithoutModelSpecificationsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutModelSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutModelSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type AdvantageTranslationCreateManyAdvantageInput = {
    id?: number
    language: $Enums.LanguageCode
    heading?: string
    title: string
  }

  export type ProductUpdateWithoutAdvantagesInput = {
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdvantagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    modelSpecification?: modelSpecificationUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutAdvantagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    model_name_en?: StringFieldUpdateOperationsInput | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    productImage?: NullableStringFieldUpdateOperationsInput | string | null
    productImage_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    status_en?: NullableStringFieldUpdateOperationsInput | string | null
    stars?: NullableIntFieldUpdateOperationsInput | number | null
    reviews?: NullableIntFieldUpdateOperationsInput | number | null
    productDescription_en?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdvantageTranslationUpdateWithoutAdvantageInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageTranslationUncheckedUpdateWithoutAdvantageInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AdvantageTranslationUncheckedUpdateManyWithoutAdvantageInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    heading?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUpdateWithoutAdvantagesInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutAdvantagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutAdvantagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type SpecificationTranslationCreateManySpecificationInput = {
    id?: number
    language: $Enums.LanguageCode
    speed?: string | null
    paperSpecification?: string | null
    sizeRange?: string | null
  }

  export type SpecificationTranslationUpdateWithoutSpecificationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificationTranslationUncheckedUpdateWithoutSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificationTranslationUncheckedUpdateManyWithoutSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    paperSpecification?: NullableStringFieldUpdateOperationsInput | string | null
    sizeRange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationUpdateWithoutSpecificationsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ApplicationDataTranslationCreateManyApplicationDataInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    src_alt?: string | null
  }

  export type ApplicationDataTranslationUpdateWithoutApplicationDataInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataTranslationUncheckedUpdateWithoutApplicationDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDataTranslationUncheckedUpdateManyWithoutApplicationDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    src_alt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTranslationUpdateWithoutApplicationDataInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutApplicationDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutApplicationDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnicalSpecificationTranslationCreateManyTechnicalSpecificationInput = {
    id?: number
    language: $Enums.LanguageCode
    feature: string
    spec: string
  }

  export type TechnicalSpecificationTranslationUpdateWithoutTechnicalSpecificationInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSpecificationTranslationUncheckedUpdateWithoutTechnicalSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSpecificationTranslationUncheckedUpdateManyWithoutTechnicalSpecificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    feature?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUpdateWithoutTechnicalSpecificationsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutTechnicalSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutTechnicalSpecificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type RelatedProductTranslationCreateManyRelatedProductInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description?: string | null
    imageAlt?: string | null
    category_Alt?: string | null
    machineType: $Enums.MachineType
  }

  export type RelatedProductTranslationUpdateWithoutRelatedProductInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type RelatedProductTranslationUncheckedUpdateWithoutRelatedProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type RelatedProductTranslationUncheckedUpdateManyWithoutRelatedProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    category_Alt?: NullableStringFieldUpdateOperationsInput | string | null
    machineType?: EnumMachineTypeFieldUpdateOperationsInput | $Enums.MachineType
  }

  export type ProductTranslationUpdateWithoutRelatedProductsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutRelatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutRelatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepTranslationCreateManyProcessStepInput = {
    id?: number
    language: $Enums.LanguageCode
    title: string
    description: string
  }

  export type ProcessStepTranslationUpdateWithoutProcessStepInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessStepTranslationUncheckedUpdateWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessStepTranslationUncheckedUpdateManyWithoutProcessStepInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUpdateWithoutProcessStepsInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
    categories?: CategoryTranslationUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    categories?: CategoryTranslationUncheckedUpdateManyWithoutProductsNestedInput
    advantages?: AdvantageUncheckedUpdateManyWithoutProductTranslationsNestedInput
    specifications?: SpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    applicationData?: ApplicationDataUncheckedUpdateManyWithoutProductTranslationsNestedInput
    technicalSpecifications?: TechnicalSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
    relatedProducts?: RelatedProductUncheckedUpdateManyWithoutProductTranslationsNestedInput
    modelSpecifications?: modelSpecificationUncheckedUpdateManyWithoutProductTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProcessStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    name?: StringFieldUpdateOperationsInput | string
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    model_description?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type CTATranslationCreateManyCtaInput = {
    id?: number
    language: $Enums.LanguageCode
    text: string
    description?: string | null
  }

  export type CTATranslationUpdateWithoutCtaInput = {
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CTATranslationUncheckedUpdateWithoutCtaInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CTATranslationUncheckedUpdateManyWithoutCtaInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageCreateManyApiKeyInput = {
    id?: number
    requestAt?: Date | string
    statusCode: number
    durationMs: number
    endpoint: string
    errorMessage?: string | null
  }

  export type AuditLogCreateManyApiKeyInput = {
    id?: number
    userId?: number | null
    apiConfigId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TranslationTaskCreateManyApiKeyInput = {
    id?: number
    entityType: string
    entityId: number
    texts: JsonNullValueInput | InputJsonValue
    language: $Enums.LanguageCode
    status: string
    attempts?: number
    lastError?: string | null
    processingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiUrl?: string | null
  }

  export type ApiKeyUsageUpdateWithoutApiKeyInput = {
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyUsageUncheckedUpdateManyWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusCode?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutApiKeyInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    apiConfig?: ApiConfigUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiConfigId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationTaskUpdateWithoutApiKeyInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranslationTaskUncheckedUpdateWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranslationTaskUncheckedUpdateManyWithoutApiKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    texts?: JsonNullValueInput | InputJsonValue
    language?: EnumLanguageCodeFieldUpdateOperationsInput | $Enums.LanguageCode
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyApiConfigInput = {
    id?: number
    userId?: number | null
    apiKeyId?: number | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutApiConfigInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    apiKey?: ApiKeyUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutApiConfigInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutApiConfigInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    apiKeyId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}